{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/Daily/source/css/style.scss","path":"css/style.scss","modified":0,"renderable":1},{"_id":"themes/Daily/source/images/arrow-left.svg","path":"images/arrow-left.svg","modified":0,"renderable":1},{"_id":"themes/Daily/source/images/arrow-right.svg","path":"images/arrow-right.svg","modified":0,"renderable":1},{"_id":"themes/Daily/source/js/app.js","path":"js/app.js","modified":0,"renderable":1},{"_id":"themes/Daily/source/images/github.svg","path":"images/github.svg","modified":0,"renderable":1},{"_id":"themes/Daily/source/images/mail.svg","path":"images/mail.svg","modified":0,"renderable":1},{"_id":"themes/Daily/source/images/menu.svg","path":"images/menu.svg","modified":0,"renderable":1},{"_id":"themes/Daily/source/images/twitter.svg","path":"images/twitter.svg","modified":0,"renderable":1},{"_id":"themes/Daily/source/images/weibo.svg","path":"images/weibo.svg","modified":0,"renderable":1},{"_id":"source/img/2017/2.jpg","path":"img/2017/2.jpg","modified":0,"renderable":0},{"_id":"source/img/2017/4.jpg","path":"img/2017/4.jpg","modified":0,"renderable":0},{"_id":"source/img/2017/5.jpg","path":"img/2017/5.jpg","modified":0,"renderable":0},{"_id":"source/img/2017/1.jpg","path":"img/2017/1.jpg","modified":0,"renderable":0},{"_id":"source/img/2017/3.jpg","path":"img/2017/3.jpg","modified":0,"renderable":0},{"_id":"source/img/2017/6.jpg","path":"img/2017/6.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"4b333f26b21c41437f066d8bceac5901bba25354","modified":1535452085553},{"_id":"themes/Daily/_config.yml","hash":"181cbe1cd374f77ded1ff0bccd1664f23e0611ff","modified":1532810838000},{"_id":"themes/Daily/README.md","hash":"91f3b2a4eb7a734cd98a9358923a243f4f096f6b","modified":1532810838000},{"_id":"source/_posts/css.md","hash":"a899ca1faafa4b63f22a666bacf6b3bbede2420f","modified":1535451431162},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1535445748675},{"_id":"source/_posts/git.md","hash":"be38e72c58ec9fb513a64c5747fad8b81ea5cf5a","modified":1535451415759},{"_id":"source/_posts/guide.md","hash":"e4658ae2cc4f3a6c29e1fecfea449dd18732188f","modified":1535451408575},{"_id":"source/_posts/debounce_throttle.md","hash":"b7841df7bc19d5210490e1b65d769eba45d2bca6","modified":1535451422466},{"_id":"source/_posts/imgUpload.md","hash":"91f2157e896e3b0e719673868af3e33353e85a05","modified":1535452390804},{"_id":"source/_posts/npm.md","hash":"d55c654ad50c26df9c674d40e0618004fdc9f224","modified":1535451379196},{"_id":"source/_posts/mobile.md","hash":"96ebfc714e3d15159d593c313846e8553041aa69","modified":1535451385878},{"_id":"source/_posts/promise.md","hash":"61c96152c692fad52256fdcb246d8d55144b7276","modified":1535451371020},{"_id":"source/_posts/recursion.md","hash":"a759668addfdad7774932f02057a179f1eb17d88","modified":1535451358781},{"_id":"source/_posts/websocket.md","hash":"c02cf6e2a0ace4b0e5b72f1c8cca2eb848763a70","modified":1535451332704},{"_id":"themes/Daily/languages/en.yml","hash":"2df42359e6646c0c2903ada8411100a8f1d15134","modified":1532810838000},{"_id":"themes/Daily/languages/default.yml","hash":"2df42359e6646c0c2903ada8411100a8f1d15134","modified":1532810838000},{"_id":"source/about/index.md","hash":"c59f150940c5cd1625c76bfa9fad35c8353a4910","modified":1535444673204},{"_id":"themes/Daily/languages/zh-CN.yml","hash":"3e28e97eaf0e172ddee96b2d6f8ba604d90ff24d","modified":1532810838000},{"_id":"themes/Daily/languages/zh-TW.yml","hash":"c727b3550a12ad6f99b13e1b320466f8238f4b54","modified":1532810838000},{"_id":"themes/Daily/layout/archive.ejs","hash":"5afa6387ae87e15a4562822850806c51f471cbe8","modified":1532810838000},{"_id":"themes/Daily/layout/index.ejs","hash":"3317310e01719dd58878fb4b7bd1b41d495800af","modified":1532810838000},{"_id":"themes/Daily/layout/layout.ejs","hash":"cbdce5eecad781dd0cb8e0c6788a9bf5e9359800","modified":1532810838000},{"_id":"themes/Daily/layout/post.ejs","hash":"be2fe9171f1c8f15447b8fe6e69a82cd40a4dead","modified":1532810838000},{"_id":"themes/Daily/layout/tag.ejs","hash":"f13f991cdd2d462cfaff2ead0a110504e10d1d2f","modified":1532810838000},{"_id":"source/_posts/js.md","hash":"0b8a4995aa80891f98f71711c4f1f9a57570a12f","modified":1535451393910},{"_id":"source/img/2017/npm-node.png","hash":"49a11949a86ddb804ca91e65d8d2c34f8ee3a6f1","modified":1532810838000},{"_id":"themes/Daily/layout/_partial/after-footer.ejs","hash":"00588b4db6aeec2d1f7951ee96980764a15e7f4f","modified":1532810838000},{"_id":"themes/Daily/layout/_partial/article-archive.ejs","hash":"32e6d38ac9074922f958126da4eb5cde0ae98da4","modified":1532810838000},{"_id":"themes/Daily/layout/_partial/comment.ejs","hash":"9c8975d87fe1a1aad63cd74affa68f42ec3334e1","modified":1532810838000},{"_id":"themes/Daily/layout/_partial/article-index.ejs","hash":"712c3930f7c5ebb433afedfcd6098d67e28da380","modified":1532810838000},{"_id":"themes/Daily/layout/_partial/head.ejs","hash":"9338cdc926aae79a50733e014e82471202b8fa07","modified":1532810838000},{"_id":"themes/Daily/layout/_partial/footer.ejs","hash":"5f190a7233be1322e744fecd2759b8e8f7042be5","modified":1532810838000},{"_id":"themes/Daily/layout/_partial/nav.ejs","hash":"cb5cb6371ad98a3fafb9d138a4f05b0b13a83edc","modified":1532810838000},{"_id":"themes/Daily/layout/_partial/pagination.ejs","hash":"98af75b95859dc6aae946497f27d7e51f753e5f6","modified":1532810838000},{"_id":"themes/Daily/source/css/_archive.scss","hash":"698f914f037079d1a25b9d86923eac4775b2ec7a","modified":1532810838000},{"_id":"themes/Daily/source/css/_comment.scss","hash":"8f92712c08489332c824d13e9e3d11bd2a0f1fd0","modified":1532810838000},{"_id":"themes/Daily/source/css/_highlight.scss","hash":"66826edd6a7da015a8d8b4b736b51e317bdce88d","modified":1532810838000},{"_id":"themes/Daily/source/css/_mobile.scss","hash":"2b7297a4539e6ae803fe459ef411aa4149b24fcf","modified":1532810838000},{"_id":"themes/Daily/source/css/_normalize.scss","hash":"59fff706bed3120e3d9d6d0092a0372c172ee537","modified":1532810838000},{"_id":"themes/Daily/source/css/_nav.scss","hash":"eebe106b0360ea5d6735c59b524338faf0937d45","modified":1532810838000},{"_id":"themes/Daily/source/css/_daily.scss","hash":"e4261421d6c6af5b20c8e2b36353ea95cadb4eef","modified":1532810838000},{"_id":"themes/Daily/source/css/_post.scss","hash":"64d31b9a7a16e9fd1b2604053ff7ff9b2bd8279c","modified":1532810838000},{"_id":"themes/Daily/source/css/_variables.scss","hash":"44e76284cf3f70c6c914586132b2e51307439cd9","modified":1532810838000},{"_id":"themes/Daily/source/css/style.scss","hash":"163cde007c7fb3debf9f53594c72d6536242f688","modified":1532810838000},{"_id":"themes/Daily/source/images/arrow-left.svg","hash":"4230dcb796a40d7a0f54c68e1ffb1f325ad962a5","modified":1532810838000},{"_id":"themes/Daily/source/images/arrow-right.svg","hash":"98c04bf1be3ca657f1e9697dc63219ade0a5616c","modified":1532810838000},{"_id":"themes/Daily/source/js/app.js","hash":"b74710d1dd7b7d1407b4fcfc9499bc37de69b21e","modified":1532810838000},{"_id":"themes/Daily/source/images/github.svg","hash":"bc2e3f2e54c354acfe64899482f6379d25f04792","modified":1532810838000},{"_id":"themes/Daily/source/images/mail.svg","hash":"18b3549b0447d605ca252fefcaa4d8e11179ce21","modified":1532810838000},{"_id":"themes/Daily/source/images/menu.svg","hash":"a1837ac76bc3e2aaf30450941bfefcb29ba16411","modified":1532810838000},{"_id":"themes/Daily/source/images/twitter.svg","hash":"2bef6c843de0113721c6c5d1676385897a22a446","modified":1532810838000},{"_id":"themes/Daily/source/images/weibo.svg","hash":"ffd43d8ae9f9ec4f5ae8b97cafa9023ac2a4e59b","modified":1532810838000},{"_id":"source/img/2016/201611-ipad-605420_1920.jpg","hash":"8ad79ca8870cbfa3b966623c8292faa44e1373b3","modified":1532810838000},{"_id":"source/img/2018/seaandship.jpg","hash":"7ad88d75b1752a067fb02091dd6b20a3353de1c3","modified":1532810838000},{"_id":"source/img/2016/20160905-ukraine-map-1422625.jpg","hash":"f575de92b16e2a0bc695b65541e3f0b22bf7a07d","modified":1532810838000},{"_id":"source/img/.DS_Store","hash":"de9adc1a9af0aee7f7bd9ded693b6ac412c83a3f","modified":1535451453120},{"_id":"source/img/2017/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1535451269047},{"_id":"source/img/2018/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1535451458130},{"_id":"source/img/2017/4.jpg","hash":"af2c1ebeaa6f32de7ab48a18348d37b88e636752","modified":1535422332000},{"_id":"source/img/2017/3.jpg","hash":"fb41a1b782bf8eaee5dc1296e650a2d5ea0de9f8","modified":1535422332000},{"_id":"source/img/2017/5.jpg","hash":"8bb9b757e71c63dcb5acc4fe81c45d17c66e7d21","modified":1535422332000},{"_id":"source/img/2017/6.jpg","hash":"1e2970d303fabf1f246f97fd98a2a1239badd9a5","modified":1535422332000},{"_id":"source/img/2017/2.jpg","hash":"7e3e36d3178267e4248d82e791e41cfa5e44af97","modified":1535422332000},{"_id":"source/img/2017/1.jpg","hash":"2b0dfdd302978c6b29312fb79404eb2e42c2e6f6","modified":1535422332000},{"_id":"public/about/index.html","hash":"72d6f80efbd706b2b8c73e3f2c82c0238ca2b024","modified":1535452734903},{"_id":"public/2018/07/mobile/index.html","hash":"08a02e2dcdacb67c9d67bff1ce60bcf338c6aed9","modified":1535452734909},{"_id":"public/2018/04/git/index.html","hash":"e692764599d795282f7545cdfe2f62ebad61a99a","modified":1535452734910},{"_id":"public/2018/02/recursion/index.html","hash":"17bfa46f8d80930c43e05c38a84ffb509a62cbbd","modified":1535452734910},{"_id":"public/2017/10/websocket/index.html","hash":"1128b1d9818fbae3054098a4d0cbf39eee8cb0bb","modified":1535452734910},{"_id":"public/tags/css/index.html","hash":"0480c5dcb136421d095c2e13b2ed02780d07bb06","modified":1535452734910},{"_id":"public/tags/git/index.html","hash":"320cbd6b984d47b84ae6b1597f3fb2467338c2e1","modified":1535452734910},{"_id":"public/tags/js/index.html","hash":"c5e3261032bc495531ea7539de425da830452eb0","modified":1535452734911},{"_id":"public/tags/构建/index.html","hash":"2b78465a883ef933ffb5812c83629a6a0fdebe08","modified":1535452734911},{"_id":"public/tags/移动端/index.html","hash":"0f406ee0f7b535f2d8534738417b53c3042a1872","modified":1535452734911},{"_id":"public/tags/promise/index.html","hash":"12ee66c01c45494be4c1cd777b6f249fd514c2f9","modified":1535452734911},{"_id":"public/tags/websocket/index.html","hash":"de95b4774fbc225fc929c0300d3e8b0b234d29a5","modified":1535452734911},{"_id":"public/archives/index.html","hash":"631605124b2298de8b9078061e7b481ae6a71eb6","modified":1535452734911},{"_id":"public/archives/page/2/index.html","hash":"631605124b2298de8b9078061e7b481ae6a71eb6","modified":1535452734911},{"_id":"public/archives/2017/index.html","hash":"bab919561f3c6e8cf8996d0435c95cd82e10c4c6","modified":1535452734911},{"_id":"public/archives/2017/10/index.html","hash":"324df38e3c16ee2d6b20388af510cdddcba93327","modified":1535452734911},{"_id":"public/archives/2017/11/index.html","hash":"b1d2fe6d9ced050eef2ef5c394114eaa8eb7b0ca","modified":1535452734911},{"_id":"public/archives/2017/12/index.html","hash":"59a3ffe78f38aefb945ec04a212e0373604a64ae","modified":1535452734911},{"_id":"public/archives/2018/index.html","hash":"3eceeea39df99b85b5dd50b3a1ef5e38c64ce2f0","modified":1535452734911},{"_id":"public/archives/2018/01/index.html","hash":"7fae4ddcfe40dbc11f811b5ccc12c291556d903f","modified":1535452734911},{"_id":"public/archives/2018/02/index.html","hash":"ed0483a678ceb228aaf80a44b2c0e3efc1020482","modified":1535452734911},{"_id":"public/archives/2018/03/index.html","hash":"3d00b1734c7847fab07738b9ae49d9810a0b4d24","modified":1535452734911},{"_id":"public/archives/2018/04/index.html","hash":"0fb35e5708658937516f6211050185741fadd31a","modified":1535452734911},{"_id":"public/archives/2018/05/index.html","hash":"95f9ef4b5a5fce0b8b802205f4d0719857f6c668","modified":1535452734911},{"_id":"public/archives/2018/06/index.html","hash":"715221b608ce97e9dde553c10ceea5bbc14dba28","modified":1535452734911},{"_id":"public/archives/2018/07/index.html","hash":"356cdff96aa81738668b75fa03a6b10ec6e68072","modified":1535452734912},{"_id":"public/archives/2018/08/index.html","hash":"6c10aa1c623e76c4fb2a7d4465eaa69de039e5ca","modified":1535452734912},{"_id":"public/index.html","hash":"f1a1d6442c0f65b83d980530ff75eaf81396b82a","modified":1535452734912},{"_id":"public/2018/08/imgUpload/index.html","hash":"dfb3a84f29b1ab6360f09ace88a7873de4dfb72a","modified":1535452734912},{"_id":"public/2018/06/js/index.html","hash":"48f1b71dc677810b925ee7332ca39f61b70a5ede","modified":1535452734912},{"_id":"public/2018/05/promise/index.html","hash":"d2a14485358bcdee15ada32bbaf53a63c80e2fce","modified":1535452734912},{"_id":"public/2018/03/css/index.html","hash":"ae8e34b59c4d4fd69051a0c8f5296c5e3791de14","modified":1535452734912},{"_id":"public/2018/01/debounce_throttle/index.html","hash":"0ff29331b7cb90ac086180d51927de796a039b1b","modified":1535452734912},{"_id":"public/2017/12/guide/index.html","hash":"49eeb50e1ecf0a65d7b671c65706ff7b2ad3b70a","modified":1535452734912},{"_id":"public/2017/11/npm/index.html","hash":"c8b4907838eb1ee74451e0b42eada82eb2e5e3a9","modified":1535452734912},{"_id":"public/page/2/index.html","hash":"e7ebe68a8c42cff9a4c065e2ec6213331aaa18a4","modified":1535452734921},{"_id":"public/page/3/index.html","hash":"367f6b13e1a6af4b6758d51b3a192023a57eceff","modified":1535452734921},{"_id":"public/images/arrow-left.svg","hash":"4230dcb796a40d7a0f54c68e1ffb1f325ad962a5","modified":1535452734921},{"_id":"public/images/arrow-right.svg","hash":"98c04bf1be3ca657f1e9697dc63219ade0a5616c","modified":1535452734922},{"_id":"public/images/github.svg","hash":"bc2e3f2e54c354acfe64899482f6379d25f04792","modified":1535452734922},{"_id":"public/images/mail.svg","hash":"18b3549b0447d605ca252fefcaa4d8e11179ce21","modified":1535452734922},{"_id":"public/images/menu.svg","hash":"a1837ac76bc3e2aaf30450941bfefcb29ba16411","modified":1535452734922},{"_id":"public/images/twitter.svg","hash":"2bef6c843de0113721c6c5d1676385897a22a446","modified":1535452734922},{"_id":"public/images/weibo.svg","hash":"ffd43d8ae9f9ec4f5ae8b97cafa9023ac2a4e59b","modified":1535452734922},{"_id":"public/img/2017/4.jpg","hash":"af2c1ebeaa6f32de7ab48a18348d37b88e636752","modified":1535452734969},{"_id":"public/img/2017/5.jpg","hash":"8bb9b757e71c63dcb5acc4fe81c45d17c66e7d21","modified":1535452734970},{"_id":"public/img/2017/3.jpg","hash":"fb41a1b782bf8eaee5dc1296e650a2d5ea0de9f8","modified":1535452734970},{"_id":"public/js/app.js","hash":"b74710d1dd7b7d1407b4fcfc9499bc37de69b21e","modified":1535452734975},{"_id":"public/css/style.css","hash":"6fd4284f12f69536a57cd1e3cb8bc408f3a4a38e","modified":1535452734977},{"_id":"public/img/2017/6.jpg","hash":"1e2970d303fabf1f246f97fd98a2a1239badd9a5","modified":1535452734981},{"_id":"public/img/2017/2.jpg","hash":"7e3e36d3178267e4248d82e791e41cfa5e44af97","modified":1535452734986},{"_id":"public/img/2017/1.jpg","hash":"2b0dfdd302978c6b29312fb79404eb2e42c2e6f6","modified":1535452734993}],"Category":[],"Data":[],"Page":[{"title":"关于本站","date":"2017-02-12T12:19:00.000Z","layout":"page","comments":0,"_content":"\n每天清晨都害怕地铁太拥攘，一到深夜又担心房间太空荡。\n\n<p align=\"right\" style=\"margin-top:40px\">——《这是你想要的生活吗》</p>\n<br>\n<br>\n","source":"about/index.md","raw":"title: 关于本站  \ndate: 2017-02-12 20:19  \nlayout: page  \ncomments: false  \n---\n\n每天清晨都害怕地铁太拥攘，一到深夜又担心房间太空荡。\n\n<p align=\"right\" style=\"margin-top:40px\">——《这是你想要的生活吗》</p>\n<br>\n<br>\n","updated":"2018-08-28T08:24:33.204Z","path":"about/index.html","_id":"cjldh03qk0001uv6xikja0auc","content":"<p>每天清晨都害怕地铁太拥攘，一到深夜又担心房间太空荡。</p>\n<p></p><p align=\"right\" style=\"margin-top:40px\">——《这是你想要的生活吗》</p><br><br><br><br><p></p>\n","site":{"data":{}},"excerpt":"","more":"<p>每天清晨都害怕地铁太拥攘，一到深夜又担心房间太空荡。</p>\n<p></p><p align=\"right\" style=\"margin-top:40px\">——《这是你想要的生活吗》</p><br><br><br><br><p></p>\n"}],"Post":[{"title":"重拾那些逐渐退化的CSS能力","date":"2018-03-28T14:01:00.000Z","modified":"2018-03-29 21:01","photos":["/img/2017/3.jpg"],"_content":"\n在这个js当道的前端届里，号称要用js写操作系统，js真的牛逼啊，写得了前端，做得了后台，码得了客户端桌面应用，不管是小程序还是新出的快应用统统都离不开js,谁还记得曾经的那个页面仔。与一个像素去较真，写了不知道多少牛逼哄哄的hack，多少个日与夜在做IE兼容。如今你有多久没有关注过html、css的更新，你的css能力退化了吗？\n\n<!--more-->\n\n### 源起\nspan元素是否可以用padding撑开宽高，”不能啊”！真的吗，确定没有记错吗，来，实验是检验真理的唯一标准。\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n\t<title></title>\n</head>\n<style type=\"text/css\">\n\tbody{margin: 0;padding: 0}\n\tdiv{\n\t\tcolor: #000;\n\t\t/*margin-bottom: 30px;*/ /*取消注释第二步，运行看效果*/\n\t}\n\tspan{\n\t\tpadding:20px;\n\t\tbackground-color: #000;\n\t\tcolor: #fff;\n\t\ttext-align: center;\n\t\tfont-size: 20px;\n\t\tmargin:20px;\n\t}\n\t\n</style>\n<body>\n\t<!-- <div>神奇啊</div> --> <!-- 取消注释第一步，运行看效果 -->\n\t<span>我是span</span>\t\n</div>\n</body>\n</html>\n```\n由此我们可以得出：\n\n```\nspan设置内外边距问题\n1、margin：\nspan标签设置margin-left/right均好使，margin-top/bottom不好使；\n2、padding： \nspan标签设置padding好使，但span标签上面无元素时，padding-top 不好使；span标签上面有元素时，padding-top会把上面的元素盖住.\n```\n天啊，太神奇了！太神奇了！为什么，为什么啊？？？？\n等等，我还有疑问，那span可以设置line-height撑开里面的高度吗？\n### html元素的标签分类\n曾经我的字典里只有行内元素和块级元素，inline & block，事实上：\n![GitHub set up](https://shuangmuyingzi.github.io/img/cssTu.png)\nHTML5中，元素主要分为7类：\nMetadata\nFlow\nSectioning\nHeading\nPhrasing\nEmbedded\nInteractive\n这些分类集合互相之间也存在一定的交集(一个元素可以同时属于多个分类)\n#### Metadata（元数据元素）\n顾名思义，Metadata元素意指那些定义文档元数据信息的元素 — 其作用包括：影响文档中其它节点的展现与行为、定义文档与其它外部资源之间的关系等。\n\n```\nbase, link, meta, noscript, script, style, template, title\n```\n#### Flow（流式元素）\n所有可以放在body标签内，构成文档内容的元素均属于Flow元素。因此，除了base, link, meta, style, title等只能放在head标签内的元素外，剩下的所有元素均属于Flow元素。\n\n```\na， abbr， address， area（如果它是map元素的后裔）， article， aside， audio， b， bdi， bdo， blockquote， br， button， canvas， cite， code， command， datalist， del， details， dfn， div， dl，em， embed， fieldset， figure， footer， form， h1， h2， h3， h4， h5， h6， header， hgroup， hr， i， iframe， img， input， ins， kbd， keygen， label， map， mark， math， menu， meter，nav， noscript， object， ol， output， p， pre， progress， q， ruby， s， samp， script， section， select， small， span， strong， style（如果该元素设置了scoped属性）， sub， sup， svg， table，textarea， time， u， ul， var， video， wbr， text\n```\n#### Sectioning（章节元素）\nSectioning意指定义页面结构的元素\n\n```\narticle, aside, nav, section\n```\n#### Heading（标题元素）\n所有标题元素属于Heading\n\n```\nh1, h2, h3, h4, h5, h6\n```\n\n#### Phrasing（段落元素）\n所有可以放在p标签内，构成段落内容的元素均属于Phrasing元素。因此，所有Phrasing元素均属于Flow元素。在HTML5标准文档中，关于Phrasing元素的原始定义为：\n\n```\nPhrasing content is the text of the document, as well as elements that mark up that text at the intra-paragraph level. Runs of phrasing content form paragraphs.\n```\n对于这一定义，个人认为不应当使用“text”这一容易引起误解的词，事实上，一个元素即使不是文本，只要能包含在p标签中成为段落内容的一部分，就可以称之为Phrasing元素。\n\n```\na（如果其只包含段落式元素）， abbr， area（如果它是map元素的后裔）， audio， b， bdi， bdo， br， button， canvas， cite， code， command， datalist， del（如果其只包含段落式元素）， dfn， em， embed， i，iframe， img， input， ins（如果其只包含段落式元素）， kbd， keygen， label， map（如果其只包含段落式元素）， mark， math， meter， noscript， object， output， progress， q， ruby， s， samp， script，select， small， span， strong， sub， sup， svg， textarea， time， u， var， video， wbr， text\n```\n#### Embedded（嵌入元素）\n所有用于在网页中嵌入外部资源的元素均属于Embedded元素\n\n```\naudio, video, img, canvas, svg, iframe, embed, object, math\n```\n#### Interactive（交互元素）\n所有与用户交互有关的元素均属于Interactive元素。\n\n```\na， audio（如果设置了controls属性）， button， details， embed， iframe， img（如果设置了usemap属性）， input（如果type属性不为hidden状态）， keygen， label， menu（如果type属性为toolbar状态），object（如果设置了usemap属性）， select， textarea， video（如果设置了controls属性）\n```\n#### Palpable\n所有应当拥有子元素的元素称之为Palpable元素。比如，br元素因不需要子元素，因此也就不属于Palpable。\n\nScript-supporting\n自身不做任何页面展现，但与页面脚本相关的元素\n\n```\nscript, template\n```\n其实这是非规范的，所以不是强求的，新的分类定义了元素的内容模型(Content Model),关键还是要清楚这些元素的特性以及各大浏览器是如何渲染解析的，包括有哪些默认的样式,从而正确嵌套标签以及设置reset.css。\nhttps://html.spec.whatwg.org/multipage/indices.html#element-content-categories\n### W3C 标准盒模型 & IE 怪异盒模型\n页面上显示的每个元素（包括内联元素）都可以看作一个盒子，即盒模型(box model) 盒模型由 4 部分组成，从内到外分别是：`content` `padding` `border` `margin`\n\n![GitHub set up](https://shuangmuyingzi.github.io/img/box-sizing.png)\n`W3C标准盒模型`一个元素的宽度（高度以此类推）应该这样计算：\n\n```\n一个元素的宽度 =  content\n盒子总宽度 = margin-left + border-left + padding-left + width + padding-right + border-right + margin-right\n```\n`而IE 怪异盒模型`一个元素的宽度（高度以此类推）却是这样计算的：\n\n```\n一个元素的宽度 =  content + padding + border\n盒子总宽度 = margin-left + width + margin-right\n```\n#### 解决方案 box-sizing\n```\n// W3C 标准盒模型（浏览器默认）\nbox-sizing: content-box;\n// IE 怪异盒模型\nbox-sizing: border-box;\n```\n当我们设置 box-sizing: border-box; 时，border 和 padding 就被包含在了宽高之内,和IE在非标准的模式下是一致的。\n然而好像看到很多网站为了避免同一份 css 在不同浏览器下表现不同，基本会加上：\n\n```\n*, *:before, *:after {\n  -moz-box-sizing: border-box;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box;\n}\n```\n#### 文档类型（Doctype）\n亲测了下，发现其实当头部设置了html5的头部声明<!DOCTYPE html>，在IE下也全是标准的盒模型了，估计除了历史遗留下的网站，新的全是html5的声明，HTML5 不基于 SGML，所以不需要引用 DTD。可能也就只有一些老家伙才经历过图下的历史：\n![GitHub set up](https://shuangmuyingzi.github.io/img/doctype.png)\n如果有兴趣推荐看这篇关于声明的具体元素意思，毕竟其实很多医院系统，学校系统，政府系统之类可能还是会有旧的，了解下也好。\nhttps://www.jianshu.com/p/c3dcdad42e6d\n\n#### 理解CSS布局和BFC\nCSS布局中有一些概念，一旦理解了这些概念，就能真正的提高你的CSS能力。这篇文章主要介绍的是关于块格式化上下文（Block Formatting Context），也就是大家俗称的BFC。\n\n它是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。也就是说我们平时在布局的时候，它默默地提供了一个环境，使得HTML元素在这个环境中按照一定规则进行布局。\n\n最常见的formatting context有Block Formatting Context(BFC)和Inline Formatting Context(IFC)，CSS3中还增加了GridLayout Formatting Context(GFC)和Flex Formatting Context(FFC)。\n\nBFC的布局规则与触发规则\n刚才我们说到BFC中的元素有一套规定的布局规则：\n\n```\n内部的元素会在垂直方向一个接一个地放置\n元素垂直方向的距离由margin决定，属于同一个BFC的两个相邻元素的margin会发生重叠\n每个元素的左外边距与包含块的左边界相接触(对于从左往右，否则相反)，即使存在浮动也是如此\nBFC的区域不会与float元素重叠\n计算BFC的高度时，浮动元素也参与计算\nBFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此\n```\n刚才我们又提到BFC是一块渲染区域，那这块渲染区域到底在哪，它又是有多大，这些由生成BFC的元素来决定，CSS2.1中规定满足下列CSS声明的元素便会生成BFC（触发规则）：\n\n```\n根元素\nfloat的值不为none\noverflow的值不为visible\nposition的值为absolute或fixed\ndisplay的值为inline-block, table-cell, table-caption, flex, inline-flex, grid\n注：display: table也认为可以生成BFC，主要原因是table会默认生成一个匿名的table-cell，正是这个匿名的table-cell生成了BFC\n```\n上面这些CSS声明的元素生成了BFC，而它们本身并不是BFC，这一点需要区分。\n#### 防止垂直margin重叠\n有点布局经验的朋友都知道margin collapse，也就是相邻的垂直元素同时设置了margin后，实际margin值会塌陷到其中较大的那个值。其根本原理就是它们处于同一个BFC，符合“属于同一个BFC的两个相邻元素的margin会发生重叠”的规则。\n\n我们可以在其中一个元素外面包裹一层容器，并触发该容器生成一个BFC。那么两个元素便属于不同的BFC，就不会发生margin重叠了：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>防止垂直margin重叠</title>\n</head>\n<style>\n    /*.wrap{\n        overflow: hidden;\n    }\n    p{\n        width: 200px;\n        line-height: 100px;\n        margin: 100px;\n        background: #000;\n        color: #fff;\n        text-align: center;\n    }*/\n    .outer { background-color: #ccc; margin: 0 0 40px 0; /*overflow: auto;*/} \n    p { padding: 0; margin: 20px 0 20px 0; background-color: rgb(233,78,119); color: #fff; }\n</style>\n<body>\n    <!-- <p>我属于一个BFC</p>\n    <div class=\"wrap\">\n        <p>我属于另一个BFC</p>\n    </div> -->\n    <div class=\"outer\">\n        <p>我是P</p>\n        <p>我是另一个P</p>\n    </div>\n</body>\n</html>\n\n```\n防止浮动子元素高度塌陷\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>防止浮动子元素高度塌陷</title>\n</head>\n<style>\n    .outer { border: 5px dotted rgb(214,129,137); border-radius: 5px; width: 450px; padding: 10px; margin-bottom: 40px;/*overflow: hidden;*/ } \n    .float { padding: 10px; border: 5px solid rgba(214,129,137,.4); border-radius: 5px; background-color: rgba(233,78,119,.4); color: #fff; float: left; width: 200px; margin: 0 20px 0 0; }\n</style>\n<body>\n    <div class=\"outer\"> \n    \t<div class=\"float\">我是浮动</div> \n    \t我会包裹着浮动\n    </div>\n</body>\n</html>\n```\n如果我们将.outer元素的overflow: hidden去掉，那么.outer元素就获取不到浮动元素的高度了。但是加上overflow属性后触发了BFC，计算BFC的高度时，浮动元素也参与了计算。\n\n防止文字（或其他元素）环绕\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>防止文字（或其他元素）环绕</title>\n</head>\n<style>\n    .parent{\n        width: 300px;\n        border: 3px solid #000;\n    }\n    .child{\n        float: left;\n        width: 100px;\n        height: 100px;\n        border: 3px solid #f00;\n        color: #f00;\n    }\n    .text{\n        /*overflow: hidden;*/\n    }\n</style>\n<body>\n    <div class=\"parent\">\n        <div class=\"child\">float: left</div>\n        <div class=\"text\">我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕</div>\n    </div>\n</body>\n</html>\n```\n正常情况下，如果一个块级元素设置成了float，那么他的兄弟元素会环绕其布局。这里我们给.text加上overflow，文字所在的区域就产生了BFC，元素的左边总是触碰到容器的左边，即使存在浮动也是如此。\n\n以上的都是BFC常见的应用场景以及它的触发规则，\n接下来我们来看看BFC新的触发条件。\n\n#### 创建BFC的新方式\n使用overflow或其他的方法创建BFC时会有两个问题。首先，这些方法本身是有自身的设计目的，所以在使用它们创建BFC时可能会产生副作用。例如，使用overflow创建BFC后在某些情况下可能会看到出现一个滚动条或者元素内容被裁切。这是由于overflow属性的设计是用来让你告诉浏览器如何定义元素的溢出状态的。\n\n最安全的做法应该是创建一个BFC时并不会带来任何副作用，它内部的元素都安全的呆在这个迷你布局中，这种方法不会引起任何意想不到的问题，也可以理解开发者的意图。CSS工作组也十分认同这种想法，所以他们定制了一个新的属性值：display:flow-root。\n\n![GitHub set up](https://shuangmuyingzi.github.io/img/flow-root.png)\n\nCaniuse上display:flow-root各浏览器兼容情况。\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>flow-root</title>\n</head>\n<style>\n    .parent{\n        width: 300px;\n        border: 3px solid #000;\n    }\n    .child{\n        float: left;\n        width: 100px;\n        height: 100px;\n        border: 3px solid #f00;\n        color: #f00;\n    }\n    .text{\n        display: flow-root;\n    }\n</style>\n<body>\n    <div class=\"parent\">\n        <div class=\"child\">float: left</div>\n        <div class=\"text\">我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕</div>\n    </div>\n</body>\n</html>\n```\nvertical-center(水平垂直居中)\n仅居中元素定宽高适用：\n\n[absolute + 负margin](http://yanhaijing.com/vertical-center/absolute1.html)\n[absolute + margin auto](http://yanhaijing.com/vertical-center/absolute2.html)\n[absolute + calc](http://yanhaijing.com/vertical-center/absolute3.html)\n居中元素不定宽高适用：\n\n[absolute + transform](http://yanhaijing.com/vertical-center/absolute4.html)\n[writing-mode](http://yanhaijing.com/vertical-center/writing-mode.html)\n[lineheight](http://yanhaijing.com/vertical-center/lineheight.html)\n[table](http://yanhaijing.com/vertical-center/table.html)\n[css-table](http://yanhaijing.com/vertical-center/css-table.html)\n[flex](http://yanhaijing.com/vertical-center/flex.html)\n[grid](http://yanhaijing.com/vertical-center/grid.html)\n参考链接：\nhttps://www.w3cplus.com/css/understanding-css-layout-block-formatting-context.html\nhttps://segmentfault.com/a/1190000011211625\n\n","source":"_posts/css.md","raw":"title: 重拾那些逐渐退化的CSS能力\ndate: 2018-03-28 22:01\nmodified: 2018-03-29 21:01\ntag:\n - css\n\nphotos:\n - /img/2017/3.jpg \n\n---\n\n在这个js当道的前端届里，号称要用js写操作系统，js真的牛逼啊，写得了前端，做得了后台，码得了客户端桌面应用，不管是小程序还是新出的快应用统统都离不开js,谁还记得曾经的那个页面仔。与一个像素去较真，写了不知道多少牛逼哄哄的hack，多少个日与夜在做IE兼容。如今你有多久没有关注过html、css的更新，你的css能力退化了吗？\n\n<!--more-->\n\n### 源起\nspan元素是否可以用padding撑开宽高，”不能啊”！真的吗，确定没有记错吗，来，实验是检验真理的唯一标准。\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n\t<title></title>\n</head>\n<style type=\"text/css\">\n\tbody{margin: 0;padding: 0}\n\tdiv{\n\t\tcolor: #000;\n\t\t/*margin-bottom: 30px;*/ /*取消注释第二步，运行看效果*/\n\t}\n\tspan{\n\t\tpadding:20px;\n\t\tbackground-color: #000;\n\t\tcolor: #fff;\n\t\ttext-align: center;\n\t\tfont-size: 20px;\n\t\tmargin:20px;\n\t}\n\t\n</style>\n<body>\n\t<!-- <div>神奇啊</div> --> <!-- 取消注释第一步，运行看效果 -->\n\t<span>我是span</span>\t\n</div>\n</body>\n</html>\n```\n由此我们可以得出：\n\n```\nspan设置内外边距问题\n1、margin：\nspan标签设置margin-left/right均好使，margin-top/bottom不好使；\n2、padding： \nspan标签设置padding好使，但span标签上面无元素时，padding-top 不好使；span标签上面有元素时，padding-top会把上面的元素盖住.\n```\n天啊，太神奇了！太神奇了！为什么，为什么啊？？？？\n等等，我还有疑问，那span可以设置line-height撑开里面的高度吗？\n### html元素的标签分类\n曾经我的字典里只有行内元素和块级元素，inline & block，事实上：\n![GitHub set up](https://shuangmuyingzi.github.io/img/cssTu.png)\nHTML5中，元素主要分为7类：\nMetadata\nFlow\nSectioning\nHeading\nPhrasing\nEmbedded\nInteractive\n这些分类集合互相之间也存在一定的交集(一个元素可以同时属于多个分类)\n#### Metadata（元数据元素）\n顾名思义，Metadata元素意指那些定义文档元数据信息的元素 — 其作用包括：影响文档中其它节点的展现与行为、定义文档与其它外部资源之间的关系等。\n\n```\nbase, link, meta, noscript, script, style, template, title\n```\n#### Flow（流式元素）\n所有可以放在body标签内，构成文档内容的元素均属于Flow元素。因此，除了base, link, meta, style, title等只能放在head标签内的元素外，剩下的所有元素均属于Flow元素。\n\n```\na， abbr， address， area（如果它是map元素的后裔）， article， aside， audio， b， bdi， bdo， blockquote， br， button， canvas， cite， code， command， datalist， del， details， dfn， div， dl，em， embed， fieldset， figure， footer， form， h1， h2， h3， h4， h5， h6， header， hgroup， hr， i， iframe， img， input， ins， kbd， keygen， label， map， mark， math， menu， meter，nav， noscript， object， ol， output， p， pre， progress， q， ruby， s， samp， script， section， select， small， span， strong， style（如果该元素设置了scoped属性）， sub， sup， svg， table，textarea， time， u， ul， var， video， wbr， text\n```\n#### Sectioning（章节元素）\nSectioning意指定义页面结构的元素\n\n```\narticle, aside, nav, section\n```\n#### Heading（标题元素）\n所有标题元素属于Heading\n\n```\nh1, h2, h3, h4, h5, h6\n```\n\n#### Phrasing（段落元素）\n所有可以放在p标签内，构成段落内容的元素均属于Phrasing元素。因此，所有Phrasing元素均属于Flow元素。在HTML5标准文档中，关于Phrasing元素的原始定义为：\n\n```\nPhrasing content is the text of the document, as well as elements that mark up that text at the intra-paragraph level. Runs of phrasing content form paragraphs.\n```\n对于这一定义，个人认为不应当使用“text”这一容易引起误解的词，事实上，一个元素即使不是文本，只要能包含在p标签中成为段落内容的一部分，就可以称之为Phrasing元素。\n\n```\na（如果其只包含段落式元素）， abbr， area（如果它是map元素的后裔）， audio， b， bdi， bdo， br， button， canvas， cite， code， command， datalist， del（如果其只包含段落式元素）， dfn， em， embed， i，iframe， img， input， ins（如果其只包含段落式元素）， kbd， keygen， label， map（如果其只包含段落式元素）， mark， math， meter， noscript， object， output， progress， q， ruby， s， samp， script，select， small， span， strong， sub， sup， svg， textarea， time， u， var， video， wbr， text\n```\n#### Embedded（嵌入元素）\n所有用于在网页中嵌入外部资源的元素均属于Embedded元素\n\n```\naudio, video, img, canvas, svg, iframe, embed, object, math\n```\n#### Interactive（交互元素）\n所有与用户交互有关的元素均属于Interactive元素。\n\n```\na， audio（如果设置了controls属性）， button， details， embed， iframe， img（如果设置了usemap属性）， input（如果type属性不为hidden状态）， keygen， label， menu（如果type属性为toolbar状态），object（如果设置了usemap属性）， select， textarea， video（如果设置了controls属性）\n```\n#### Palpable\n所有应当拥有子元素的元素称之为Palpable元素。比如，br元素因不需要子元素，因此也就不属于Palpable。\n\nScript-supporting\n自身不做任何页面展现，但与页面脚本相关的元素\n\n```\nscript, template\n```\n其实这是非规范的，所以不是强求的，新的分类定义了元素的内容模型(Content Model),关键还是要清楚这些元素的特性以及各大浏览器是如何渲染解析的，包括有哪些默认的样式,从而正确嵌套标签以及设置reset.css。\nhttps://html.spec.whatwg.org/multipage/indices.html#element-content-categories\n### W3C 标准盒模型 & IE 怪异盒模型\n页面上显示的每个元素（包括内联元素）都可以看作一个盒子，即盒模型(box model) 盒模型由 4 部分组成，从内到外分别是：`content` `padding` `border` `margin`\n\n![GitHub set up](https://shuangmuyingzi.github.io/img/box-sizing.png)\n`W3C标准盒模型`一个元素的宽度（高度以此类推）应该这样计算：\n\n```\n一个元素的宽度 =  content\n盒子总宽度 = margin-left + border-left + padding-left + width + padding-right + border-right + margin-right\n```\n`而IE 怪异盒模型`一个元素的宽度（高度以此类推）却是这样计算的：\n\n```\n一个元素的宽度 =  content + padding + border\n盒子总宽度 = margin-left + width + margin-right\n```\n#### 解决方案 box-sizing\n```\n// W3C 标准盒模型（浏览器默认）\nbox-sizing: content-box;\n// IE 怪异盒模型\nbox-sizing: border-box;\n```\n当我们设置 box-sizing: border-box; 时，border 和 padding 就被包含在了宽高之内,和IE在非标准的模式下是一致的。\n然而好像看到很多网站为了避免同一份 css 在不同浏览器下表现不同，基本会加上：\n\n```\n*, *:before, *:after {\n  -moz-box-sizing: border-box;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box;\n}\n```\n#### 文档类型（Doctype）\n亲测了下，发现其实当头部设置了html5的头部声明<!DOCTYPE html>，在IE下也全是标准的盒模型了，估计除了历史遗留下的网站，新的全是html5的声明，HTML5 不基于 SGML，所以不需要引用 DTD。可能也就只有一些老家伙才经历过图下的历史：\n![GitHub set up](https://shuangmuyingzi.github.io/img/doctype.png)\n如果有兴趣推荐看这篇关于声明的具体元素意思，毕竟其实很多医院系统，学校系统，政府系统之类可能还是会有旧的，了解下也好。\nhttps://www.jianshu.com/p/c3dcdad42e6d\n\n#### 理解CSS布局和BFC\nCSS布局中有一些概念，一旦理解了这些概念，就能真正的提高你的CSS能力。这篇文章主要介绍的是关于块格式化上下文（Block Formatting Context），也就是大家俗称的BFC。\n\n它是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。也就是说我们平时在布局的时候，它默默地提供了一个环境，使得HTML元素在这个环境中按照一定规则进行布局。\n\n最常见的formatting context有Block Formatting Context(BFC)和Inline Formatting Context(IFC)，CSS3中还增加了GridLayout Formatting Context(GFC)和Flex Formatting Context(FFC)。\n\nBFC的布局规则与触发规则\n刚才我们说到BFC中的元素有一套规定的布局规则：\n\n```\n内部的元素会在垂直方向一个接一个地放置\n元素垂直方向的距离由margin决定，属于同一个BFC的两个相邻元素的margin会发生重叠\n每个元素的左外边距与包含块的左边界相接触(对于从左往右，否则相反)，即使存在浮动也是如此\nBFC的区域不会与float元素重叠\n计算BFC的高度时，浮动元素也参与计算\nBFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此\n```\n刚才我们又提到BFC是一块渲染区域，那这块渲染区域到底在哪，它又是有多大，这些由生成BFC的元素来决定，CSS2.1中规定满足下列CSS声明的元素便会生成BFC（触发规则）：\n\n```\n根元素\nfloat的值不为none\noverflow的值不为visible\nposition的值为absolute或fixed\ndisplay的值为inline-block, table-cell, table-caption, flex, inline-flex, grid\n注：display: table也认为可以生成BFC，主要原因是table会默认生成一个匿名的table-cell，正是这个匿名的table-cell生成了BFC\n```\n上面这些CSS声明的元素生成了BFC，而它们本身并不是BFC，这一点需要区分。\n#### 防止垂直margin重叠\n有点布局经验的朋友都知道margin collapse，也就是相邻的垂直元素同时设置了margin后，实际margin值会塌陷到其中较大的那个值。其根本原理就是它们处于同一个BFC，符合“属于同一个BFC的两个相邻元素的margin会发生重叠”的规则。\n\n我们可以在其中一个元素外面包裹一层容器，并触发该容器生成一个BFC。那么两个元素便属于不同的BFC，就不会发生margin重叠了：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>防止垂直margin重叠</title>\n</head>\n<style>\n    /*.wrap{\n        overflow: hidden;\n    }\n    p{\n        width: 200px;\n        line-height: 100px;\n        margin: 100px;\n        background: #000;\n        color: #fff;\n        text-align: center;\n    }*/\n    .outer { background-color: #ccc; margin: 0 0 40px 0; /*overflow: auto;*/} \n    p { padding: 0; margin: 20px 0 20px 0; background-color: rgb(233,78,119); color: #fff; }\n</style>\n<body>\n    <!-- <p>我属于一个BFC</p>\n    <div class=\"wrap\">\n        <p>我属于另一个BFC</p>\n    </div> -->\n    <div class=\"outer\">\n        <p>我是P</p>\n        <p>我是另一个P</p>\n    </div>\n</body>\n</html>\n\n```\n防止浮动子元素高度塌陷\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>防止浮动子元素高度塌陷</title>\n</head>\n<style>\n    .outer { border: 5px dotted rgb(214,129,137); border-radius: 5px; width: 450px; padding: 10px; margin-bottom: 40px;/*overflow: hidden;*/ } \n    .float { padding: 10px; border: 5px solid rgba(214,129,137,.4); border-radius: 5px; background-color: rgba(233,78,119,.4); color: #fff; float: left; width: 200px; margin: 0 20px 0 0; }\n</style>\n<body>\n    <div class=\"outer\"> \n    \t<div class=\"float\">我是浮动</div> \n    \t我会包裹着浮动\n    </div>\n</body>\n</html>\n```\n如果我们将.outer元素的overflow: hidden去掉，那么.outer元素就获取不到浮动元素的高度了。但是加上overflow属性后触发了BFC，计算BFC的高度时，浮动元素也参与了计算。\n\n防止文字（或其他元素）环绕\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>防止文字（或其他元素）环绕</title>\n</head>\n<style>\n    .parent{\n        width: 300px;\n        border: 3px solid #000;\n    }\n    .child{\n        float: left;\n        width: 100px;\n        height: 100px;\n        border: 3px solid #f00;\n        color: #f00;\n    }\n    .text{\n        /*overflow: hidden;*/\n    }\n</style>\n<body>\n    <div class=\"parent\">\n        <div class=\"child\">float: left</div>\n        <div class=\"text\">我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕</div>\n    </div>\n</body>\n</html>\n```\n正常情况下，如果一个块级元素设置成了float，那么他的兄弟元素会环绕其布局。这里我们给.text加上overflow，文字所在的区域就产生了BFC，元素的左边总是触碰到容器的左边，即使存在浮动也是如此。\n\n以上的都是BFC常见的应用场景以及它的触发规则，\n接下来我们来看看BFC新的触发条件。\n\n#### 创建BFC的新方式\n使用overflow或其他的方法创建BFC时会有两个问题。首先，这些方法本身是有自身的设计目的，所以在使用它们创建BFC时可能会产生副作用。例如，使用overflow创建BFC后在某些情况下可能会看到出现一个滚动条或者元素内容被裁切。这是由于overflow属性的设计是用来让你告诉浏览器如何定义元素的溢出状态的。\n\n最安全的做法应该是创建一个BFC时并不会带来任何副作用，它内部的元素都安全的呆在这个迷你布局中，这种方法不会引起任何意想不到的问题，也可以理解开发者的意图。CSS工作组也十分认同这种想法，所以他们定制了一个新的属性值：display:flow-root。\n\n![GitHub set up](https://shuangmuyingzi.github.io/img/flow-root.png)\n\nCaniuse上display:flow-root各浏览器兼容情况。\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n\t<meta charset=\"UTF-8\">\n\t<title>flow-root</title>\n</head>\n<style>\n    .parent{\n        width: 300px;\n        border: 3px solid #000;\n    }\n    .child{\n        float: left;\n        width: 100px;\n        height: 100px;\n        border: 3px solid #f00;\n        color: #f00;\n    }\n    .text{\n        display: flow-root;\n    }\n</style>\n<body>\n    <div class=\"parent\">\n        <div class=\"child\">float: left</div>\n        <div class=\"text\">我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕</div>\n    </div>\n</body>\n</html>\n```\nvertical-center(水平垂直居中)\n仅居中元素定宽高适用：\n\n[absolute + 负margin](http://yanhaijing.com/vertical-center/absolute1.html)\n[absolute + margin auto](http://yanhaijing.com/vertical-center/absolute2.html)\n[absolute + calc](http://yanhaijing.com/vertical-center/absolute3.html)\n居中元素不定宽高适用：\n\n[absolute + transform](http://yanhaijing.com/vertical-center/absolute4.html)\n[writing-mode](http://yanhaijing.com/vertical-center/writing-mode.html)\n[lineheight](http://yanhaijing.com/vertical-center/lineheight.html)\n[table](http://yanhaijing.com/vertical-center/table.html)\n[css-table](http://yanhaijing.com/vertical-center/css-table.html)\n[flex](http://yanhaijing.com/vertical-center/flex.html)\n[grid](http://yanhaijing.com/vertical-center/grid.html)\n参考链接：\nhttps://www.w3cplus.com/css/understanding-css-layout-block-formatting-context.html\nhttps://segmentfault.com/a/1190000011211625\n\n","slug":"css","published":1,"updated":"2018-08-28T10:17:11.162Z","_id":"cjldh03qc0000uv6xx2orh2ky","comments":1,"layout":"post","link":"","content":"<p>在这个js当道的前端届里，号称要用js写操作系统，js真的牛逼啊，写得了前端，做得了后台，码得了客户端桌面应用，不管是小程序还是新出的快应用统统都离不开js,谁还记得曾经的那个页面仔。与一个像素去较真，写了不知道多少牛逼哄哄的hack，多少个日与夜在做IE兼容。如今你有多久没有关注过html、css的更新，你的css能力退化了吗？</p>\n<a id=\"more\"></a>\n<h3 id=\"源起\"><a href=\"#源起\" class=\"headerlink\" title=\"源起\"></a>源起</h3><p>span元素是否可以用padding撑开宽高，”不能啊”！真的吗，确定没有记错吗，来，实验是检验真理的唯一标准。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">\tbody&#123;margin: 0;padding: 0&#125;</span></span><br><span class=\"line\"><span class=\"undefined\">\tdiv&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">\t\tcolor: #000;</span></span><br><span class=\"line\"><span class=\"undefined\">\t\t/*margin-bottom: 30px;*/ /*取消注释第二步，运行看效果*/</span></span><br><span class=\"line\"><span class=\"undefined\">\t&#125;</span></span><br><span class=\"line\"><span class=\"undefined\">\tspan&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">\t\tpadding:20px;</span></span><br><span class=\"line\"><span class=\"undefined\">\t\tbackground-color: #000;</span></span><br><span class=\"line\"><span class=\"undefined\">\t\tcolor: #fff;</span></span><br><span class=\"line\"><span class=\"undefined\">\t\ttext-align: center;</span></span><br><span class=\"line\"><span class=\"undefined\">\t\tfont-size: 20px;</span></span><br><span class=\"line\"><span class=\"undefined\">\t\tmargin:20px;</span></span><br><span class=\"line\"><span class=\"undefined\">\t&#125;</span></span><br><span class=\"line\"><span class=\"undefined\">\t</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- &lt;div&gt;神奇啊&lt;/div&gt; --&gt;</span> <span class=\"comment\">&lt;!-- 取消注释第一步，运行看效果 --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>我是span<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span>\t</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>由此我们可以得出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">span设置内外边距问题</span><br><span class=\"line\">1、margin：</span><br><span class=\"line\">span标签设置margin-left/right均好使，margin-top/bottom不好使；</span><br><span class=\"line\">2、padding： </span><br><span class=\"line\">span标签设置padding好使，但span标签上面无元素时，padding-top 不好使；span标签上面有元素时，padding-top会把上面的元素盖住.</span><br></pre></td></tr></table></figure>\n<p>天啊，太神奇了！太神奇了！为什么，为什么啊？？？？<br>等等，我还有疑问，那span可以设置line-height撑开里面的高度吗？</p>\n<h3 id=\"html元素的标签分类\"><a href=\"#html元素的标签分类\" class=\"headerlink\" title=\"html元素的标签分类\"></a>html元素的标签分类</h3><p>曾经我的字典里只有行内元素和块级元素，inline &amp; block，事实上：<br><img src=\"https://shuangmuyingzi.github.io/img/cssTu.png\" alt=\"GitHub set up\"><br>HTML5中，元素主要分为7类：<br>Metadata<br>Flow<br>Sectioning<br>Heading<br>Phrasing<br>Embedded<br>Interactive<br>这些分类集合互相之间也存在一定的交集(一个元素可以同时属于多个分类)</p>\n<h4 id=\"Metadata（元数据元素）\"><a href=\"#Metadata（元数据元素）\" class=\"headerlink\" title=\"Metadata（元数据元素）\"></a>Metadata（元数据元素）</h4><p>顾名思义，Metadata元素意指那些定义文档元数据信息的元素 — 其作用包括：影响文档中其它节点的展现与行为、定义文档与其它外部资源之间的关系等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">base, link, meta, noscript, script, style, template, title</span><br></pre></td></tr></table></figure>\n<h4 id=\"Flow（流式元素）\"><a href=\"#Flow（流式元素）\" class=\"headerlink\" title=\"Flow（流式元素）\"></a>Flow（流式元素）</h4><p>所有可以放在body标签内，构成文档内容的元素均属于Flow元素。因此，除了base, link, meta, style, title等只能放在head标签内的元素外，剩下的所有元素均属于Flow元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">a， abbr， address， area（如果它是map元素的后裔）， article， aside， audio， b， bdi， bdo， blockquote， br， button， canvas， cite， code， command， datalist， del， details， dfn， div， dl，em， embed， fieldset， figure， footer， form， h1， h2， h3， h4， h5， h6， header， hgroup， hr， i， iframe， img， input， ins， kbd， keygen， label， map， mark， math， menu， meter，nav， noscript， object， ol， output， p， pre， progress， q， ruby， s， samp， script， section， select， small， span， strong， style（如果该元素设置了scoped属性）， sub， sup， svg， table，textarea， time， u， ul， var， video， wbr， text</span><br></pre></td></tr></table></figure>\n<h4 id=\"Sectioning（章节元素）\"><a href=\"#Sectioning（章节元素）\" class=\"headerlink\" title=\"Sectioning（章节元素）\"></a>Sectioning（章节元素）</h4><p>Sectioning意指定义页面结构的元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">article, aside, nav, section</span><br></pre></td></tr></table></figure>\n<h4 id=\"Heading（标题元素）\"><a href=\"#Heading（标题元素）\" class=\"headerlink\" title=\"Heading（标题元素）\"></a>Heading（标题元素）</h4><p>所有标题元素属于Heading</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">h1, h2, h3, h4, h5, h6</span><br></pre></td></tr></table></figure>\n<h4 id=\"Phrasing（段落元素）\"><a href=\"#Phrasing（段落元素）\" class=\"headerlink\" title=\"Phrasing（段落元素）\"></a>Phrasing（段落元素）</h4><p>所有可以放在p标签内，构成段落内容的元素均属于Phrasing元素。因此，所有Phrasing元素均属于Flow元素。在HTML5标准文档中，关于Phrasing元素的原始定义为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Phrasing content is the text of the document, as well as elements that mark up that text at the intra-paragraph level. Runs of phrasing content form paragraphs.</span><br></pre></td></tr></table></figure>\n<p>对于这一定义，个人认为不应当使用“text”这一容易引起误解的词，事实上，一个元素即使不是文本，只要能包含在p标签中成为段落内容的一部分，就可以称之为Phrasing元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">a（如果其只包含段落式元素）， abbr， area（如果它是map元素的后裔）， audio， b， bdi， bdo， br， button， canvas， cite， code， command， datalist， del（如果其只包含段落式元素）， dfn， em， embed， i，iframe， img， input， ins（如果其只包含段落式元素）， kbd， keygen， label， map（如果其只包含段落式元素）， mark， math， meter， noscript， object， output， progress， q， ruby， s， samp， script，select， small， span， strong， sub， sup， svg， textarea， time， u， var， video， wbr， text</span><br></pre></td></tr></table></figure>\n<h4 id=\"Embedded（嵌入元素）\"><a href=\"#Embedded（嵌入元素）\" class=\"headerlink\" title=\"Embedded（嵌入元素）\"></a>Embedded（嵌入元素）</h4><p>所有用于在网页中嵌入外部资源的元素均属于Embedded元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">audio, video, img, canvas, svg, iframe, embed, object, math</span><br></pre></td></tr></table></figure>\n<h4 id=\"Interactive（交互元素）\"><a href=\"#Interactive（交互元素）\" class=\"headerlink\" title=\"Interactive（交互元素）\"></a>Interactive（交互元素）</h4><p>所有与用户交互有关的元素均属于Interactive元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">a， audio（如果设置了controls属性）， button， details， embed， iframe， img（如果设置了usemap属性）， input（如果type属性不为hidden状态）， keygen， label， menu（如果type属性为toolbar状态），object（如果设置了usemap属性）， select， textarea， video（如果设置了controls属性）</span><br></pre></td></tr></table></figure>\n<h4 id=\"Palpable\"><a href=\"#Palpable\" class=\"headerlink\" title=\"Palpable\"></a>Palpable</h4><p>所有应当拥有子元素的元素称之为Palpable元素。比如，br元素因不需要子元素，因此也就不属于Palpable。</p>\n<p>Script-supporting<br>自身不做任何页面展现，但与页面脚本相关的元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">script, template</span><br></pre></td></tr></table></figure>\n<p>其实这是非规范的，所以不是强求的，新的分类定义了元素的内容模型(Content Model),关键还是要清楚这些元素的特性以及各大浏览器是如何渲染解析的，包括有哪些默认的样式,从而正确嵌套标签以及设置reset.css。<br><a href=\"https://html.spec.whatwg.org/multipage/indices.html#element-content-categories\" target=\"_blank\" rel=\"noopener\">https://html.spec.whatwg.org/multipage/indices.html#element-content-categories</a></p>\n<h3 id=\"W3C-标准盒模型-amp-IE-怪异盒模型\"><a href=\"#W3C-标准盒模型-amp-IE-怪异盒模型\" class=\"headerlink\" title=\"W3C 标准盒模型 &amp; IE 怪异盒模型\"></a>W3C 标准盒模型 &amp; IE 怪异盒模型</h3><p>页面上显示的每个元素（包括内联元素）都可以看作一个盒子，即盒模型(box model) 盒模型由 4 部分组成，从内到外分别是：<code>content</code> <code>padding</code> <code>border</code> <code>margin</code></p>\n<p><img src=\"https://shuangmuyingzi.github.io/img/box-sizing.png\" alt=\"GitHub set up\"><br><code>W3C标准盒模型</code>一个元素的宽度（高度以此类推）应该这样计算：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">一个元素的宽度 =  content</span><br><span class=\"line\">盒子总宽度 = margin-left + border-left + padding-left + width + padding-right + border-right + margin-right</span><br></pre></td></tr></table></figure>\n<p><code>而IE 怪异盒模型</code>一个元素的宽度（高度以此类推）却是这样计算的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">一个元素的宽度 =  content + padding + border</span><br><span class=\"line\">盒子总宽度 = margin-left + width + margin-right</span><br></pre></td></tr></table></figure>\n<h4 id=\"解决方案-box-sizing\"><a href=\"#解决方案-box-sizing\" class=\"headerlink\" title=\"解决方案 box-sizing\"></a>解决方案 box-sizing</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// W3C 标准盒模型（浏览器默认）</span><br><span class=\"line\">box-sizing: content-box;</span><br><span class=\"line\">// IE 怪异盒模型</span><br><span class=\"line\">box-sizing: border-box;</span><br></pre></td></tr></table></figure>\n<p>当我们设置 box-sizing: border-box; 时，border 和 padding 就被包含在了宽高之内,和IE在非标准的模式下是一致的。<br>然而好像看到很多网站为了避免同一份 css 在不同浏览器下表现不同，基本会加上：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">*, *:before, *:after &#123;</span><br><span class=\"line\">  -moz-box-sizing: border-box;</span><br><span class=\"line\">  -webkit-box-sizing: border-box;</span><br><span class=\"line\">  box-sizing: border-box;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"文档类型（Doctype）\"><a href=\"#文档类型（Doctype）\" class=\"headerlink\" title=\"文档类型（Doctype）\"></a>文档类型（Doctype）</h4><p>亲测了下，发现其实当头部设置了html5的头部声明&lt;!DOCTYPE html&gt;，在IE下也全是标准的盒模型了，估计除了历史遗留下的网站，新的全是html5的声明，HTML5 不基于 SGML，所以不需要引用 DTD。可能也就只有一些老家伙才经历过图下的历史：<br><img src=\"https://shuangmuyingzi.github.io/img/doctype.png\" alt=\"GitHub set up\"><br>如果有兴趣推荐看这篇关于声明的具体元素意思，毕竟其实很多医院系统，学校系统，政府系统之类可能还是会有旧的，了解下也好。<br><a href=\"https://www.jianshu.com/p/c3dcdad42e6d\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/c3dcdad42e6d</a></p>\n<h4 id=\"理解CSS布局和BFC\"><a href=\"#理解CSS布局和BFC\" class=\"headerlink\" title=\"理解CSS布局和BFC\"></a>理解CSS布局和BFC</h4><p>CSS布局中有一些概念，一旦理解了这些概念，就能真正的提高你的CSS能力。这篇文章主要介绍的是关于块格式化上下文（Block Formatting Context），也就是大家俗称的BFC。</p>\n<p>它是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。也就是说我们平时在布局的时候，它默默地提供了一个环境，使得HTML元素在这个环境中按照一定规则进行布局。</p>\n<p>最常见的formatting context有Block Formatting Context(BFC)和Inline Formatting Context(IFC)，CSS3中还增加了GridLayout Formatting Context(GFC)和Flex Formatting Context(FFC)。</p>\n<p>BFC的布局规则与触发规则<br>刚才我们说到BFC中的元素有一套规定的布局规则：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">内部的元素会在垂直方向一个接一个地放置</span><br><span class=\"line\">元素垂直方向的距离由margin决定，属于同一个BFC的两个相邻元素的margin会发生重叠</span><br><span class=\"line\">每个元素的左外边距与包含块的左边界相接触(对于从左往右，否则相反)，即使存在浮动也是如此</span><br><span class=\"line\">BFC的区域不会与float元素重叠</span><br><span class=\"line\">计算BFC的高度时，浮动元素也参与计算</span><br><span class=\"line\">BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此</span><br></pre></td></tr></table></figure>\n<p>刚才我们又提到BFC是一块渲染区域，那这块渲染区域到底在哪，它又是有多大，这些由生成BFC的元素来决定，CSS2.1中规定满足下列CSS声明的元素便会生成BFC（触发规则）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">根元素</span><br><span class=\"line\">float的值不为none</span><br><span class=\"line\">overflow的值不为visible</span><br><span class=\"line\">position的值为absolute或fixed</span><br><span class=\"line\">display的值为inline-block, table-cell, table-caption, flex, inline-flex, grid</span><br><span class=\"line\">注：display: table也认为可以生成BFC，主要原因是table会默认生成一个匿名的table-cell，正是这个匿名的table-cell生成了BFC</span><br></pre></td></tr></table></figure>\n<p>上面这些CSS声明的元素生成了BFC，而它们本身并不是BFC，这一点需要区分。</p>\n<h4 id=\"防止垂直margin重叠\"><a href=\"#防止垂直margin重叠\" class=\"headerlink\" title=\"防止垂直margin重叠\"></a>防止垂直margin重叠</h4><p>有点布局经验的朋友都知道margin collapse，也就是相邻的垂直元素同时设置了margin后，实际margin值会塌陷到其中较大的那个值。其根本原理就是它们处于同一个BFC，符合“属于同一个BFC的两个相邻元素的margin会发生重叠”的规则。</p>\n<p>我们可以在其中一个元素外面包裹一层容器，并触发该容器生成一个BFC。那么两个元素便属于不同的BFC，就不会发生margin重叠了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">\t&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">\t&lt;title&gt;防止垂直margin重叠&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">    /*.wrap&#123;</span><br><span class=\"line\">        overflow: hidden;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    p&#123;</span><br><span class=\"line\">        width: 200px;</span><br><span class=\"line\">        line-height: 100px;</span><br><span class=\"line\">        margin: 100px;</span><br><span class=\"line\">        background: #000;</span><br><span class=\"line\">        color: #fff;</span><br><span class=\"line\">        text-align: center;</span><br><span class=\"line\">    &#125;*/</span><br><span class=\"line\">    .outer &#123; background-color: #ccc; margin: 0 0 40px 0; /*overflow: auto;*/&#125; </span><br><span class=\"line\">    p &#123; padding: 0; margin: 20px 0 20px 0; background-color: rgb(233,78,119); color: #fff; &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;!-- &lt;p&gt;我属于一个BFC&lt;/p&gt;</span><br><span class=\"line\">    &lt;div class=&quot;wrap&quot;&gt;</span><br><span class=\"line\">        &lt;p&gt;我属于另一个BFC&lt;/p&gt;</span><br><span class=\"line\">    &lt;/div&gt; --&gt;</span><br><span class=\"line\">    &lt;div class=&quot;outer&quot;&gt;</span><br><span class=\"line\">        &lt;p&gt;我是P&lt;/p&gt;</span><br><span class=\"line\">        &lt;p&gt;我是另一个P&lt;/p&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>防止浮动子元素高度塌陷</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>防止浮动子元素高度塌陷<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">    .outer &#123; border: 5px dotted rgb(214,129,137); border-radius: 5px; width: 450px; padding: 10px; margin-bottom: 40px;/*overflow: hidden;*/ &#125; </span></span><br><span class=\"line\"><span class=\"undefined\">    .float &#123; padding: 10px; border: 5px solid rgba(214,129,137,.4); border-radius: 5px; background-color: rgba(233,78,119,.4); color: #fff; float: left; width: 200px; margin: 0 20px 0 0; &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"outer\"</span>&gt;</span> </span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"float\"</span>&gt;</span>我是浮动<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    \t我会包裹着浮动</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>如果我们将.outer元素的overflow: hidden去掉，那么.outer元素就获取不到浮动元素的高度了。但是加上overflow属性后触发了BFC，计算BFC的高度时，浮动元素也参与了计算。</p>\n<p>防止文字（或其他元素）环绕</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">\t&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">\t&lt;title&gt;防止文字（或其他元素）环绕&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">    .parent&#123;</span><br><span class=\"line\">        width: 300px;</span><br><span class=\"line\">        border: 3px solid #000;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .child&#123;</span><br><span class=\"line\">        float: left;</span><br><span class=\"line\">        width: 100px;</span><br><span class=\"line\">        height: 100px;</span><br><span class=\"line\">        border: 3px solid #f00;</span><br><span class=\"line\">        color: #f00;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .text&#123;</span><br><span class=\"line\">        /*overflow: hidden;*/</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div class=&quot;parent&quot;&gt;</span><br><span class=\"line\">        &lt;div class=&quot;child&quot;&gt;float: left&lt;/div&gt;</span><br><span class=\"line\">        &lt;div class=&quot;text&quot;&gt;我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕&lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>正常情况下，如果一个块级元素设置成了float，那么他的兄弟元素会环绕其布局。这里我们给.text加上overflow，文字所在的区域就产生了BFC，元素的左边总是触碰到容器的左边，即使存在浮动也是如此。</p>\n<p>以上的都是BFC常见的应用场景以及它的触发规则，<br>接下来我们来看看BFC新的触发条件。</p>\n<h4 id=\"创建BFC的新方式\"><a href=\"#创建BFC的新方式\" class=\"headerlink\" title=\"创建BFC的新方式\"></a>创建BFC的新方式</h4><p>使用overflow或其他的方法创建BFC时会有两个问题。首先，这些方法本身是有自身的设计目的，所以在使用它们创建BFC时可能会产生副作用。例如，使用overflow创建BFC后在某些情况下可能会看到出现一个滚动条或者元素内容被裁切。这是由于overflow属性的设计是用来让你告诉浏览器如何定义元素的溢出状态的。</p>\n<p>最安全的做法应该是创建一个BFC时并不会带来任何副作用，它内部的元素都安全的呆在这个迷你布局中，这种方法不会引起任何意想不到的问题，也可以理解开发者的意图。CSS工作组也十分认同这种想法，所以他们定制了一个新的属性值：display:flow-root。</p>\n<p><img src=\"https://shuangmuyingzi.github.io/img/flow-root.png\" alt=\"GitHub set up\"></p>\n<p>Caniuse上display:flow-root各浏览器兼容情况。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">\t&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">\t&lt;title&gt;flow-root&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">    .parent&#123;</span><br><span class=\"line\">        width: 300px;</span><br><span class=\"line\">        border: 3px solid #000;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .child&#123;</span><br><span class=\"line\">        float: left;</span><br><span class=\"line\">        width: 100px;</span><br><span class=\"line\">        height: 100px;</span><br><span class=\"line\">        border: 3px solid #f00;</span><br><span class=\"line\">        color: #f00;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .text&#123;</span><br><span class=\"line\">        display: flow-root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div class=&quot;parent&quot;&gt;</span><br><span class=\"line\">        &lt;div class=&quot;child&quot;&gt;float: left&lt;/div&gt;</span><br><span class=\"line\">        &lt;div class=&quot;text&quot;&gt;我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕&lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>vertical-center(水平垂直居中)<br>仅居中元素定宽高适用：</p>\n<p><a href=\"http://yanhaijing.com/vertical-center/absolute1.html\" target=\"_blank\" rel=\"noopener\">absolute + 负margin</a><br><a href=\"http://yanhaijing.com/vertical-center/absolute2.html\" target=\"_blank\" rel=\"noopener\">absolute + margin auto</a><br><a href=\"http://yanhaijing.com/vertical-center/absolute3.html\" target=\"_blank\" rel=\"noopener\">absolute + calc</a><br>居中元素不定宽高适用：</p>\n<p><a href=\"http://yanhaijing.com/vertical-center/absolute4.html\" target=\"_blank\" rel=\"noopener\">absolute + transform</a><br><a href=\"http://yanhaijing.com/vertical-center/writing-mode.html\" target=\"_blank\" rel=\"noopener\">writing-mode</a><br><a href=\"http://yanhaijing.com/vertical-center/lineheight.html\" target=\"_blank\" rel=\"noopener\">lineheight</a><br><a href=\"http://yanhaijing.com/vertical-center/table.html\" target=\"_blank\" rel=\"noopener\">table</a><br><a href=\"http://yanhaijing.com/vertical-center/css-table.html\" target=\"_blank\" rel=\"noopener\">css-table</a><br><a href=\"http://yanhaijing.com/vertical-center/flex.html\" target=\"_blank\" rel=\"noopener\">flex</a><br><a href=\"http://yanhaijing.com/vertical-center/grid.html\" target=\"_blank\" rel=\"noopener\">grid</a><br>参考链接：<br><a href=\"https://www.w3cplus.com/css/understanding-css-layout-block-formatting-context.html\" target=\"_blank\" rel=\"noopener\">https://www.w3cplus.com/css/understanding-css-layout-block-formatting-context.html</a><br><a href=\"https://segmentfault.com/a/1190000011211625\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000011211625</a></p>\n","site":{"data":{}},"excerpt":"<p>在这个js当道的前端届里，号称要用js写操作系统，js真的牛逼啊，写得了前端，做得了后台，码得了客户端桌面应用，不管是小程序还是新出的快应用统统都离不开js,谁还记得曾经的那个页面仔。与一个像素去较真，写了不知道多少牛逼哄哄的hack，多少个日与夜在做IE兼容。如今你有多久没有关注过html、css的更新，你的css能力退化了吗？</p>","more":"<h3 id=\"源起\"><a href=\"#源起\" class=\"headerlink\" title=\"源起\"></a>源起</h3><p>span元素是否可以用padding撑开宽高，”不能啊”！真的吗，确定没有记错吗，来，实验是检验真理的唯一标准。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">\tbody&#123;margin: 0;padding: 0&#125;</span></span><br><span class=\"line\"><span class=\"undefined\">\tdiv&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">\t\tcolor: #000;</span></span><br><span class=\"line\"><span class=\"undefined\">\t\t/*margin-bottom: 30px;*/ /*取消注释第二步，运行看效果*/</span></span><br><span class=\"line\"><span class=\"undefined\">\t&#125;</span></span><br><span class=\"line\"><span class=\"undefined\">\tspan&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">\t\tpadding:20px;</span></span><br><span class=\"line\"><span class=\"undefined\">\t\tbackground-color: #000;</span></span><br><span class=\"line\"><span class=\"undefined\">\t\tcolor: #fff;</span></span><br><span class=\"line\"><span class=\"undefined\">\t\ttext-align: center;</span></span><br><span class=\"line\"><span class=\"undefined\">\t\tfont-size: 20px;</span></span><br><span class=\"line\"><span class=\"undefined\">\t\tmargin:20px;</span></span><br><span class=\"line\"><span class=\"undefined\">\t&#125;</span></span><br><span class=\"line\"><span class=\"undefined\">\t</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"comment\">&lt;!-- &lt;div&gt;神奇啊&lt;/div&gt; --&gt;</span> <span class=\"comment\">&lt;!-- 取消注释第一步，运行看效果 --&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>我是span<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span>\t</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>由此我们可以得出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">span设置内外边距问题</span><br><span class=\"line\">1、margin：</span><br><span class=\"line\">span标签设置margin-left/right均好使，margin-top/bottom不好使；</span><br><span class=\"line\">2、padding： </span><br><span class=\"line\">span标签设置padding好使，但span标签上面无元素时，padding-top 不好使；span标签上面有元素时，padding-top会把上面的元素盖住.</span><br></pre></td></tr></table></figure>\n<p>天啊，太神奇了！太神奇了！为什么，为什么啊？？？？<br>等等，我还有疑问，那span可以设置line-height撑开里面的高度吗？</p>\n<h3 id=\"html元素的标签分类\"><a href=\"#html元素的标签分类\" class=\"headerlink\" title=\"html元素的标签分类\"></a>html元素的标签分类</h3><p>曾经我的字典里只有行内元素和块级元素，inline &amp; block，事实上：<br><img src=\"https://shuangmuyingzi.github.io/img/cssTu.png\" alt=\"GitHub set up\"><br>HTML5中，元素主要分为7类：<br>Metadata<br>Flow<br>Sectioning<br>Heading<br>Phrasing<br>Embedded<br>Interactive<br>这些分类集合互相之间也存在一定的交集(一个元素可以同时属于多个分类)</p>\n<h4 id=\"Metadata（元数据元素）\"><a href=\"#Metadata（元数据元素）\" class=\"headerlink\" title=\"Metadata（元数据元素）\"></a>Metadata（元数据元素）</h4><p>顾名思义，Metadata元素意指那些定义文档元数据信息的元素 — 其作用包括：影响文档中其它节点的展现与行为、定义文档与其它外部资源之间的关系等。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">base, link, meta, noscript, script, style, template, title</span><br></pre></td></tr></table></figure>\n<h4 id=\"Flow（流式元素）\"><a href=\"#Flow（流式元素）\" class=\"headerlink\" title=\"Flow（流式元素）\"></a>Flow（流式元素）</h4><p>所有可以放在body标签内，构成文档内容的元素均属于Flow元素。因此，除了base, link, meta, style, title等只能放在head标签内的元素外，剩下的所有元素均属于Flow元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">a， abbr， address， area（如果它是map元素的后裔）， article， aside， audio， b， bdi， bdo， blockquote， br， button， canvas， cite， code， command， datalist， del， details， dfn， div， dl，em， embed， fieldset， figure， footer， form， h1， h2， h3， h4， h5， h6， header， hgroup， hr， i， iframe， img， input， ins， kbd， keygen， label， map， mark， math， menu， meter，nav， noscript， object， ol， output， p， pre， progress， q， ruby， s， samp， script， section， select， small， span， strong， style（如果该元素设置了scoped属性）， sub， sup， svg， table，textarea， time， u， ul， var， video， wbr， text</span><br></pre></td></tr></table></figure>\n<h4 id=\"Sectioning（章节元素）\"><a href=\"#Sectioning（章节元素）\" class=\"headerlink\" title=\"Sectioning（章节元素）\"></a>Sectioning（章节元素）</h4><p>Sectioning意指定义页面结构的元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">article, aside, nav, section</span><br></pre></td></tr></table></figure>\n<h4 id=\"Heading（标题元素）\"><a href=\"#Heading（标题元素）\" class=\"headerlink\" title=\"Heading（标题元素）\"></a>Heading（标题元素）</h4><p>所有标题元素属于Heading</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">h1, h2, h3, h4, h5, h6</span><br></pre></td></tr></table></figure>\n<h4 id=\"Phrasing（段落元素）\"><a href=\"#Phrasing（段落元素）\" class=\"headerlink\" title=\"Phrasing（段落元素）\"></a>Phrasing（段落元素）</h4><p>所有可以放在p标签内，构成段落内容的元素均属于Phrasing元素。因此，所有Phrasing元素均属于Flow元素。在HTML5标准文档中，关于Phrasing元素的原始定义为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Phrasing content is the text of the document, as well as elements that mark up that text at the intra-paragraph level. Runs of phrasing content form paragraphs.</span><br></pre></td></tr></table></figure>\n<p>对于这一定义，个人认为不应当使用“text”这一容易引起误解的词，事实上，一个元素即使不是文本，只要能包含在p标签中成为段落内容的一部分，就可以称之为Phrasing元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">a（如果其只包含段落式元素）， abbr， area（如果它是map元素的后裔）， audio， b， bdi， bdo， br， button， canvas， cite， code， command， datalist， del（如果其只包含段落式元素）， dfn， em， embed， i，iframe， img， input， ins（如果其只包含段落式元素）， kbd， keygen， label， map（如果其只包含段落式元素）， mark， math， meter， noscript， object， output， progress， q， ruby， s， samp， script，select， small， span， strong， sub， sup， svg， textarea， time， u， var， video， wbr， text</span><br></pre></td></tr></table></figure>\n<h4 id=\"Embedded（嵌入元素）\"><a href=\"#Embedded（嵌入元素）\" class=\"headerlink\" title=\"Embedded（嵌入元素）\"></a>Embedded（嵌入元素）</h4><p>所有用于在网页中嵌入外部资源的元素均属于Embedded元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">audio, video, img, canvas, svg, iframe, embed, object, math</span><br></pre></td></tr></table></figure>\n<h4 id=\"Interactive（交互元素）\"><a href=\"#Interactive（交互元素）\" class=\"headerlink\" title=\"Interactive（交互元素）\"></a>Interactive（交互元素）</h4><p>所有与用户交互有关的元素均属于Interactive元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">a， audio（如果设置了controls属性）， button， details， embed， iframe， img（如果设置了usemap属性）， input（如果type属性不为hidden状态）， keygen， label， menu（如果type属性为toolbar状态），object（如果设置了usemap属性）， select， textarea， video（如果设置了controls属性）</span><br></pre></td></tr></table></figure>\n<h4 id=\"Palpable\"><a href=\"#Palpable\" class=\"headerlink\" title=\"Palpable\"></a>Palpable</h4><p>所有应当拥有子元素的元素称之为Palpable元素。比如，br元素因不需要子元素，因此也就不属于Palpable。</p>\n<p>Script-supporting<br>自身不做任何页面展现，但与页面脚本相关的元素</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">script, template</span><br></pre></td></tr></table></figure>\n<p>其实这是非规范的，所以不是强求的，新的分类定义了元素的内容模型(Content Model),关键还是要清楚这些元素的特性以及各大浏览器是如何渲染解析的，包括有哪些默认的样式,从而正确嵌套标签以及设置reset.css。<br><a href=\"https://html.spec.whatwg.org/multipage/indices.html#element-content-categories\" target=\"_blank\" rel=\"noopener\">https://html.spec.whatwg.org/multipage/indices.html#element-content-categories</a></p>\n<h3 id=\"W3C-标准盒模型-amp-IE-怪异盒模型\"><a href=\"#W3C-标准盒模型-amp-IE-怪异盒模型\" class=\"headerlink\" title=\"W3C 标准盒模型 &amp; IE 怪异盒模型\"></a>W3C 标准盒模型 &amp; IE 怪异盒模型</h3><p>页面上显示的每个元素（包括内联元素）都可以看作一个盒子，即盒模型(box model) 盒模型由 4 部分组成，从内到外分别是：<code>content</code> <code>padding</code> <code>border</code> <code>margin</code></p>\n<p><img src=\"https://shuangmuyingzi.github.io/img/box-sizing.png\" alt=\"GitHub set up\"><br><code>W3C标准盒模型</code>一个元素的宽度（高度以此类推）应该这样计算：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">一个元素的宽度 =  content</span><br><span class=\"line\">盒子总宽度 = margin-left + border-left + padding-left + width + padding-right + border-right + margin-right</span><br></pre></td></tr></table></figure>\n<p><code>而IE 怪异盒模型</code>一个元素的宽度（高度以此类推）却是这样计算的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">一个元素的宽度 =  content + padding + border</span><br><span class=\"line\">盒子总宽度 = margin-left + width + margin-right</span><br></pre></td></tr></table></figure>\n<h4 id=\"解决方案-box-sizing\"><a href=\"#解决方案-box-sizing\" class=\"headerlink\" title=\"解决方案 box-sizing\"></a>解决方案 box-sizing</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// W3C 标准盒模型（浏览器默认）</span><br><span class=\"line\">box-sizing: content-box;</span><br><span class=\"line\">// IE 怪异盒模型</span><br><span class=\"line\">box-sizing: border-box;</span><br></pre></td></tr></table></figure>\n<p>当我们设置 box-sizing: border-box; 时，border 和 padding 就被包含在了宽高之内,和IE在非标准的模式下是一致的。<br>然而好像看到很多网站为了避免同一份 css 在不同浏览器下表现不同，基本会加上：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">*, *:before, *:after &#123;</span><br><span class=\"line\">  -moz-box-sizing: border-box;</span><br><span class=\"line\">  -webkit-box-sizing: border-box;</span><br><span class=\"line\">  box-sizing: border-box;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"文档类型（Doctype）\"><a href=\"#文档类型（Doctype）\" class=\"headerlink\" title=\"文档类型（Doctype）\"></a>文档类型（Doctype）</h4><p>亲测了下，发现其实当头部设置了html5的头部声明&lt;!DOCTYPE html&gt;，在IE下也全是标准的盒模型了，估计除了历史遗留下的网站，新的全是html5的声明，HTML5 不基于 SGML，所以不需要引用 DTD。可能也就只有一些老家伙才经历过图下的历史：<br><img src=\"https://shuangmuyingzi.github.io/img/doctype.png\" alt=\"GitHub set up\"><br>如果有兴趣推荐看这篇关于声明的具体元素意思，毕竟其实很多医院系统，学校系统，政府系统之类可能还是会有旧的，了解下也好。<br><a href=\"https://www.jianshu.com/p/c3dcdad42e6d\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/c3dcdad42e6d</a></p>\n<h4 id=\"理解CSS布局和BFC\"><a href=\"#理解CSS布局和BFC\" class=\"headerlink\" title=\"理解CSS布局和BFC\"></a>理解CSS布局和BFC</h4><p>CSS布局中有一些概念，一旦理解了这些概念，就能真正的提高你的CSS能力。这篇文章主要介绍的是关于块格式化上下文（Block Formatting Context），也就是大家俗称的BFC。</p>\n<p>它是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。也就是说我们平时在布局的时候，它默默地提供了一个环境，使得HTML元素在这个环境中按照一定规则进行布局。</p>\n<p>最常见的formatting context有Block Formatting Context(BFC)和Inline Formatting Context(IFC)，CSS3中还增加了GridLayout Formatting Context(GFC)和Flex Formatting Context(FFC)。</p>\n<p>BFC的布局规则与触发规则<br>刚才我们说到BFC中的元素有一套规定的布局规则：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">内部的元素会在垂直方向一个接一个地放置</span><br><span class=\"line\">元素垂直方向的距离由margin决定，属于同一个BFC的两个相邻元素的margin会发生重叠</span><br><span class=\"line\">每个元素的左外边距与包含块的左边界相接触(对于从左往右，否则相反)，即使存在浮动也是如此</span><br><span class=\"line\">BFC的区域不会与float元素重叠</span><br><span class=\"line\">计算BFC的高度时，浮动元素也参与计算</span><br><span class=\"line\">BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之也如此</span><br></pre></td></tr></table></figure>\n<p>刚才我们又提到BFC是一块渲染区域，那这块渲染区域到底在哪，它又是有多大，这些由生成BFC的元素来决定，CSS2.1中规定满足下列CSS声明的元素便会生成BFC（触发规则）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">根元素</span><br><span class=\"line\">float的值不为none</span><br><span class=\"line\">overflow的值不为visible</span><br><span class=\"line\">position的值为absolute或fixed</span><br><span class=\"line\">display的值为inline-block, table-cell, table-caption, flex, inline-flex, grid</span><br><span class=\"line\">注：display: table也认为可以生成BFC，主要原因是table会默认生成一个匿名的table-cell，正是这个匿名的table-cell生成了BFC</span><br></pre></td></tr></table></figure>\n<p>上面这些CSS声明的元素生成了BFC，而它们本身并不是BFC，这一点需要区分。</p>\n<h4 id=\"防止垂直margin重叠\"><a href=\"#防止垂直margin重叠\" class=\"headerlink\" title=\"防止垂直margin重叠\"></a>防止垂直margin重叠</h4><p>有点布局经验的朋友都知道margin collapse，也就是相邻的垂直元素同时设置了margin后，实际margin值会塌陷到其中较大的那个值。其根本原理就是它们处于同一个BFC，符合“属于同一个BFC的两个相邻元素的margin会发生重叠”的规则。</p>\n<p>我们可以在其中一个元素外面包裹一层容器，并触发该容器生成一个BFC。那么两个元素便属于不同的BFC，就不会发生margin重叠了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">\t&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">\t&lt;title&gt;防止垂直margin重叠&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">    /*.wrap&#123;</span><br><span class=\"line\">        overflow: hidden;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    p&#123;</span><br><span class=\"line\">        width: 200px;</span><br><span class=\"line\">        line-height: 100px;</span><br><span class=\"line\">        margin: 100px;</span><br><span class=\"line\">        background: #000;</span><br><span class=\"line\">        color: #fff;</span><br><span class=\"line\">        text-align: center;</span><br><span class=\"line\">    &#125;*/</span><br><span class=\"line\">    .outer &#123; background-color: #ccc; margin: 0 0 40px 0; /*overflow: auto;*/&#125; </span><br><span class=\"line\">    p &#123; padding: 0; margin: 20px 0 20px 0; background-color: rgb(233,78,119); color: #fff; &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;!-- &lt;p&gt;我属于一个BFC&lt;/p&gt;</span><br><span class=\"line\">    &lt;div class=&quot;wrap&quot;&gt;</span><br><span class=\"line\">        &lt;p&gt;我属于另一个BFC&lt;/p&gt;</span><br><span class=\"line\">    &lt;/div&gt; --&gt;</span><br><span class=\"line\">    &lt;div class=&quot;outer&quot;&gt;</span><br><span class=\"line\">        &lt;p&gt;我是P&lt;/p&gt;</span><br><span class=\"line\">        &lt;p&gt;我是另一个P&lt;/p&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>防止浮动子元素高度塌陷</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">\"en\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">\"UTF-8\"</span>&gt;</span></span><br><span class=\"line\">\t<span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>防止浮动子元素高度塌陷<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">    .outer &#123; border: 5px dotted rgb(214,129,137); border-radius: 5px; width: 450px; padding: 10px; margin-bottom: 40px;/*overflow: hidden;*/ &#125; </span></span><br><span class=\"line\"><span class=\"undefined\">    .float &#123; padding: 10px; border: 5px solid rgba(214,129,137,.4); border-radius: 5px; background-color: rgba(233,78,119,.4); color: #fff; float: left; width: 200px; margin: 0 20px 0 0; &#125;</span></span><br><span class=\"line\"><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"outer\"</span>&gt;</span> </span><br><span class=\"line\">    \t<span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">\"float\"</span>&gt;</span>我是浮动<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span> </span><br><span class=\"line\">    \t我会包裹着浮动</span><br><span class=\"line\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p>如果我们将.outer元素的overflow: hidden去掉，那么.outer元素就获取不到浮动元素的高度了。但是加上overflow属性后触发了BFC，计算BFC的高度时，浮动元素也参与了计算。</p>\n<p>防止文字（或其他元素）环绕</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">\t&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">\t&lt;title&gt;防止文字（或其他元素）环绕&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">    .parent&#123;</span><br><span class=\"line\">        width: 300px;</span><br><span class=\"line\">        border: 3px solid #000;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .child&#123;</span><br><span class=\"line\">        float: left;</span><br><span class=\"line\">        width: 100px;</span><br><span class=\"line\">        height: 100px;</span><br><span class=\"line\">        border: 3px solid #f00;</span><br><span class=\"line\">        color: #f00;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .text&#123;</span><br><span class=\"line\">        /*overflow: hidden;*/</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div class=&quot;parent&quot;&gt;</span><br><span class=\"line\">        &lt;div class=&quot;child&quot;&gt;float: left&lt;/div&gt;</span><br><span class=\"line\">        &lt;div class=&quot;text&quot;&gt;我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕&lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>正常情况下，如果一个块级元素设置成了float，那么他的兄弟元素会环绕其布局。这里我们给.text加上overflow，文字所在的区域就产生了BFC，元素的左边总是触碰到容器的左边，即使存在浮动也是如此。</p>\n<p>以上的都是BFC常见的应用场景以及它的触发规则，<br>接下来我们来看看BFC新的触发条件。</p>\n<h4 id=\"创建BFC的新方式\"><a href=\"#创建BFC的新方式\" class=\"headerlink\" title=\"创建BFC的新方式\"></a>创建BFC的新方式</h4><p>使用overflow或其他的方法创建BFC时会有两个问题。首先，这些方法本身是有自身的设计目的，所以在使用它们创建BFC时可能会产生副作用。例如，使用overflow创建BFC后在某些情况下可能会看到出现一个滚动条或者元素内容被裁切。这是由于overflow属性的设计是用来让你告诉浏览器如何定义元素的溢出状态的。</p>\n<p>最安全的做法应该是创建一个BFC时并不会带来任何副作用，它内部的元素都安全的呆在这个迷你布局中，这种方法不会引起任何意想不到的问题，也可以理解开发者的意图。CSS工作组也十分认同这种想法，所以他们定制了一个新的属性值：display:flow-root。</p>\n<p><img src=\"https://shuangmuyingzi.github.io/img/flow-root.png\" alt=\"GitHub set up\"></p>\n<p>Caniuse上display:flow-root各浏览器兼容情况。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;!DOCTYPE html&gt;</span><br><span class=\"line\">&lt;html lang=&quot;en&quot;&gt;</span><br><span class=\"line\">&lt;head&gt;</span><br><span class=\"line\">\t&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class=\"line\">\t&lt;title&gt;flow-root&lt;/title&gt;</span><br><span class=\"line\">&lt;/head&gt;</span><br><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">    .parent&#123;</span><br><span class=\"line\">        width: 300px;</span><br><span class=\"line\">        border: 3px solid #000;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .child&#123;</span><br><span class=\"line\">        float: left;</span><br><span class=\"line\">        width: 100px;</span><br><span class=\"line\">        height: 100px;</span><br><span class=\"line\">        border: 3px solid #f00;</span><br><span class=\"line\">        color: #f00;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .text&#123;</span><br><span class=\"line\">        display: flow-root;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">    &lt;div class=&quot;parent&quot;&gt;</span><br><span class=\"line\">        &lt;div class=&quot;child&quot;&gt;float: left&lt;/div&gt;</span><br><span class=\"line\">        &lt;div class=&quot;text&quot;&gt;我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕我只是文字但我不会环绕&lt;/div&gt;</span><br><span class=\"line\">    &lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure>\n<p>vertical-center(水平垂直居中)<br>仅居中元素定宽高适用：</p>\n<p><a href=\"http://yanhaijing.com/vertical-center/absolute1.html\" target=\"_blank\" rel=\"noopener\">absolute + 负margin</a><br><a href=\"http://yanhaijing.com/vertical-center/absolute2.html\" target=\"_blank\" rel=\"noopener\">absolute + margin auto</a><br><a href=\"http://yanhaijing.com/vertical-center/absolute3.html\" target=\"_blank\" rel=\"noopener\">absolute + calc</a><br>居中元素不定宽高适用：</p>\n<p><a href=\"http://yanhaijing.com/vertical-center/absolute4.html\" target=\"_blank\" rel=\"noopener\">absolute + transform</a><br><a href=\"http://yanhaijing.com/vertical-center/writing-mode.html\" target=\"_blank\" rel=\"noopener\">writing-mode</a><br><a href=\"http://yanhaijing.com/vertical-center/lineheight.html\" target=\"_blank\" rel=\"noopener\">lineheight</a><br><a href=\"http://yanhaijing.com/vertical-center/table.html\" target=\"_blank\" rel=\"noopener\">table</a><br><a href=\"http://yanhaijing.com/vertical-center/css-table.html\" target=\"_blank\" rel=\"noopener\">css-table</a><br><a href=\"http://yanhaijing.com/vertical-center/flex.html\" target=\"_blank\" rel=\"noopener\">flex</a><br><a href=\"http://yanhaijing.com/vertical-center/grid.html\" target=\"_blank\" rel=\"noopener\">grid</a><br>参考链接：<br><a href=\"https://www.w3cplus.com/css/understanding-css-layout-block-formatting-context.html\" target=\"_blank\" rel=\"noopener\">https://www.w3cplus.com/css/understanding-css-layout-block-formatting-context.html</a><br><a href=\"https://segmentfault.com/a/1190000011211625\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000011211625</a></p>"},{"title":"总有后悔药吃的git","date":"2018-04-27T16:00:00.000Z","photos":["/img/2017/5.jpg"],"_content":"\n记录一些常用的git操作，以便回顾和查询。理解这些指令，觉得最重要的是理解Git的内部原理，比如Git的分布式版本控制，分清楚工作区、暂存区、版本库，还有就是理解Git跟踪并管理的是修改，而非文件。\n\n<!--more-->\n\n### 我的骚操作\n重说三：mac系统“最近使用”里面的文件不能删，不能删，千万不要随便删。那天我以为这里(最近使用)的文件是对别的地方的拷贝，我一向都有洁癖，经常会删除电脑那些基本不用的东西或者是重复的东西，结果一删造成千古恨，至今为止我都还没处理完造成的影响，只能发现再处理，好在有git仓库的文件可以有后悔药吃，其他的也就只能哭了。\n\n### 几个重要的名词\n![GitHub set up](https://shuangmuyingzi.github.io/img/git.jpeg)\n\n* Workspace：工作区\n* Index / Stage：暂存区\n* Repository：仓库区（或本地仓库）\n* Remote：远程仓库\n\n#### 设置\n\n```\n$ git config --global user.name \"Your Name\"\n$ git config --global user.email \"email@example.com\"\n```\n#### 提交\ngit 跟踪的是修改，而不是文件\n![GitHub set up](https://shuangmuyingzi.github.io/img/git2.png)\n\n```\n#将“当前修改”移动到暂存区(stage)\n git add a.txt\n#将暂存区修改提交\n git commit -m \"Add a.txt.\"\n```\n#### 查看状态\n\n```\n git status\n //显示暂存区和工作区的差异\n git diff\n```\n#### 回退\n\n```\n# 放弃工作区修改\n$ git checkout -- file.name\n$ git checkout -- .\n\n# 取消commit(比如需要重写commit信息)\n$ git reset --soft HEAD\n\n# 取消commit、add(重新提交代码和commit)\n$ git reset HEAD\n$ git reset --mixed HEAD\n\n# 取消commit、add、工作区修改(需要完全重置)\n$ git reset --hard HEAD\n```\n#### 记录\n\n```\n$ git reflog\n$ git log\n```\n#### 删除\n\n```\n$ rm file.name\n$ git rm file.name\n$ git commit -m \"Del\"\n```\n#### 远程操作\n\n```\n$ git remote add origin git@github.com:shuangmuyingzi/loadingModule.git\n# 第一次推送，-u(--set-upstream)指定默认上游\n$ git push -u origin master\n$ git push origin master\n```\n#### 克隆\n\n```\n$ git clone https://github.com/shuangmuyingzi/loadingModule.git\n$ git clone git@github.com:shuangmuyingzi/loadingModule.git\n```\n#### 分支\n创建分支\n\n```\n$ git branch [name]\n```\n切换分支\n\n```\n$ git checkout [name]\n```\n创建并切换分支\n\n```\n$ git checkout -b [name]\n```\n合并分支\n\n```\n$ git merge [name]\n```\n删除分支\n\n```\n$ git branch -d [name]\n```\n查看分支\n\n```\n$ git branch\n```\n#### 撤销\n撤销本地修改\n\n```\n$ git checkout -- [filename]\n$ git checkout -- .\n```\n重置暂存区和工作区，与上一次commit保持一致\n\n```\n$ git reset --hard ［filename］\n```\n#### Git fetch和pull的区别\nGit中从远程的分支获取最新的版本到本地有这样2个命令：\n\n##### git fetch：相当于是从远程获取最新版本到本地，不会自动merge\n\ngit fetch origin master \ngit log -p master..origin/master \ngit merge origin/master\n\n以上命令的含义：\n\n首先从远程的origin的master主分支下载最新的版本到origin/master分支上；然后比较本地的master分支和origin/master分支的差别；最后进行合并。上述过程其实可以用以下更清晰的方式来进行： \ngit fetch origin master:tmp \ngit diff tmp \ngit merge tmp \n从远程获取最新的版本到本地的tmp分支上之后再进行比较合并\n\n##### git pull：相当于是从远程获取最新版本并merge到本地\n\ngit pull origin master\n\n上述命令其实相当于git fetch 和 git merge 在实际使用中，git fetch更安全一些。因为在merge前，我们可以查看更新情况，然后再决定是否合并结束。\n\n参考链接：\nhttps://aotu.io/notes/2015/11/17/Git-Commands/index.html\n\n\n\n\n\n\n","source":"_posts/git.md","raw":"title: 总有后悔药吃的git\ndate: 2018-04-28\ntag:\n - git\n\nphotos:\n - /img/2017/5.jpg \n\n---\n\n记录一些常用的git操作，以便回顾和查询。理解这些指令，觉得最重要的是理解Git的内部原理，比如Git的分布式版本控制，分清楚工作区、暂存区、版本库，还有就是理解Git跟踪并管理的是修改，而非文件。\n\n<!--more-->\n\n### 我的骚操作\n重说三：mac系统“最近使用”里面的文件不能删，不能删，千万不要随便删。那天我以为这里(最近使用)的文件是对别的地方的拷贝，我一向都有洁癖，经常会删除电脑那些基本不用的东西或者是重复的东西，结果一删造成千古恨，至今为止我都还没处理完造成的影响，只能发现再处理，好在有git仓库的文件可以有后悔药吃，其他的也就只能哭了。\n\n### 几个重要的名词\n![GitHub set up](https://shuangmuyingzi.github.io/img/git.jpeg)\n\n* Workspace：工作区\n* Index / Stage：暂存区\n* Repository：仓库区（或本地仓库）\n* Remote：远程仓库\n\n#### 设置\n\n```\n$ git config --global user.name \"Your Name\"\n$ git config --global user.email \"email@example.com\"\n```\n#### 提交\ngit 跟踪的是修改，而不是文件\n![GitHub set up](https://shuangmuyingzi.github.io/img/git2.png)\n\n```\n#将“当前修改”移动到暂存区(stage)\n git add a.txt\n#将暂存区修改提交\n git commit -m \"Add a.txt.\"\n```\n#### 查看状态\n\n```\n git status\n //显示暂存区和工作区的差异\n git diff\n```\n#### 回退\n\n```\n# 放弃工作区修改\n$ git checkout -- file.name\n$ git checkout -- .\n\n# 取消commit(比如需要重写commit信息)\n$ git reset --soft HEAD\n\n# 取消commit、add(重新提交代码和commit)\n$ git reset HEAD\n$ git reset --mixed HEAD\n\n# 取消commit、add、工作区修改(需要完全重置)\n$ git reset --hard HEAD\n```\n#### 记录\n\n```\n$ git reflog\n$ git log\n```\n#### 删除\n\n```\n$ rm file.name\n$ git rm file.name\n$ git commit -m \"Del\"\n```\n#### 远程操作\n\n```\n$ git remote add origin git@github.com:shuangmuyingzi/loadingModule.git\n# 第一次推送，-u(--set-upstream)指定默认上游\n$ git push -u origin master\n$ git push origin master\n```\n#### 克隆\n\n```\n$ git clone https://github.com/shuangmuyingzi/loadingModule.git\n$ git clone git@github.com:shuangmuyingzi/loadingModule.git\n```\n#### 分支\n创建分支\n\n```\n$ git branch [name]\n```\n切换分支\n\n```\n$ git checkout [name]\n```\n创建并切换分支\n\n```\n$ git checkout -b [name]\n```\n合并分支\n\n```\n$ git merge [name]\n```\n删除分支\n\n```\n$ git branch -d [name]\n```\n查看分支\n\n```\n$ git branch\n```\n#### 撤销\n撤销本地修改\n\n```\n$ git checkout -- [filename]\n$ git checkout -- .\n```\n重置暂存区和工作区，与上一次commit保持一致\n\n```\n$ git reset --hard ［filename］\n```\n#### Git fetch和pull的区别\nGit中从远程的分支获取最新的版本到本地有这样2个命令：\n\n##### git fetch：相当于是从远程获取最新版本到本地，不会自动merge\n\ngit fetch origin master \ngit log -p master..origin/master \ngit merge origin/master\n\n以上命令的含义：\n\n首先从远程的origin的master主分支下载最新的版本到origin/master分支上；然后比较本地的master分支和origin/master分支的差别；最后进行合并。上述过程其实可以用以下更清晰的方式来进行： \ngit fetch origin master:tmp \ngit diff tmp \ngit merge tmp \n从远程获取最新的版本到本地的tmp分支上之后再进行比较合并\n\n##### git pull：相当于是从远程获取最新版本并merge到本地\n\ngit pull origin master\n\n上述命令其实相当于git fetch 和 git merge 在实际使用中，git fetch更安全一些。因为在merge前，我们可以查看更新情况，然后再决定是否合并结束。\n\n参考链接：\nhttps://aotu.io/notes/2015/11/17/Git-Commands/index.html\n\n\n\n\n\n\n","slug":"git","published":1,"updated":"2018-08-28T10:16:55.759Z","_id":"cjldh03qr0002uv6xelpdsbu8","comments":1,"layout":"post","link":"","content":"<p>记录一些常用的git操作，以便回顾和查询。理解这些指令，觉得最重要的是理解Git的内部原理，比如Git的分布式版本控制，分清楚工作区、暂存区、版本库，还有就是理解Git跟踪并管理的是修改，而非文件。</p>\n<a id=\"more\"></a>\n<h3 id=\"我的骚操作\"><a href=\"#我的骚操作\" class=\"headerlink\" title=\"我的骚操作\"></a>我的骚操作</h3><p>重说三：mac系统“最近使用”里面的文件不能删，不能删，千万不要随便删。那天我以为这里(最近使用)的文件是对别的地方的拷贝，我一向都有洁癖，经常会删除电脑那些基本不用的东西或者是重复的东西，结果一删造成千古恨，至今为止我都还没处理完造成的影响，只能发现再处理，好在有git仓库的文件可以有后悔药吃，其他的也就只能哭了。</p>\n<h3 id=\"几个重要的名词\"><a href=\"#几个重要的名词\" class=\"headerlink\" title=\"几个重要的名词\"></a>几个重要的名词</h3><p><img src=\"https://shuangmuyingzi.github.io/img/git.jpeg\" alt=\"GitHub set up\"></p>\n<ul>\n<li>Workspace：工作区</li>\n<li>Index / Stage：暂存区</li>\n<li>Repository：仓库区（或本地仓库）</li>\n<li>Remote：远程仓库</li>\n</ul>\n<h4 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git config --global user.name &quot;Your Name&quot;</span><br><span class=\"line\">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"提交\"><a href=\"#提交\" class=\"headerlink\" title=\"提交\"></a>提交</h4><p>git 跟踪的是修改，而不是文件<br><img src=\"https://shuangmuyingzi.github.io/img/git2.png\" alt=\"GitHub set up\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#将“当前修改”移动到暂存区(stage)</span><br><span class=\"line\"> git add a.txt</span><br><span class=\"line\">#将暂存区修改提交</span><br><span class=\"line\"> git commit -m &quot;Add a.txt.&quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"查看状态\"><a href=\"#查看状态\" class=\"headerlink\" title=\"查看状态\"></a>查看状态</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">git status</span><br><span class=\"line\">//显示暂存区和工作区的差异</span><br><span class=\"line\">git diff</span><br></pre></td></tr></table></figure>\n<h4 id=\"回退\"><a href=\"#回退\" class=\"headerlink\" title=\"回退\"></a>回退</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 放弃工作区修改</span><br><span class=\"line\">$ git checkout -- file.name</span><br><span class=\"line\">$ git checkout -- .</span><br><span class=\"line\"></span><br><span class=\"line\"># 取消commit(比如需要重写commit信息)</span><br><span class=\"line\">$ git reset --soft HEAD</span><br><span class=\"line\"></span><br><span class=\"line\"># 取消commit、add(重新提交代码和commit)</span><br><span class=\"line\">$ git reset HEAD</span><br><span class=\"line\">$ git reset --mixed HEAD</span><br><span class=\"line\"></span><br><span class=\"line\"># 取消commit、add、工作区修改(需要完全重置)</span><br><span class=\"line\">$ git reset --hard HEAD</span><br></pre></td></tr></table></figure>\n<h4 id=\"记录\"><a href=\"#记录\" class=\"headerlink\" title=\"记录\"></a>记录</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git reflog</span><br><span class=\"line\">$ git log</span><br></pre></td></tr></table></figure>\n<h4 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ rm file.name</span><br><span class=\"line\">$ git rm file.name</span><br><span class=\"line\">$ git commit -m &quot;Del&quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"远程操作\"><a href=\"#远程操作\" class=\"headerlink\" title=\"远程操作\"></a>远程操作</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git remote add origin git@github.com:shuangmuyingzi/loadingModule.git</span><br><span class=\"line\"># 第一次推送，-u(--set-upstream)指定默认上游</span><br><span class=\"line\">$ git push -u origin master</span><br><span class=\"line\">$ git push origin master</span><br></pre></td></tr></table></figure>\n<h4 id=\"克隆\"><a href=\"#克隆\" class=\"headerlink\" title=\"克隆\"></a>克隆</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git clone https://github.com/shuangmuyingzi/loadingModule.git</span><br><span class=\"line\">$ git clone git@github.com:shuangmuyingzi/loadingModule.git</span><br></pre></td></tr></table></figure>\n<h4 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h4><p>创建分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git branch [name]</span><br></pre></td></tr></table></figure>\n<p>切换分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git checkout [name]</span><br></pre></td></tr></table></figure>\n<p>创建并切换分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git checkout -b [name]</span><br></pre></td></tr></table></figure>\n<p>合并分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git merge [name]</span><br></pre></td></tr></table></figure>\n<p>删除分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git branch -d [name]</span><br></pre></td></tr></table></figure>\n<p>查看分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git branch</span><br></pre></td></tr></table></figure>\n<h4 id=\"撤销\"><a href=\"#撤销\" class=\"headerlink\" title=\"撤销\"></a>撤销</h4><p>撤销本地修改</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git checkout -- [filename]</span><br><span class=\"line\">$ git checkout -- .</span><br></pre></td></tr></table></figure>\n<p>重置暂存区和工作区，与上一次commit保持一致</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git reset --hard ［filename］</span><br></pre></td></tr></table></figure>\n<h4 id=\"Git-fetch和pull的区别\"><a href=\"#Git-fetch和pull的区别\" class=\"headerlink\" title=\"Git fetch和pull的区别\"></a>Git fetch和pull的区别</h4><p>Git中从远程的分支获取最新的版本到本地有这样2个命令：</p>\n<h5 id=\"git-fetch：相当于是从远程获取最新版本到本地，不会自动merge\"><a href=\"#git-fetch：相当于是从远程获取最新版本到本地，不会自动merge\" class=\"headerlink\" title=\"git fetch：相当于是从远程获取最新版本到本地，不会自动merge\"></a>git fetch：相当于是从远程获取最新版本到本地，不会自动merge</h5><p>git fetch origin master<br>git log -p master..origin/master<br>git merge origin/master</p>\n<p>以上命令的含义：</p>\n<p>首先从远程的origin的master主分支下载最新的版本到origin/master分支上；然后比较本地的master分支和origin/master分支的差别；最后进行合并。上述过程其实可以用以下更清晰的方式来进行：<br>git fetch origin master:tmp<br>git diff tmp<br>git merge tmp<br>从远程获取最新的版本到本地的tmp分支上之后再进行比较合并</p>\n<h5 id=\"git-pull：相当于是从远程获取最新版本并merge到本地\"><a href=\"#git-pull：相当于是从远程获取最新版本并merge到本地\" class=\"headerlink\" title=\"git pull：相当于是从远程获取最新版本并merge到本地\"></a>git pull：相当于是从远程获取最新版本并merge到本地</h5><p>git pull origin master</p>\n<p>上述命令其实相当于git fetch 和 git merge 在实际使用中，git fetch更安全一些。因为在merge前，我们可以查看更新情况，然后再决定是否合并结束。</p>\n<p>参考链接：<br><a href=\"https://aotu.io/notes/2015/11/17/Git-Commands/index.html\" target=\"_blank\" rel=\"noopener\">https://aotu.io/notes/2015/11/17/Git-Commands/index.html</a></p>\n","site":{"data":{}},"excerpt":"<p>记录一些常用的git操作，以便回顾和查询。理解这些指令，觉得最重要的是理解Git的内部原理，比如Git的分布式版本控制，分清楚工作区、暂存区、版本库，还有就是理解Git跟踪并管理的是修改，而非文件。</p>","more":"<h3 id=\"我的骚操作\"><a href=\"#我的骚操作\" class=\"headerlink\" title=\"我的骚操作\"></a>我的骚操作</h3><p>重说三：mac系统“最近使用”里面的文件不能删，不能删，千万不要随便删。那天我以为这里(最近使用)的文件是对别的地方的拷贝，我一向都有洁癖，经常会删除电脑那些基本不用的东西或者是重复的东西，结果一删造成千古恨，至今为止我都还没处理完造成的影响，只能发现再处理，好在有git仓库的文件可以有后悔药吃，其他的也就只能哭了。</p>\n<h3 id=\"几个重要的名词\"><a href=\"#几个重要的名词\" class=\"headerlink\" title=\"几个重要的名词\"></a>几个重要的名词</h3><p><img src=\"https://shuangmuyingzi.github.io/img/git.jpeg\" alt=\"GitHub set up\"></p>\n<ul>\n<li>Workspace：工作区</li>\n<li>Index / Stage：暂存区</li>\n<li>Repository：仓库区（或本地仓库）</li>\n<li>Remote：远程仓库</li>\n</ul>\n<h4 id=\"设置\"><a href=\"#设置\" class=\"headerlink\" title=\"设置\"></a>设置</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git config --global user.name &quot;Your Name&quot;</span><br><span class=\"line\">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"提交\"><a href=\"#提交\" class=\"headerlink\" title=\"提交\"></a>提交</h4><p>git 跟踪的是修改，而不是文件<br><img src=\"https://shuangmuyingzi.github.io/img/git2.png\" alt=\"GitHub set up\"></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#将“当前修改”移动到暂存区(stage)</span><br><span class=\"line\"> git add a.txt</span><br><span class=\"line\">#将暂存区修改提交</span><br><span class=\"line\"> git commit -m &quot;Add a.txt.&quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"查看状态\"><a href=\"#查看状态\" class=\"headerlink\" title=\"查看状态\"></a>查看状态</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">git status</span><br><span class=\"line\">//显示暂存区和工作区的差异</span><br><span class=\"line\">git diff</span><br></pre></td></tr></table></figure>\n<h4 id=\"回退\"><a href=\"#回退\" class=\"headerlink\" title=\"回退\"></a>回退</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 放弃工作区修改</span><br><span class=\"line\">$ git checkout -- file.name</span><br><span class=\"line\">$ git checkout -- .</span><br><span class=\"line\"></span><br><span class=\"line\"># 取消commit(比如需要重写commit信息)</span><br><span class=\"line\">$ git reset --soft HEAD</span><br><span class=\"line\"></span><br><span class=\"line\"># 取消commit、add(重新提交代码和commit)</span><br><span class=\"line\">$ git reset HEAD</span><br><span class=\"line\">$ git reset --mixed HEAD</span><br><span class=\"line\"></span><br><span class=\"line\"># 取消commit、add、工作区修改(需要完全重置)</span><br><span class=\"line\">$ git reset --hard HEAD</span><br></pre></td></tr></table></figure>\n<h4 id=\"记录\"><a href=\"#记录\" class=\"headerlink\" title=\"记录\"></a>记录</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git reflog</span><br><span class=\"line\">$ git log</span><br></pre></td></tr></table></figure>\n<h4 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ rm file.name</span><br><span class=\"line\">$ git rm file.name</span><br><span class=\"line\">$ git commit -m &quot;Del&quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"远程操作\"><a href=\"#远程操作\" class=\"headerlink\" title=\"远程操作\"></a>远程操作</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git remote add origin git@github.com:shuangmuyingzi/loadingModule.git</span><br><span class=\"line\"># 第一次推送，-u(--set-upstream)指定默认上游</span><br><span class=\"line\">$ git push -u origin master</span><br><span class=\"line\">$ git push origin master</span><br></pre></td></tr></table></figure>\n<h4 id=\"克隆\"><a href=\"#克隆\" class=\"headerlink\" title=\"克隆\"></a>克隆</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git clone https://github.com/shuangmuyingzi/loadingModule.git</span><br><span class=\"line\">$ git clone git@github.com:shuangmuyingzi/loadingModule.git</span><br></pre></td></tr></table></figure>\n<h4 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h4><p>创建分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git branch [name]</span><br></pre></td></tr></table></figure>\n<p>切换分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git checkout [name]</span><br></pre></td></tr></table></figure>\n<p>创建并切换分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git checkout -b [name]</span><br></pre></td></tr></table></figure>\n<p>合并分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git merge [name]</span><br></pre></td></tr></table></figure>\n<p>删除分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git branch -d [name]</span><br></pre></td></tr></table></figure>\n<p>查看分支</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git branch</span><br></pre></td></tr></table></figure>\n<h4 id=\"撤销\"><a href=\"#撤销\" class=\"headerlink\" title=\"撤销\"></a>撤销</h4><p>撤销本地修改</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git checkout -- [filename]</span><br><span class=\"line\">$ git checkout -- .</span><br></pre></td></tr></table></figure>\n<p>重置暂存区和工作区，与上一次commit保持一致</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ git reset --hard ［filename］</span><br></pre></td></tr></table></figure>\n<h4 id=\"Git-fetch和pull的区别\"><a href=\"#Git-fetch和pull的区别\" class=\"headerlink\" title=\"Git fetch和pull的区别\"></a>Git fetch和pull的区别</h4><p>Git中从远程的分支获取最新的版本到本地有这样2个命令：</p>\n<h5 id=\"git-fetch：相当于是从远程获取最新版本到本地，不会自动merge\"><a href=\"#git-fetch：相当于是从远程获取最新版本到本地，不会自动merge\" class=\"headerlink\" title=\"git fetch：相当于是从远程获取最新版本到本地，不会自动merge\"></a>git fetch：相当于是从远程获取最新版本到本地，不会自动merge</h5><p>git fetch origin master<br>git log -p master..origin/master<br>git merge origin/master</p>\n<p>以上命令的含义：</p>\n<p>首先从远程的origin的master主分支下载最新的版本到origin/master分支上；然后比较本地的master分支和origin/master分支的差别；最后进行合并。上述过程其实可以用以下更清晰的方式来进行：<br>git fetch origin master:tmp<br>git diff tmp<br>git merge tmp<br>从远程获取最新的版本到本地的tmp分支上之后再进行比较合并</p>\n<h5 id=\"git-pull：相当于是从远程获取最新版本并merge到本地\"><a href=\"#git-pull：相当于是从远程获取最新版本并merge到本地\" class=\"headerlink\" title=\"git pull：相当于是从远程获取最新版本并merge到本地\"></a>git pull：相当于是从远程获取最新版本并merge到本地</h5><p>git pull origin master</p>\n<p>上述命令其实相当于git fetch 和 git merge 在实际使用中，git fetch更安全一些。因为在merge前，我们可以查看更新情况，然后再决定是否合并结束。</p>\n<p>参考链接：<br><a href=\"https://aotu.io/notes/2015/11/17/Git-Commands/index.html\" target=\"_blank\" rel=\"noopener\">https://aotu.io/notes/2015/11/17/Git-Commands/index.html</a></p>"},{"title":"JavaScript guide","date":"2017-12-27T16:00:00.000Z","photos":["/img/2017/4.jpg"],"_content":"\n本文主要记录一些javascript优秀的写法，自己又老是不习惯使用的，方便日后养成习惯。\n\n<!--more-->\n\n## JavaScript guide es5\n\n### 数组\n1、当你需要拷贝数组时，使用 Array#slice。\n\n```\nvar len = items.length;\nvar itemsCopy = [];\nvar i;\n// bad\nfor (i = 0; i < len; i++) {\n  itemsCopy[i] = items[i];\n}\n// good\nitemsCopy = items.slice();\n```\n2、使用 Array#slice 将类数组对象转换成数组。\n\n```\nfunction trigger() {\n  var args = Array.prototype.slice.call(arguments);\n  ...\n}\n```\n### 字符串\n1、使用单引号 `''` 包裹字符串。\n\n```\n// bad\nvar name = \"Bob Parr\";\n// good\nvar name = 'Bob Parr';\n// bad\nvar fullName = \"Bob \" + this.lastName;\n// good\nvar fullName = 'Bob ' + this.lastName;\n```\n2、超过 100 个字符的字符串应该使用连接符写成多行。\n3、注：若过度使用，通过连接符连接的长字符串可能会影响性能。\n\n```\n// bad\nvar errorMessage = 'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.';\n// bad\nvar errorMessage = 'This is a super long error that was thrown because \\\nof Batman. When you stop to think about how Batman had anything to do \\\nwith this, you would get nowhere \\\nfast.';\n// good\nvar errorMessage = 'This is a super long error that was thrown because ' +\n  'of Batman. When you stop to think about how Batman had anything to do ' +\n  'with this, you would get nowhere fast.';\n```\n4、程序化生成的字符串使用 Array#join 连接而不是使用连接符。尤其是 IE 下：\n\n```\nvar items;\nvar messages;\nvar length;\nvar i;\nmessages = [{\n  state: 'success',\n  message: 'This one worked.'\n}, {\n  state: 'success',\n  message: 'This one worked as well.'\n}, {\n  state: 'error',\n  message: 'This one did not work.'\n}];\nlength = messages.length;\n// bad\nfunction inbox(messages) {\n  items = '<ul>';\n  for (i = 0; i < length; i++) {\n    items += '<li>' + messages[i].message + '</li>';\n  }\n  return items + '</ul>';\n}\n// good\nfunction inbox(messages) {\n  items = [];\n  for (i = 0; i < length; i++) {\n    // use direct assignment in this case because we're micro-optimizing.\n    items[i] = '<li>' + messages[i].message + '</li>';\n  }\n  return '<ul>' + items.join('') + '</ul>';\n}\n```\n### 函数\n1、函数表达式：\n\n```\n// 匿名函数表达式\nvar anonymous = function() {\n  return true;\n};\n// 命名函数表达式\nvar named = function named() {\n  return true;\n};\n// 立即调用的函数表达式（IIFE）\n(function () {\n  console.log('Welcome to the Internet. Please follow me.');\n}());\n```\n2、永远不要在一个非函数代码块（if、while 等）中声明一个函数，浏览器允许你这么做，但它们的解析表现不一致，正确的做法是：在块外定义一个变量，然后将函数赋值给它。\n\n3、注： ECMA-262 把 块 定义为一组语句。函数声明不是语句。\n\n```\n// bad\nif (currentUser) {\n  function test() {\n    console.log('Nope.');\n  }\n}\n// good\nvar test;\nif (currentUser) {\n  test = function test() {\n    console.log('Yup.');\n  };\n}\n```\n4、永远不要把参数命名为 arguments。这将取代函数作用域内的 arguments 对象。\n\n```\n// bad\nfunction nope(name, options, arguments) {\n  // ...stuff...\n}\n// good\nfunction yup(name, options, args) {\n  // ...stuff...\n}\n```\n### 变量\n1、使用 var 声明每一个变量。\n这样做的好处是增加新变量将变的更加容易，而且你永远不用再担心调换错 ; 跟 ,。\n\n```\n// bad\nvar items = getItems(),\n    goSportsTeam = true,\n    dragonball = 'z';\n// bad\n// （跟上面的代码比较一下，看看哪里错了）\nvar items = getItems(),\n    goSportsTeam = true;\n    dragonball = 'z';\n// good\nvar items = getItems();\nvar goSportsTeam = true;\nvar dragonball = 'z';\n```\n2、最后再声明未赋值的变量。当你需要引用前面的变量赋值时这将变的很有用。\n\n```\n// bad\nvar i, len, dragonball,\n    items = getItems(),\n    goSportsTeam = true;\n// bad\nvar i;\nvar items = getItems();\nvar dragonball;\nvar goSportsTeam = true;\nvar len;\n// good\nvar items = getItems();\nvar goSportsTeam = true;\nvar dragonball;\nvar length;\nvar i;\n```\n3、在作用域顶部声明变量。这将帮你避免变量声明提升相关的问题。\n\n```\n// bad\nfunction () {\n  test();\n  console.log('doing stuff..');\n  //..other stuff..\n  var name = getName();\n  if (name === 'test') {\n    return false;\n  }\n  return name;\n}\n// good\nfunction () {\n  var name = getName();\n  test();\n  console.log('doing stuff..');\n  //..other stuff..\n  if (name === 'test') {\n    return false;\n  }\n  return name;\n}\n// bad - 不必要的函数调用\nfunction () {\n  var name = getName();\n  if (!arguments.length) {\n    return false;\n  }\n  this.setFirstName(name);\n  return true;\n}\n// good\nfunction () {\n  var name;\n  if (!arguments.length) {\n    return false;\n  }\n  name = getName();\n  this.setFirstName(name);\n  return true;\n}\n```\n\n### 比较运算符 & 等号\n1、优先使用 === 和 !== 而不是 == 和 !=.\n2、条件表达式例如 if 语句通过抽象方法 ToBoolean 强制计算它们的表达式并且总是遵守下面的规则：\n对象 被计算为 true\nUndefined 被计算为 false\nNull 被计算为 false\n布尔值 被计算为 布尔的值\n数字 如果是 +0、-0 或 NaN 被计算为 false，否则为 true\n字符串 如果是空字符串 '' 被计算为 false，否则为 true\n\n```\nif ([0]) {\n  // true\n  // 一个数组就是一个对象，对象被计算为 true\n}\n```\n3、使用快捷方式。\n\n```\n// bad\nif (name !== '') {\n  // ...stuff...\n}\n// good\nif (name) {\n  // ...stuff...\n}\n// bad\nif (collection.length > 0) {\n  // ...stuff...\n}\n// good\nif (collection.length) {\n  // ...stuff...\n}\n```\n### 块\n1、使用大括号包裹所有的多行代码块。\n\n```\n// bad\nif (test)\n  return false;\n// good\nif (test) return false;\n// good\nif (test) {\n  return false;\n}\n// bad\nfunction () { return false; }\n// good\nfunction () {\n  return false;\n}\n```\n### 注释\n1、使用 /** ... */ 作为多行注释。包含描述、指定所有参数和返回值的类型和值。\n\n```\n// bad\n// make() returns a new element\n// based on the passed in tag name\n//\n// @param {String} tag\n// @return {Element} element\nfunction make(tag) {\n  // ...stuff...\n  return element;\n}\n// good\n/**\n * make() returns a new element\n * based on the passed in tag name\n *\n * @param {String} tag\n * @return {Element} element\n */\nfunction make(tag) {\n  // ...stuff...\n  return element;\n}\n```\n2、使用 // 作为单行注释。在评论对象上面另起一行使用单行注释。在注释前插入空行。\n\n```\n// bad\nvar active = true;  // is current tab\n// good\n// is current tab\nvar active = true;\n// bad\nfunction getType() {\n  console.log('fetching type...');\n  // set the default type to 'no type'\n  var type = this.type || 'no type';\n  return type;\n}\n// good\nfunction getType() {\n  console.log('fetching type...');\n  // set the default type to 'no type'\n  var type = this.type || 'no type';\n  return type;\n}\n```\n3、给注释增加 FIXME 或 TODO 的前缀可以帮助其他开发者快速了解这是一个需要复查的问题，或是给需要实现的功能提供一个解决方式。这将有别于常见的注释，因为它们是可操作的。使用 FIXME -- need to figure this out 或者 TODO -- need to implement。\n\n4、使用 // FIXME: 标注问题。\n\n```\nfunction Calculator() {\n  // FIXME: shouldn't use a global here\n  total = 0;\n  return this;\n}\n\n```\n5、使用 // TODO: 标注问题的解决方式。\n\n```\nfunction Calculator() {\n  // TODO: total should be configurable by an options param\n  this.total = 0;\n  return this;\n}\n```\n### 空白\n1、使用 2 个空格作为缩进。\n\n```\n// bad\nfunction () {\n∙∙∙∙var name;\n}\n// bad\nfunction () {\n∙var name;\n}\n// good\nfunction () {\n∙∙var name;\n}\n```\n2、在大括号前放一个空格。\n\n```\n// bad\nfunction test(){\n  console.log('test');\n}\n// good\nfunction test() {\n  console.log('test');\n}\n// bad\ndog.set('attr',{\n  age: '1 year',\n  breed: 'Bernese Mountain Dog'\n});\n// good\ndog.set('attr', {\n  age: '1 year',\n  breed: 'Bernese Mountain Dog'\n});\n```\n3、在控制语句（if、while 等）的小括号前放一个空格。在函数调用及声明中，不在函数的参数列表前加空格。\n\n```\n// bad\nif(isJedi) {\n  fight ();\n}\n// good\nif (isJedi) {\n  fight();\n}\n// bad\nfunction fight () {\n  console.log ('Swooosh!');\n}\n// good\nfunction fight() {\n  console.log('Swooosh!');\n}\n```\n4、使用空格把运算符隔开。\n\n```\n// bad\nvar x=y+5;\n// good\nvar x = y + 5;\n```\n5、在文件末尾插入一个空行。\n\n```\n// bad\n(function (global) {\n  // ...stuff...\n})(this);\n```\n```\n// bad\n(function (global) {\n  // ...stuff...\n})(this);↵\n↵\n```\n```\n// good\n(function (global) {\n  // ...stuff...\n})(this);↵\n```\n6、在使用长方法链时进行缩进。使用前面的点 . 强调这是方法调用而不是新语句。\n\n```\n// bad\n$('#items').find('.selected').highlight().end().find('.open').updateCount();\n// bad\n$('#items').\n  find('.selected').\n    highlight().\n    end().\n  find('.open').\n    updateCount();\n// good\n$('#items')\n  .find('.selected')\n    .highlight()\n    .end()\n  .find('.open')\n    .updateCount();\n// bad\nvar leds = stage.selectAll('.led').data(data).enter().append('svg:svg').classed('led', true)\n    .attr('width', (radius + margin) * 2).append('svg:g')\n    .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')')\n    .call(tron.led);\n// good\nvar leds = stage.selectAll('.led')\n    .data(data)\n  .enter().append('svg:svg')\n    .classed('led', true)\n    .attr('width', (radius + margin) * 2)\n  .append('svg:g')\n    .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')')\n    .call(tron.led);\n```\n7、在块末和新语句前插入空行。\n\n```\n// bad\nif (foo) {\n  return bar;\n}\nreturn baz;\n// good\nif (foo) {\n  return bar;\n}\nreturn baz;\n// bad\nvar obj = {\n  foo: function () {\n  },\n  bar: function () {\n  }\n};\nreturn obj;\n// good\nvar obj = {\n  foo: function () {\n  },\n  bar: function () {\n  }\n};\nreturn obj;\n```\n### 分号\n1、使用分号。\n\n```\n// bad\n(function () {\n  var name = 'Skywalker'\n  return name\n})()\n// good\n(function () {\n  var name = 'Skywalker';\n  return name;\n})();\n// good (防止函数在两个 IIFE 合并时被当成一个参数\n;(function () {\n  var name = 'Skywalker';\n  return name;\n})();\n```\n### 类型转换\n1、在语句开始时执行类型转换。\n2、字符串：\n\n```\n//  => this.reviewScore = 9;\n// bad\nvar totalScore = this.reviewScore + '';\n// good\nvar totalScore = '' + this.reviewScore;\n// bad\nvar totalScore = '' + this.reviewScore + ' total score';\n// good\nvar totalScore = this.reviewScore + ' total score';\n```\n3、使用 parseInt 转换数字时总是带上类型转换的基数。\n\n```\nvar inputValue = '4';\n// bad\nvar val = new Number(inputValue);\n// bad\nvar val = +inputValue;\n// bad\nvar val = inputValue >> 0;\n// bad\nvar val = parseInt(inputValue);\n// good\nvar val = Number(inputValue);\n// good\nvar val = parseInt(inputValue, 10);\n```\n4、如果因为某些原因 parseInt 成为你所做的事的瓶颈而需要使用位操作解决性能问题时，留个注释说清楚原因和你的目的。\n\n```\n// good\n/**\n * parseInt was the reason my code was slow.\n * Bitshifting the String to coerce it to a\n * Number made it a lot faster.\n */\nvar val = inputValue >> 0;\n```\n5、布尔:\n\n```\nvar age = 0;\n// bad\nvar hasAge = new Boolean(age);\n// good\nvar hasAge = Boolean(age);\n// good\nvar hasAge = !!age;\n```\n### 命名规则\n1、避免单字母命名。命名应具备描述性。\n\n```\n// bad\nfunction q() {\n  // ...stuff...\n}\n// good\nfunction query() {\n  // ..stuff..\n```\n2、使用驼峰式命名对象、函数和实例。\n\n```\n// bad\nvar OBJEcttsssss = {};\nvar this_is_my_object = {};\nvar o = {};\nfunction c() {}\n// good\nvar thisIsMyObject = {};\nfunction thisIsMyFunction() {}\n```\n3、使用帕斯卡式命名构造函数或类。\n\n```\n// bad\nfunction user(options) {\n  this.name = options.name;\n}\nvar bad = new user({\n  name: 'nope'\n});\n// good\nfunction User(options) {\n  this.name = options.name;\n}\nvar good = new User({\n  name: 'yup'\n});\n```\n4、不要使用下划线前/后缀。\n为什么？JavaScript 并没有私有属性或私有方法的概念。虽然使用下划线是表示「私有」的一种共识，但实际上这些属性是完全公开的，它本身就是你公共接口的一部分。这种习惯或许会导致开发者错误的认为改动它不会造成破坏或者不需要去测试。长话短说：如果你想要某处为「私有」，它必须不能是显式提出的。\n\n```\n// bad\nthis.__firstName__ = 'Panda';\nthis.firstName_ = 'Panda';\nthis._firstName = 'Panda';\n// good\nthis.firstName = 'Panda';\n```\n5、不要保存 this 的引用。使用 Function#bind。\n\n```\n// bad\nfunction () {\n  var self = this;\n  return function () {\n    console.log(self);\n  };\n}\n// bad\nfunction () {\n  var that = this;\n  return function () {\n    console.log(that);\n  };\n}\n// bad\nfunction () {\n  var _this = this;\n  return function () {\n    console.log(_this);\n  };\n}\n// good\nfunction () {\n  return function () {\n    console.log(this);\n  }.bind(this);\n}\n```\n6、如果你的文件导出一个类，你的文件名应该与类名完全相同。\n\n```\n// file contents\nclass CheckBox {\n  // ...\n}\nmodule.exports = CheckBox;\n// in some other file\n// bad\nvar CheckBox = require('./checkBox');\n// bad\nvar CheckBox = require('./check_box');\n// good\nvar CheckBox = require('./CheckBox');\n```\n### 模块\n1、模块应该以 ! 开始。这样确保了当一个不好的模块忘记包含最后的分号时，在合并代码到生产环境后不会产生错误\n2、文件应该以驼峰式命名，并放在同名的文件夹里，且与导出的名字一致。\n3、增加一个名为 noConflict() 的方法来设置导出的模块为前一个版本并返回它。\n4、永远在模块顶部声明 'use strict';。\n\n```\n// fancyInput/fancyInput.js\n!function (global) {\n  'use strict';\n  var previousFancyInput = global.FancyInput;\n  function FancyInput(options) {\n    this.options = options || {};\n  }\n  FancyInput.noConflict = function noConflict() {\n    global.FancyInput = previousFancyInput;\n    return FancyInput;\n  };\n  global.FancyInput = FancyInput;\n}(this);\n```\n参考链接：https://github.com/sivan/javascript-style-guide/blob/master/es5/README.md\n\n\n","source":"_posts/guide.md","raw":"title: JavaScript guide\ndate: 2017-12-28\ntag:\n - js\n\nphotos:\n - /img/2017/4.jpg \n\n---\n\n本文主要记录一些javascript优秀的写法，自己又老是不习惯使用的，方便日后养成习惯。\n\n<!--more-->\n\n## JavaScript guide es5\n\n### 数组\n1、当你需要拷贝数组时，使用 Array#slice。\n\n```\nvar len = items.length;\nvar itemsCopy = [];\nvar i;\n// bad\nfor (i = 0; i < len; i++) {\n  itemsCopy[i] = items[i];\n}\n// good\nitemsCopy = items.slice();\n```\n2、使用 Array#slice 将类数组对象转换成数组。\n\n```\nfunction trigger() {\n  var args = Array.prototype.slice.call(arguments);\n  ...\n}\n```\n### 字符串\n1、使用单引号 `''` 包裹字符串。\n\n```\n// bad\nvar name = \"Bob Parr\";\n// good\nvar name = 'Bob Parr';\n// bad\nvar fullName = \"Bob \" + this.lastName;\n// good\nvar fullName = 'Bob ' + this.lastName;\n```\n2、超过 100 个字符的字符串应该使用连接符写成多行。\n3、注：若过度使用，通过连接符连接的长字符串可能会影响性能。\n\n```\n// bad\nvar errorMessage = 'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.';\n// bad\nvar errorMessage = 'This is a super long error that was thrown because \\\nof Batman. When you stop to think about how Batman had anything to do \\\nwith this, you would get nowhere \\\nfast.';\n// good\nvar errorMessage = 'This is a super long error that was thrown because ' +\n  'of Batman. When you stop to think about how Batman had anything to do ' +\n  'with this, you would get nowhere fast.';\n```\n4、程序化生成的字符串使用 Array#join 连接而不是使用连接符。尤其是 IE 下：\n\n```\nvar items;\nvar messages;\nvar length;\nvar i;\nmessages = [{\n  state: 'success',\n  message: 'This one worked.'\n}, {\n  state: 'success',\n  message: 'This one worked as well.'\n}, {\n  state: 'error',\n  message: 'This one did not work.'\n}];\nlength = messages.length;\n// bad\nfunction inbox(messages) {\n  items = '<ul>';\n  for (i = 0; i < length; i++) {\n    items += '<li>' + messages[i].message + '</li>';\n  }\n  return items + '</ul>';\n}\n// good\nfunction inbox(messages) {\n  items = [];\n  for (i = 0; i < length; i++) {\n    // use direct assignment in this case because we're micro-optimizing.\n    items[i] = '<li>' + messages[i].message + '</li>';\n  }\n  return '<ul>' + items.join('') + '</ul>';\n}\n```\n### 函数\n1、函数表达式：\n\n```\n// 匿名函数表达式\nvar anonymous = function() {\n  return true;\n};\n// 命名函数表达式\nvar named = function named() {\n  return true;\n};\n// 立即调用的函数表达式（IIFE）\n(function () {\n  console.log('Welcome to the Internet. Please follow me.');\n}());\n```\n2、永远不要在一个非函数代码块（if、while 等）中声明一个函数，浏览器允许你这么做，但它们的解析表现不一致，正确的做法是：在块外定义一个变量，然后将函数赋值给它。\n\n3、注： ECMA-262 把 块 定义为一组语句。函数声明不是语句。\n\n```\n// bad\nif (currentUser) {\n  function test() {\n    console.log('Nope.');\n  }\n}\n// good\nvar test;\nif (currentUser) {\n  test = function test() {\n    console.log('Yup.');\n  };\n}\n```\n4、永远不要把参数命名为 arguments。这将取代函数作用域内的 arguments 对象。\n\n```\n// bad\nfunction nope(name, options, arguments) {\n  // ...stuff...\n}\n// good\nfunction yup(name, options, args) {\n  // ...stuff...\n}\n```\n### 变量\n1、使用 var 声明每一个变量。\n这样做的好处是增加新变量将变的更加容易，而且你永远不用再担心调换错 ; 跟 ,。\n\n```\n// bad\nvar items = getItems(),\n    goSportsTeam = true,\n    dragonball = 'z';\n// bad\n// （跟上面的代码比较一下，看看哪里错了）\nvar items = getItems(),\n    goSportsTeam = true;\n    dragonball = 'z';\n// good\nvar items = getItems();\nvar goSportsTeam = true;\nvar dragonball = 'z';\n```\n2、最后再声明未赋值的变量。当你需要引用前面的变量赋值时这将变的很有用。\n\n```\n// bad\nvar i, len, dragonball,\n    items = getItems(),\n    goSportsTeam = true;\n// bad\nvar i;\nvar items = getItems();\nvar dragonball;\nvar goSportsTeam = true;\nvar len;\n// good\nvar items = getItems();\nvar goSportsTeam = true;\nvar dragonball;\nvar length;\nvar i;\n```\n3、在作用域顶部声明变量。这将帮你避免变量声明提升相关的问题。\n\n```\n// bad\nfunction () {\n  test();\n  console.log('doing stuff..');\n  //..other stuff..\n  var name = getName();\n  if (name === 'test') {\n    return false;\n  }\n  return name;\n}\n// good\nfunction () {\n  var name = getName();\n  test();\n  console.log('doing stuff..');\n  //..other stuff..\n  if (name === 'test') {\n    return false;\n  }\n  return name;\n}\n// bad - 不必要的函数调用\nfunction () {\n  var name = getName();\n  if (!arguments.length) {\n    return false;\n  }\n  this.setFirstName(name);\n  return true;\n}\n// good\nfunction () {\n  var name;\n  if (!arguments.length) {\n    return false;\n  }\n  name = getName();\n  this.setFirstName(name);\n  return true;\n}\n```\n\n### 比较运算符 & 等号\n1、优先使用 === 和 !== 而不是 == 和 !=.\n2、条件表达式例如 if 语句通过抽象方法 ToBoolean 强制计算它们的表达式并且总是遵守下面的规则：\n对象 被计算为 true\nUndefined 被计算为 false\nNull 被计算为 false\n布尔值 被计算为 布尔的值\n数字 如果是 +0、-0 或 NaN 被计算为 false，否则为 true\n字符串 如果是空字符串 '' 被计算为 false，否则为 true\n\n```\nif ([0]) {\n  // true\n  // 一个数组就是一个对象，对象被计算为 true\n}\n```\n3、使用快捷方式。\n\n```\n// bad\nif (name !== '') {\n  // ...stuff...\n}\n// good\nif (name) {\n  // ...stuff...\n}\n// bad\nif (collection.length > 0) {\n  // ...stuff...\n}\n// good\nif (collection.length) {\n  // ...stuff...\n}\n```\n### 块\n1、使用大括号包裹所有的多行代码块。\n\n```\n// bad\nif (test)\n  return false;\n// good\nif (test) return false;\n// good\nif (test) {\n  return false;\n}\n// bad\nfunction () { return false; }\n// good\nfunction () {\n  return false;\n}\n```\n### 注释\n1、使用 /** ... */ 作为多行注释。包含描述、指定所有参数和返回值的类型和值。\n\n```\n// bad\n// make() returns a new element\n// based on the passed in tag name\n//\n// @param {String} tag\n// @return {Element} element\nfunction make(tag) {\n  // ...stuff...\n  return element;\n}\n// good\n/**\n * make() returns a new element\n * based on the passed in tag name\n *\n * @param {String} tag\n * @return {Element} element\n */\nfunction make(tag) {\n  // ...stuff...\n  return element;\n}\n```\n2、使用 // 作为单行注释。在评论对象上面另起一行使用单行注释。在注释前插入空行。\n\n```\n// bad\nvar active = true;  // is current tab\n// good\n// is current tab\nvar active = true;\n// bad\nfunction getType() {\n  console.log('fetching type...');\n  // set the default type to 'no type'\n  var type = this.type || 'no type';\n  return type;\n}\n// good\nfunction getType() {\n  console.log('fetching type...');\n  // set the default type to 'no type'\n  var type = this.type || 'no type';\n  return type;\n}\n```\n3、给注释增加 FIXME 或 TODO 的前缀可以帮助其他开发者快速了解这是一个需要复查的问题，或是给需要实现的功能提供一个解决方式。这将有别于常见的注释，因为它们是可操作的。使用 FIXME -- need to figure this out 或者 TODO -- need to implement。\n\n4、使用 // FIXME: 标注问题。\n\n```\nfunction Calculator() {\n  // FIXME: shouldn't use a global here\n  total = 0;\n  return this;\n}\n\n```\n5、使用 // TODO: 标注问题的解决方式。\n\n```\nfunction Calculator() {\n  // TODO: total should be configurable by an options param\n  this.total = 0;\n  return this;\n}\n```\n### 空白\n1、使用 2 个空格作为缩进。\n\n```\n// bad\nfunction () {\n∙∙∙∙var name;\n}\n// bad\nfunction () {\n∙var name;\n}\n// good\nfunction () {\n∙∙var name;\n}\n```\n2、在大括号前放一个空格。\n\n```\n// bad\nfunction test(){\n  console.log('test');\n}\n// good\nfunction test() {\n  console.log('test');\n}\n// bad\ndog.set('attr',{\n  age: '1 year',\n  breed: 'Bernese Mountain Dog'\n});\n// good\ndog.set('attr', {\n  age: '1 year',\n  breed: 'Bernese Mountain Dog'\n});\n```\n3、在控制语句（if、while 等）的小括号前放一个空格。在函数调用及声明中，不在函数的参数列表前加空格。\n\n```\n// bad\nif(isJedi) {\n  fight ();\n}\n// good\nif (isJedi) {\n  fight();\n}\n// bad\nfunction fight () {\n  console.log ('Swooosh!');\n}\n// good\nfunction fight() {\n  console.log('Swooosh!');\n}\n```\n4、使用空格把运算符隔开。\n\n```\n// bad\nvar x=y+5;\n// good\nvar x = y + 5;\n```\n5、在文件末尾插入一个空行。\n\n```\n// bad\n(function (global) {\n  // ...stuff...\n})(this);\n```\n```\n// bad\n(function (global) {\n  // ...stuff...\n})(this);↵\n↵\n```\n```\n// good\n(function (global) {\n  // ...stuff...\n})(this);↵\n```\n6、在使用长方法链时进行缩进。使用前面的点 . 强调这是方法调用而不是新语句。\n\n```\n// bad\n$('#items').find('.selected').highlight().end().find('.open').updateCount();\n// bad\n$('#items').\n  find('.selected').\n    highlight().\n    end().\n  find('.open').\n    updateCount();\n// good\n$('#items')\n  .find('.selected')\n    .highlight()\n    .end()\n  .find('.open')\n    .updateCount();\n// bad\nvar leds = stage.selectAll('.led').data(data).enter().append('svg:svg').classed('led', true)\n    .attr('width', (radius + margin) * 2).append('svg:g')\n    .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')')\n    .call(tron.led);\n// good\nvar leds = stage.selectAll('.led')\n    .data(data)\n  .enter().append('svg:svg')\n    .classed('led', true)\n    .attr('width', (radius + margin) * 2)\n  .append('svg:g')\n    .attr('transform', 'translate(' + (radius + margin) + ',' + (radius + margin) + ')')\n    .call(tron.led);\n```\n7、在块末和新语句前插入空行。\n\n```\n// bad\nif (foo) {\n  return bar;\n}\nreturn baz;\n// good\nif (foo) {\n  return bar;\n}\nreturn baz;\n// bad\nvar obj = {\n  foo: function () {\n  },\n  bar: function () {\n  }\n};\nreturn obj;\n// good\nvar obj = {\n  foo: function () {\n  },\n  bar: function () {\n  }\n};\nreturn obj;\n```\n### 分号\n1、使用分号。\n\n```\n// bad\n(function () {\n  var name = 'Skywalker'\n  return name\n})()\n// good\n(function () {\n  var name = 'Skywalker';\n  return name;\n})();\n// good (防止函数在两个 IIFE 合并时被当成一个参数\n;(function () {\n  var name = 'Skywalker';\n  return name;\n})();\n```\n### 类型转换\n1、在语句开始时执行类型转换。\n2、字符串：\n\n```\n//  => this.reviewScore = 9;\n// bad\nvar totalScore = this.reviewScore + '';\n// good\nvar totalScore = '' + this.reviewScore;\n// bad\nvar totalScore = '' + this.reviewScore + ' total score';\n// good\nvar totalScore = this.reviewScore + ' total score';\n```\n3、使用 parseInt 转换数字时总是带上类型转换的基数。\n\n```\nvar inputValue = '4';\n// bad\nvar val = new Number(inputValue);\n// bad\nvar val = +inputValue;\n// bad\nvar val = inputValue >> 0;\n// bad\nvar val = parseInt(inputValue);\n// good\nvar val = Number(inputValue);\n// good\nvar val = parseInt(inputValue, 10);\n```\n4、如果因为某些原因 parseInt 成为你所做的事的瓶颈而需要使用位操作解决性能问题时，留个注释说清楚原因和你的目的。\n\n```\n// good\n/**\n * parseInt was the reason my code was slow.\n * Bitshifting the String to coerce it to a\n * Number made it a lot faster.\n */\nvar val = inputValue >> 0;\n```\n5、布尔:\n\n```\nvar age = 0;\n// bad\nvar hasAge = new Boolean(age);\n// good\nvar hasAge = Boolean(age);\n// good\nvar hasAge = !!age;\n```\n### 命名规则\n1、避免单字母命名。命名应具备描述性。\n\n```\n// bad\nfunction q() {\n  // ...stuff...\n}\n// good\nfunction query() {\n  // ..stuff..\n```\n2、使用驼峰式命名对象、函数和实例。\n\n```\n// bad\nvar OBJEcttsssss = {};\nvar this_is_my_object = {};\nvar o = {};\nfunction c() {}\n// good\nvar thisIsMyObject = {};\nfunction thisIsMyFunction() {}\n```\n3、使用帕斯卡式命名构造函数或类。\n\n```\n// bad\nfunction user(options) {\n  this.name = options.name;\n}\nvar bad = new user({\n  name: 'nope'\n});\n// good\nfunction User(options) {\n  this.name = options.name;\n}\nvar good = new User({\n  name: 'yup'\n});\n```\n4、不要使用下划线前/后缀。\n为什么？JavaScript 并没有私有属性或私有方法的概念。虽然使用下划线是表示「私有」的一种共识，但实际上这些属性是完全公开的，它本身就是你公共接口的一部分。这种习惯或许会导致开发者错误的认为改动它不会造成破坏或者不需要去测试。长话短说：如果你想要某处为「私有」，它必须不能是显式提出的。\n\n```\n// bad\nthis.__firstName__ = 'Panda';\nthis.firstName_ = 'Panda';\nthis._firstName = 'Panda';\n// good\nthis.firstName = 'Panda';\n```\n5、不要保存 this 的引用。使用 Function#bind。\n\n```\n// bad\nfunction () {\n  var self = this;\n  return function () {\n    console.log(self);\n  };\n}\n// bad\nfunction () {\n  var that = this;\n  return function () {\n    console.log(that);\n  };\n}\n// bad\nfunction () {\n  var _this = this;\n  return function () {\n    console.log(_this);\n  };\n}\n// good\nfunction () {\n  return function () {\n    console.log(this);\n  }.bind(this);\n}\n```\n6、如果你的文件导出一个类，你的文件名应该与类名完全相同。\n\n```\n// file contents\nclass CheckBox {\n  // ...\n}\nmodule.exports = CheckBox;\n// in some other file\n// bad\nvar CheckBox = require('./checkBox');\n// bad\nvar CheckBox = require('./check_box');\n// good\nvar CheckBox = require('./CheckBox');\n```\n### 模块\n1、模块应该以 ! 开始。这样确保了当一个不好的模块忘记包含最后的分号时，在合并代码到生产环境后不会产生错误\n2、文件应该以驼峰式命名，并放在同名的文件夹里，且与导出的名字一致。\n3、增加一个名为 noConflict() 的方法来设置导出的模块为前一个版本并返回它。\n4、永远在模块顶部声明 'use strict';。\n\n```\n// fancyInput/fancyInput.js\n!function (global) {\n  'use strict';\n  var previousFancyInput = global.FancyInput;\n  function FancyInput(options) {\n    this.options = options || {};\n  }\n  FancyInput.noConflict = function noConflict() {\n    global.FancyInput = previousFancyInput;\n    return FancyInput;\n  };\n  global.FancyInput = FancyInput;\n}(this);\n```\n参考链接：https://github.com/sivan/javascript-style-guide/blob/master/es5/README.md\n\n\n","slug":"guide","published":1,"updated":"2018-08-28T10:16:48.575Z","_id":"cjldh03qz0004uv6xqenai4ik","comments":1,"layout":"post","link":"","content":"<p>本文主要记录一些javascript优秀的写法，自己又老是不习惯使用的，方便日后养成习惯。</p>\n<a id=\"more\"></a>\n<h2 id=\"JavaScript-guide-es5\"><a href=\"#JavaScript-guide-es5\" class=\"headerlink\" title=\"JavaScript guide es5\"></a>JavaScript guide es5</h2><h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>1、当你需要拷贝数组时，使用 Array#slice。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var len = items.length;</span><br><span class=\"line\">var itemsCopy = [];</span><br><span class=\"line\">var i;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">for (i = 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">  itemsCopy[i] = items[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// good</span><br><span class=\"line\">itemsCopy = items.slice();</span><br></pre></td></tr></table></figure>\n<p>2、使用 Array#slice 将类数组对象转换成数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function trigger() &#123;</span><br><span class=\"line\">  var args = Array.prototype.slice.call(arguments);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>1、使用单引号 <code>&#39;&#39;</code> 包裹字符串。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">var name = &quot;Bob Parr&quot;;</span><br><span class=\"line\">// good</span><br><span class=\"line\">var name = &apos;Bob Parr&apos;;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">var fullName = &quot;Bob &quot; + this.lastName;</span><br><span class=\"line\">// good</span><br><span class=\"line\">var fullName = &apos;Bob &apos; + this.lastName;</span><br></pre></td></tr></table></figure>\n<p>2、超过 100 个字符的字符串应该使用连接符写成多行。<br>3、注：若过度使用，通过连接符连接的长字符串可能会影响性能。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">var errorMessage = &apos;This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.&apos;;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">var errorMessage = &apos;This is a super long error that was thrown because \\</span><br><span class=\"line\">of Batman. When you stop to think about how Batman had anything to do \\</span><br><span class=\"line\">with this, you would get nowhere \\</span><br><span class=\"line\">fast.&apos;;</span><br><span class=\"line\">// good</span><br><span class=\"line\">var errorMessage = &apos;This is a super long error that was thrown because &apos; +</span><br><span class=\"line\">  &apos;of Batman. When you stop to think about how Batman had anything to do &apos; +</span><br><span class=\"line\">  &apos;with this, you would get nowhere fast.&apos;;</span><br></pre></td></tr></table></figure>\n<p>4、程序化生成的字符串使用 Array#join 连接而不是使用连接符。尤其是 IE 下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var items;</span><br><span class=\"line\">var messages;</span><br><span class=\"line\">var length;</span><br><span class=\"line\">var i;</span><br><span class=\"line\">messages = [&#123;</span><br><span class=\"line\">  state: &apos;success&apos;,</span><br><span class=\"line\">  message: &apos;This one worked.&apos;</span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">  state: &apos;success&apos;,</span><br><span class=\"line\">  message: &apos;This one worked as well.&apos;</span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">  state: &apos;error&apos;,</span><br><span class=\"line\">  message: &apos;This one did not work.&apos;</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\">length = messages.length;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">function inbox(messages) &#123;</span><br><span class=\"line\">  items = &apos;&lt;ul&gt;&apos;;</span><br><span class=\"line\">  for (i = 0; i &lt; length; i++) &#123;</span><br><span class=\"line\">    items += &apos;&lt;li&gt;&apos; + messages[i].message + &apos;&lt;/li&gt;&apos;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return items + &apos;&lt;/ul&gt;&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// good</span><br><span class=\"line\">function inbox(messages) &#123;</span><br><span class=\"line\">  items = [];</span><br><span class=\"line\">  for (i = 0; i &lt; length; i++) &#123;</span><br><span class=\"line\">    // use direct assignment in this case because we&apos;re micro-optimizing.</span><br><span class=\"line\">    items[i] = &apos;&lt;li&gt;&apos; + messages[i].message + &apos;&lt;/li&gt;&apos;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return &apos;&lt;ul&gt;&apos; + items.join(&apos;&apos;) + &apos;&lt;/ul&gt;&apos;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><p>1、函数表达式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 匿名函数表达式</span><br><span class=\"line\">var anonymous = function() &#123;</span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">// 命名函数表达式</span><br><span class=\"line\">var named = function named() &#123;</span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">// 立即调用的函数表达式（IIFE）</span><br><span class=\"line\">(function () &#123;</span><br><span class=\"line\">  console.log(&apos;Welcome to the Internet. Please follow me.&apos;);</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<p>2、永远不要在一个非函数代码块（if、while 等）中声明一个函数，浏览器允许你这么做，但它们的解析表现不一致，正确的做法是：在块外定义一个变量，然后将函数赋值给它。</p>\n<p>3、注： ECMA-262 把 块 定义为一组语句。函数声明不是语句。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">if (currentUser) &#123;</span><br><span class=\"line\">  function test() &#123;</span><br><span class=\"line\">    console.log(&apos;Nope.&apos;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// good</span><br><span class=\"line\">var test;</span><br><span class=\"line\">if (currentUser) &#123;</span><br><span class=\"line\">  test = function test() &#123;</span><br><span class=\"line\">    console.log(&apos;Yup.&apos;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>4、永远不要把参数命名为 arguments。这将取代函数作用域内的 arguments 对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">function nope(name, options, arguments) &#123;</span><br><span class=\"line\">  // ...stuff...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// good</span><br><span class=\"line\">function yup(name, options, args) &#123;</span><br><span class=\"line\">  // ...stuff...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><p>1、使用 var 声明每一个变量。<br>这样做的好处是增加新变量将变的更加容易，而且你永远不用再担心调换错 ; 跟 ,。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">var items = getItems(),</span><br><span class=\"line\">    goSportsTeam = true,</span><br><span class=\"line\">    dragonball = &apos;z&apos;;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">// （跟上面的代码比较一下，看看哪里错了）</span><br><span class=\"line\">var items = getItems(),</span><br><span class=\"line\">    goSportsTeam = true;</span><br><span class=\"line\">    dragonball = &apos;z&apos;;</span><br><span class=\"line\">// good</span><br><span class=\"line\">var items = getItems();</span><br><span class=\"line\">var goSportsTeam = true;</span><br><span class=\"line\">var dragonball = &apos;z&apos;;</span><br></pre></td></tr></table></figure>\n<p>2、最后再声明未赋值的变量。当你需要引用前面的变量赋值时这将变的很有用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">var i, len, dragonball,</span><br><span class=\"line\">    items = getItems(),</span><br><span class=\"line\">    goSportsTeam = true;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">var i;</span><br><span class=\"line\">var items = getItems();</span><br><span class=\"line\">var dragonball;</span><br><span class=\"line\">var goSportsTeam = true;</span><br><span class=\"line\">var len;</span><br><span class=\"line\">// good</span><br><span class=\"line\">var items = getItems();</span><br><span class=\"line\">var goSportsTeam = true;</span><br><span class=\"line\">var dragonball;</span><br><span class=\"line\">var length;</span><br><span class=\"line\">var i;</span><br></pre></td></tr></table></figure>\n<p>3、在作用域顶部声明变量。这将帮你避免变量声明提升相关的问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">function () &#123;</span><br><span class=\"line\">  test();</span><br><span class=\"line\">  console.log(&apos;doing stuff..&apos;);</span><br><span class=\"line\">  //..other stuff..</span><br><span class=\"line\">  var name = getName();</span><br><span class=\"line\">  if (name === &apos;test&apos;) &#123;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// good</span><br><span class=\"line\">function () &#123;</span><br><span class=\"line\">  var name = getName();</span><br><span class=\"line\">  test();</span><br><span class=\"line\">  console.log(&apos;doing stuff..&apos;);</span><br><span class=\"line\">  //..other stuff..</span><br><span class=\"line\">  if (name === &apos;test&apos;) &#123;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// bad - 不必要的函数调用</span><br><span class=\"line\">function () &#123;</span><br><span class=\"line\">  var name = getName();</span><br><span class=\"line\">  if (!arguments.length) &#123;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  this.setFirstName(name);</span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// good</span><br><span class=\"line\">function () &#123;</span><br><span class=\"line\">  var name;</span><br><span class=\"line\">  if (!arguments.length) &#123;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  name = getName();</span><br><span class=\"line\">  this.setFirstName(name);</span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"比较运算符-amp-等号\"><a href=\"#比较运算符-amp-等号\" class=\"headerlink\" title=\"比较运算符 &amp; 等号\"></a>比较运算符 &amp; 等号</h3><p>1、优先使用 === 和 !== 而不是 == 和 !=.<br>2、条件表达式例如 if 语句通过抽象方法 ToBoolean 强制计算它们的表达式并且总是遵守下面的规则：<br>对象 被计算为 true<br>Undefined 被计算为 false<br>Null 被计算为 false<br>布尔值 被计算为 布尔的值<br>数字 如果是 +0、-0 或 NaN 被计算为 false，否则为 true<br>字符串 如果是空字符串 ‘’ 被计算为 false，否则为 true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">if ([0]) &#123;</span><br><span class=\"line\">  // true</span><br><span class=\"line\">  // 一个数组就是一个对象，对象被计算为 true</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3、使用快捷方式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">if (name !== &apos;&apos;) &#123;</span><br><span class=\"line\">  // ...stuff...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// good</span><br><span class=\"line\">if (name) &#123;</span><br><span class=\"line\">  // ...stuff...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">if (collection.length &gt; 0) &#123;</span><br><span class=\"line\">  // ...stuff...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// good</span><br><span class=\"line\">if (collection.length) &#123;</span><br><span class=\"line\">  // ...stuff...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"块\"><a href=\"#块\" class=\"headerlink\" title=\"块\"></a>块</h3><p>1、使用大括号包裹所有的多行代码块。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">if (test)</span><br><span class=\"line\">  return false;</span><br><span class=\"line\">// good</span><br><span class=\"line\">if (test) return false;</span><br><span class=\"line\">// good</span><br><span class=\"line\">if (test) &#123;</span><br><span class=\"line\">  return false;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">function () &#123; return false; &#125;</span><br><span class=\"line\">// good</span><br><span class=\"line\">function () &#123;</span><br><span class=\"line\">  return false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><p>1、使用 /*<em> … </em>/ 作为多行注释。包含描述、指定所有参数和返回值的类型和值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">// make() returns a new element</span><br><span class=\"line\">// based on the passed in tag name</span><br><span class=\"line\">//</span><br><span class=\"line\">// @param &#123;String&#125; tag</span><br><span class=\"line\">// @return &#123;Element&#125; element</span><br><span class=\"line\">function make(tag) &#123;</span><br><span class=\"line\">  // ...stuff...</span><br><span class=\"line\">  return element;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// good</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * make() returns a new element</span><br><span class=\"line\"> * based on the passed in tag name</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param &#123;String&#125; tag</span><br><span class=\"line\"> * @return &#123;Element&#125; element</span><br><span class=\"line\"> */</span><br><span class=\"line\">function make(tag) &#123;</span><br><span class=\"line\">  // ...stuff...</span><br><span class=\"line\">  return element;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2、使用 // 作为单行注释。在评论对象上面另起一行使用单行注释。在注释前插入空行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">var active = true;  // is current tab</span><br><span class=\"line\">// good</span><br><span class=\"line\">// is current tab</span><br><span class=\"line\">var active = true;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">function getType() &#123;</span><br><span class=\"line\">  console.log(&apos;fetching type...&apos;);</span><br><span class=\"line\">  // set the default type to &apos;no type&apos;</span><br><span class=\"line\">  var type = this.type || &apos;no type&apos;;</span><br><span class=\"line\">  return type;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// good</span><br><span class=\"line\">function getType() &#123;</span><br><span class=\"line\">  console.log(&apos;fetching type...&apos;);</span><br><span class=\"line\">  // set the default type to &apos;no type&apos;</span><br><span class=\"line\">  var type = this.type || &apos;no type&apos;;</span><br><span class=\"line\">  return type;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3、给注释增加 FIXME 或 TODO 的前缀可以帮助其他开发者快速了解这是一个需要复查的问题，或是给需要实现的功能提供一个解决方式。这将有别于常见的注释，因为它们是可操作的。使用 FIXME – need to figure this out 或者 TODO – need to implement。</p>\n<p>4、使用 // FIXME: 标注问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function Calculator() &#123;</span><br><span class=\"line\">  // FIXME: shouldn&apos;t use a global here</span><br><span class=\"line\">  total = 0;</span><br><span class=\"line\">  return this;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>5、使用 // TODO: 标注问题的解决方式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function Calculator() &#123;</span><br><span class=\"line\">  // TODO: total should be configurable by an options param</span><br><span class=\"line\">  this.total = 0;</span><br><span class=\"line\">  return this;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"空白\"><a href=\"#空白\" class=\"headerlink\" title=\"空白\"></a>空白</h3><p>1、使用 2 个空格作为缩进。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">function () &#123;</span><br><span class=\"line\">∙∙∙∙var name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">function () &#123;</span><br><span class=\"line\">∙var name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// good</span><br><span class=\"line\">function () &#123;</span><br><span class=\"line\">∙∙var name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2、在大括号前放一个空格。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">function test()&#123;</span><br><span class=\"line\">  console.log(&apos;test&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// good</span><br><span class=\"line\">function test() &#123;</span><br><span class=\"line\">  console.log(&apos;test&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">dog.set(&apos;attr&apos;,&#123;</span><br><span class=\"line\">  age: &apos;1 year&apos;,</span><br><span class=\"line\">  breed: &apos;Bernese Mountain Dog&apos;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// good</span><br><span class=\"line\">dog.set(&apos;attr&apos;, &#123;</span><br><span class=\"line\">  age: &apos;1 year&apos;,</span><br><span class=\"line\">  breed: &apos;Bernese Mountain Dog&apos;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>3、在控制语句（if、while 等）的小括号前放一个空格。在函数调用及声明中，不在函数的参数列表前加空格。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">if(isJedi) &#123;</span><br><span class=\"line\">  fight ();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// good</span><br><span class=\"line\">if (isJedi) &#123;</span><br><span class=\"line\">  fight();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">function fight () &#123;</span><br><span class=\"line\">  console.log (&apos;Swooosh!&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// good</span><br><span class=\"line\">function fight() &#123;</span><br><span class=\"line\">  console.log(&apos;Swooosh!&apos;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>4、使用空格把运算符隔开。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">var x=y+5;</span><br><span class=\"line\">// good</span><br><span class=\"line\">var x = y + 5;</span><br></pre></td></tr></table></figure>\n<p>5、在文件末尾插入一个空行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">(function (global) &#123;</span><br><span class=\"line\">  // ...stuff...</span><br><span class=\"line\">&#125;)(this);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">(function (global) &#123;</span><br><span class=\"line\">  // ...stuff...</span><br><span class=\"line\">&#125;)(this);↵</span><br><span class=\"line\">↵</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// good</span><br><span class=\"line\">(function (global) &#123;</span><br><span class=\"line\">  // ...stuff...</span><br><span class=\"line\">&#125;)(this);↵</span><br></pre></td></tr></table></figure>\n<p>6、在使用长方法链时进行缩进。使用前面的点 . 强调这是方法调用而不是新语句。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">$(&apos;#items&apos;).find(&apos;.selected&apos;).highlight().end().find(&apos;.open&apos;).updateCount();</span><br><span class=\"line\">// bad</span><br><span class=\"line\">$(&apos;#items&apos;).</span><br><span class=\"line\">  find(&apos;.selected&apos;).</span><br><span class=\"line\">    highlight().</span><br><span class=\"line\">    end().</span><br><span class=\"line\">  find(&apos;.open&apos;).</span><br><span class=\"line\">    updateCount();</span><br><span class=\"line\">// good</span><br><span class=\"line\">$(&apos;#items&apos;)</span><br><span class=\"line\">  .find(&apos;.selected&apos;)</span><br><span class=\"line\">    .highlight()</span><br><span class=\"line\">    .end()</span><br><span class=\"line\">  .find(&apos;.open&apos;)</span><br><span class=\"line\">    .updateCount();</span><br><span class=\"line\">// bad</span><br><span class=\"line\">var leds = stage.selectAll(&apos;.led&apos;).data(data).enter().append(&apos;svg:svg&apos;).classed(&apos;led&apos;, true)</span><br><span class=\"line\">    .attr(&apos;width&apos;, (radius + margin) * 2).append(&apos;svg:g&apos;)</span><br><span class=\"line\">    .attr(&apos;transform&apos;, &apos;translate(&apos; + (radius + margin) + &apos;,&apos; + (radius + margin) + &apos;)&apos;)</span><br><span class=\"line\">    .call(tron.led);</span><br><span class=\"line\">// good</span><br><span class=\"line\">var leds = stage.selectAll(&apos;.led&apos;)</span><br><span class=\"line\">    .data(data)</span><br><span class=\"line\">  .enter().append(&apos;svg:svg&apos;)</span><br><span class=\"line\">    .classed(&apos;led&apos;, true)</span><br><span class=\"line\">    .attr(&apos;width&apos;, (radius + margin) * 2)</span><br><span class=\"line\">  .append(&apos;svg:g&apos;)</span><br><span class=\"line\">    .attr(&apos;transform&apos;, &apos;translate(&apos; + (radius + margin) + &apos;,&apos; + (radius + margin) + &apos;)&apos;)</span><br><span class=\"line\">    .call(tron.led);</span><br></pre></td></tr></table></figure>\n<p>7、在块末和新语句前插入空行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">if (foo) &#123;</span><br><span class=\"line\">  return bar;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return baz;</span><br><span class=\"line\">// good</span><br><span class=\"line\">if (foo) &#123;</span><br><span class=\"line\">  return bar;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return baz;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">  foo: function () &#123;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  bar: function () &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">return obj;</span><br><span class=\"line\">// good</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">  foo: function () &#123;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  bar: function () &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">return obj;</span><br></pre></td></tr></table></figure>\n<h3 id=\"分号\"><a href=\"#分号\" class=\"headerlink\" title=\"分号\"></a>分号</h3><p>1、使用分号。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">(function () &#123;</span><br><span class=\"line\">  var name = &apos;Skywalker&apos;</span><br><span class=\"line\">  return name</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\">// good</span><br><span class=\"line\">(function () &#123;</span><br><span class=\"line\">  var name = &apos;Skywalker&apos;;</span><br><span class=\"line\">  return name;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">// good (防止函数在两个 IIFE 合并时被当成一个参数</span><br><span class=\"line\">;(function () &#123;</span><br><span class=\"line\">  var name = &apos;Skywalker&apos;;</span><br><span class=\"line\">  return name;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><p>1、在语句开始时执行类型转换。<br>2、字符串：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//  =&gt; this.reviewScore = 9;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">var totalScore = this.reviewScore + &apos;&apos;;</span><br><span class=\"line\">// good</span><br><span class=\"line\">var totalScore = &apos;&apos; + this.reviewScore;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">var totalScore = &apos;&apos; + this.reviewScore + &apos; total score&apos;;</span><br><span class=\"line\">// good</span><br><span class=\"line\">var totalScore = this.reviewScore + &apos; total score&apos;;</span><br></pre></td></tr></table></figure>\n<p>3、使用 parseInt 转换数字时总是带上类型转换的基数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var inputValue = &apos;4&apos;;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">var val = new Number(inputValue);</span><br><span class=\"line\">// bad</span><br><span class=\"line\">var val = +inputValue;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">var val = inputValue &gt;&gt; 0;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">var val = parseInt(inputValue);</span><br><span class=\"line\">// good</span><br><span class=\"line\">var val = Number(inputValue);</span><br><span class=\"line\">// good</span><br><span class=\"line\">var val = parseInt(inputValue, 10);</span><br></pre></td></tr></table></figure>\n<p>4、如果因为某些原因 parseInt 成为你所做的事的瓶颈而需要使用位操作解决性能问题时，留个注释说清楚原因和你的目的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// good</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * parseInt was the reason my code was slow.</span><br><span class=\"line\"> * Bitshifting the String to coerce it to a</span><br><span class=\"line\"> * Number made it a lot faster.</span><br><span class=\"line\"> */</span><br><span class=\"line\">var val = inputValue &gt;&gt; 0;</span><br></pre></td></tr></table></figure>\n<p>5、布尔:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var age = 0;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">var hasAge = new Boolean(age);</span><br><span class=\"line\">// good</span><br><span class=\"line\">var hasAge = Boolean(age);</span><br><span class=\"line\">// good</span><br><span class=\"line\">var hasAge = !!age;</span><br></pre></td></tr></table></figure>\n<h3 id=\"命名规则\"><a href=\"#命名规则\" class=\"headerlink\" title=\"命名规则\"></a>命名规则</h3><p>1、避免单字母命名。命名应具备描述性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">function q() &#123;</span><br><span class=\"line\">  // ...stuff...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// good</span><br><span class=\"line\">function query() &#123;</span><br><span class=\"line\">  // ..stuff..</span><br></pre></td></tr></table></figure>\n<p>2、使用驼峰式命名对象、函数和实例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">var OBJEcttsssss = &#123;&#125;;</span><br><span class=\"line\">var this_is_my_object = &#123;&#125;;</span><br><span class=\"line\">var o = &#123;&#125;;</span><br><span class=\"line\">function c() &#123;&#125;</span><br><span class=\"line\">// good</span><br><span class=\"line\">var thisIsMyObject = &#123;&#125;;</span><br><span class=\"line\">function thisIsMyFunction() &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>3、使用帕斯卡式命名构造函数或类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">function user(options) &#123;</span><br><span class=\"line\">  this.name = options.name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var bad = new user(&#123;</span><br><span class=\"line\">  name: &apos;nope&apos;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// good</span><br><span class=\"line\">function User(options) &#123;</span><br><span class=\"line\">  this.name = options.name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var good = new User(&#123;</span><br><span class=\"line\">  name: &apos;yup&apos;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>4、不要使用下划线前/后缀。<br>为什么？JavaScript 并没有私有属性或私有方法的概念。虽然使用下划线是表示「私有」的一种共识，但实际上这些属性是完全公开的，它本身就是你公共接口的一部分。这种习惯或许会导致开发者错误的认为改动它不会造成破坏或者不需要去测试。长话短说：如果你想要某处为「私有」，它必须不能是显式提出的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">this.__firstName__ = &apos;Panda&apos;;</span><br><span class=\"line\">this.firstName_ = &apos;Panda&apos;;</span><br><span class=\"line\">this._firstName = &apos;Panda&apos;;</span><br><span class=\"line\">// good</span><br><span class=\"line\">this.firstName = &apos;Panda&apos;;</span><br></pre></td></tr></table></figure>\n<p>5、不要保存 this 的引用。使用 Function#bind。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">function () &#123;</span><br><span class=\"line\">  var self = this;</span><br><span class=\"line\">  return function () &#123;</span><br><span class=\"line\">    console.log(self);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">function () &#123;</span><br><span class=\"line\">  var that = this;</span><br><span class=\"line\">  return function () &#123;</span><br><span class=\"line\">    console.log(that);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">function () &#123;</span><br><span class=\"line\">  var _this = this;</span><br><span class=\"line\">  return function () &#123;</span><br><span class=\"line\">    console.log(_this);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// good</span><br><span class=\"line\">function () &#123;</span><br><span class=\"line\">  return function () &#123;</span><br><span class=\"line\">    console.log(this);</span><br><span class=\"line\">  &#125;.bind(this);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>6、如果你的文件导出一个类，你的文件名应该与类名完全相同。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// file contents</span><br><span class=\"line\">class CheckBox &#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports = CheckBox;</span><br><span class=\"line\">// in some other file</span><br><span class=\"line\">// bad</span><br><span class=\"line\">var CheckBox = require(&apos;./checkBox&apos;);</span><br><span class=\"line\">// bad</span><br><span class=\"line\">var CheckBox = require(&apos;./check_box&apos;);</span><br><span class=\"line\">// good</span><br><span class=\"line\">var CheckBox = require(&apos;./CheckBox&apos;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h3><p>1、模块应该以 ! 开始。这样确保了当一个不好的模块忘记包含最后的分号时，在合并代码到生产环境后不会产生错误<br>2、文件应该以驼峰式命名，并放在同名的文件夹里，且与导出的名字一致。<br>3、增加一个名为 noConflict() 的方法来设置导出的模块为前一个版本并返回它。<br>4、永远在模块顶部声明 ‘use strict’;。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// fancyInput/fancyInput.js</span><br><span class=\"line\">!function (global) &#123;</span><br><span class=\"line\">  &apos;use strict&apos;;</span><br><span class=\"line\">  var previousFancyInput = global.FancyInput;</span><br><span class=\"line\">  function FancyInput(options) &#123;</span><br><span class=\"line\">    this.options = options || &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  FancyInput.noConflict = function noConflict() &#123;</span><br><span class=\"line\">    global.FancyInput = previousFancyInput;</span><br><span class=\"line\">    return FancyInput;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  global.FancyInput = FancyInput;</span><br><span class=\"line\">&#125;(this);</span><br></pre></td></tr></table></figure>\n<p>参考链接：<a href=\"https://github.com/sivan/javascript-style-guide/blob/master/es5/README.md\" target=\"_blank\" rel=\"noopener\">https://github.com/sivan/javascript-style-guide/blob/master/es5/README.md</a></p>\n","site":{"data":{}},"excerpt":"<p>本文主要记录一些javascript优秀的写法，自己又老是不习惯使用的，方便日后养成习惯。</p>","more":"<h2 id=\"JavaScript-guide-es5\"><a href=\"#JavaScript-guide-es5\" class=\"headerlink\" title=\"JavaScript guide es5\"></a>JavaScript guide es5</h2><h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>1、当你需要拷贝数组时，使用 Array#slice。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var len = items.length;</span><br><span class=\"line\">var itemsCopy = [];</span><br><span class=\"line\">var i;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">for (i = 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">  itemsCopy[i] = items[i];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// good</span><br><span class=\"line\">itemsCopy = items.slice();</span><br></pre></td></tr></table></figure>\n<p>2、使用 Array#slice 将类数组对象转换成数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function trigger() &#123;</span><br><span class=\"line\">  var args = Array.prototype.slice.call(arguments);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>1、使用单引号 <code>&#39;&#39;</code> 包裹字符串。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">var name = &quot;Bob Parr&quot;;</span><br><span class=\"line\">// good</span><br><span class=\"line\">var name = &apos;Bob Parr&apos;;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">var fullName = &quot;Bob &quot; + this.lastName;</span><br><span class=\"line\">// good</span><br><span class=\"line\">var fullName = &apos;Bob &apos; + this.lastName;</span><br></pre></td></tr></table></figure>\n<p>2、超过 100 个字符的字符串应该使用连接符写成多行。<br>3、注：若过度使用，通过连接符连接的长字符串可能会影响性能。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">var errorMessage = &apos;This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.&apos;;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">var errorMessage = &apos;This is a super long error that was thrown because \\</span><br><span class=\"line\">of Batman. When you stop to think about how Batman had anything to do \\</span><br><span class=\"line\">with this, you would get nowhere \\</span><br><span class=\"line\">fast.&apos;;</span><br><span class=\"line\">// good</span><br><span class=\"line\">var errorMessage = &apos;This is a super long error that was thrown because &apos; +</span><br><span class=\"line\">  &apos;of Batman. When you stop to think about how Batman had anything to do &apos; +</span><br><span class=\"line\">  &apos;with this, you would get nowhere fast.&apos;;</span><br></pre></td></tr></table></figure>\n<p>4、程序化生成的字符串使用 Array#join 连接而不是使用连接符。尤其是 IE 下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var items;</span><br><span class=\"line\">var messages;</span><br><span class=\"line\">var length;</span><br><span class=\"line\">var i;</span><br><span class=\"line\">messages = [&#123;</span><br><span class=\"line\">  state: &apos;success&apos;,</span><br><span class=\"line\">  message: &apos;This one worked.&apos;</span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">  state: &apos;success&apos;,</span><br><span class=\"line\">  message: &apos;This one worked as well.&apos;</span><br><span class=\"line\">&#125;, &#123;</span><br><span class=\"line\">  state: &apos;error&apos;,</span><br><span class=\"line\">  message: &apos;This one did not work.&apos;</span><br><span class=\"line\">&#125;];</span><br><span class=\"line\">length = messages.length;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">function inbox(messages) &#123;</span><br><span class=\"line\">  items = &apos;&lt;ul&gt;&apos;;</span><br><span class=\"line\">  for (i = 0; i &lt; length; i++) &#123;</span><br><span class=\"line\">    items += &apos;&lt;li&gt;&apos; + messages[i].message + &apos;&lt;/li&gt;&apos;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return items + &apos;&lt;/ul&gt;&apos;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// good</span><br><span class=\"line\">function inbox(messages) &#123;</span><br><span class=\"line\">  items = [];</span><br><span class=\"line\">  for (i = 0; i &lt; length; i++) &#123;</span><br><span class=\"line\">    // use direct assignment in this case because we&apos;re micro-optimizing.</span><br><span class=\"line\">    items[i] = &apos;&lt;li&gt;&apos; + messages[i].message + &apos;&lt;/li&gt;&apos;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return &apos;&lt;ul&gt;&apos; + items.join(&apos;&apos;) + &apos;&lt;/ul&gt;&apos;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h3><p>1、函数表达式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 匿名函数表达式</span><br><span class=\"line\">var anonymous = function() &#123;</span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">// 命名函数表达式</span><br><span class=\"line\">var named = function named() &#123;</span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">// 立即调用的函数表达式（IIFE）</span><br><span class=\"line\">(function () &#123;</span><br><span class=\"line\">  console.log(&apos;Welcome to the Internet. Please follow me.&apos;);</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<p>2、永远不要在一个非函数代码块（if、while 等）中声明一个函数，浏览器允许你这么做，但它们的解析表现不一致，正确的做法是：在块外定义一个变量，然后将函数赋值给它。</p>\n<p>3、注： ECMA-262 把 块 定义为一组语句。函数声明不是语句。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">if (currentUser) &#123;</span><br><span class=\"line\">  function test() &#123;</span><br><span class=\"line\">    console.log(&apos;Nope.&apos;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// good</span><br><span class=\"line\">var test;</span><br><span class=\"line\">if (currentUser) &#123;</span><br><span class=\"line\">  test = function test() &#123;</span><br><span class=\"line\">    console.log(&apos;Yup.&apos;);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>4、永远不要把参数命名为 arguments。这将取代函数作用域内的 arguments 对象。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">function nope(name, options, arguments) &#123;</span><br><span class=\"line\">  // ...stuff...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// good</span><br><span class=\"line\">function yup(name, options, args) &#123;</span><br><span class=\"line\">  // ...stuff...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><p>1、使用 var 声明每一个变量。<br>这样做的好处是增加新变量将变的更加容易，而且你永远不用再担心调换错 ; 跟 ,。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">var items = getItems(),</span><br><span class=\"line\">    goSportsTeam = true,</span><br><span class=\"line\">    dragonball = &apos;z&apos;;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">// （跟上面的代码比较一下，看看哪里错了）</span><br><span class=\"line\">var items = getItems(),</span><br><span class=\"line\">    goSportsTeam = true;</span><br><span class=\"line\">    dragonball = &apos;z&apos;;</span><br><span class=\"line\">// good</span><br><span class=\"line\">var items = getItems();</span><br><span class=\"line\">var goSportsTeam = true;</span><br><span class=\"line\">var dragonball = &apos;z&apos;;</span><br></pre></td></tr></table></figure>\n<p>2、最后再声明未赋值的变量。当你需要引用前面的变量赋值时这将变的很有用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">var i, len, dragonball,</span><br><span class=\"line\">    items = getItems(),</span><br><span class=\"line\">    goSportsTeam = true;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">var i;</span><br><span class=\"line\">var items = getItems();</span><br><span class=\"line\">var dragonball;</span><br><span class=\"line\">var goSportsTeam = true;</span><br><span class=\"line\">var len;</span><br><span class=\"line\">// good</span><br><span class=\"line\">var items = getItems();</span><br><span class=\"line\">var goSportsTeam = true;</span><br><span class=\"line\">var dragonball;</span><br><span class=\"line\">var length;</span><br><span class=\"line\">var i;</span><br></pre></td></tr></table></figure>\n<p>3、在作用域顶部声明变量。这将帮你避免变量声明提升相关的问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">function () &#123;</span><br><span class=\"line\">  test();</span><br><span class=\"line\">  console.log(&apos;doing stuff..&apos;);</span><br><span class=\"line\">  //..other stuff..</span><br><span class=\"line\">  var name = getName();</span><br><span class=\"line\">  if (name === &apos;test&apos;) &#123;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// good</span><br><span class=\"line\">function () &#123;</span><br><span class=\"line\">  var name = getName();</span><br><span class=\"line\">  test();</span><br><span class=\"line\">  console.log(&apos;doing stuff..&apos;);</span><br><span class=\"line\">  //..other stuff..</span><br><span class=\"line\">  if (name === &apos;test&apos;) &#123;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// bad - 不必要的函数调用</span><br><span class=\"line\">function () &#123;</span><br><span class=\"line\">  var name = getName();</span><br><span class=\"line\">  if (!arguments.length) &#123;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  this.setFirstName(name);</span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// good</span><br><span class=\"line\">function () &#123;</span><br><span class=\"line\">  var name;</span><br><span class=\"line\">  if (!arguments.length) &#123;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  name = getName();</span><br><span class=\"line\">  this.setFirstName(name);</span><br><span class=\"line\">  return true;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"比较运算符-amp-等号\"><a href=\"#比较运算符-amp-等号\" class=\"headerlink\" title=\"比较运算符 &amp; 等号\"></a>比较运算符 &amp; 等号</h3><p>1、优先使用 === 和 !== 而不是 == 和 !=.<br>2、条件表达式例如 if 语句通过抽象方法 ToBoolean 强制计算它们的表达式并且总是遵守下面的规则：<br>对象 被计算为 true<br>Undefined 被计算为 false<br>Null 被计算为 false<br>布尔值 被计算为 布尔的值<br>数字 如果是 +0、-0 或 NaN 被计算为 false，否则为 true<br>字符串 如果是空字符串 ‘’ 被计算为 false，否则为 true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">if ([0]) &#123;</span><br><span class=\"line\">  // true</span><br><span class=\"line\">  // 一个数组就是一个对象，对象被计算为 true</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3、使用快捷方式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">if (name !== &apos;&apos;) &#123;</span><br><span class=\"line\">  // ...stuff...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// good</span><br><span class=\"line\">if (name) &#123;</span><br><span class=\"line\">  // ...stuff...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">if (collection.length &gt; 0) &#123;</span><br><span class=\"line\">  // ...stuff...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// good</span><br><span class=\"line\">if (collection.length) &#123;</span><br><span class=\"line\">  // ...stuff...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"块\"><a href=\"#块\" class=\"headerlink\" title=\"块\"></a>块</h3><p>1、使用大括号包裹所有的多行代码块。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">if (test)</span><br><span class=\"line\">  return false;</span><br><span class=\"line\">// good</span><br><span class=\"line\">if (test) return false;</span><br><span class=\"line\">// good</span><br><span class=\"line\">if (test) &#123;</span><br><span class=\"line\">  return false;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">function () &#123; return false; &#125;</span><br><span class=\"line\">// good</span><br><span class=\"line\">function () &#123;</span><br><span class=\"line\">  return false;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h3><p>1、使用 /*<em> … </em>/ 作为多行注释。包含描述、指定所有参数和返回值的类型和值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">// make() returns a new element</span><br><span class=\"line\">// based on the passed in tag name</span><br><span class=\"line\">//</span><br><span class=\"line\">// @param &#123;String&#125; tag</span><br><span class=\"line\">// @return &#123;Element&#125; element</span><br><span class=\"line\">function make(tag) &#123;</span><br><span class=\"line\">  // ...stuff...</span><br><span class=\"line\">  return element;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// good</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * make() returns a new element</span><br><span class=\"line\"> * based on the passed in tag name</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * @param &#123;String&#125; tag</span><br><span class=\"line\"> * @return &#123;Element&#125; element</span><br><span class=\"line\"> */</span><br><span class=\"line\">function make(tag) &#123;</span><br><span class=\"line\">  // ...stuff...</span><br><span class=\"line\">  return element;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2、使用 // 作为单行注释。在评论对象上面另起一行使用单行注释。在注释前插入空行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">var active = true;  // is current tab</span><br><span class=\"line\">// good</span><br><span class=\"line\">// is current tab</span><br><span class=\"line\">var active = true;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">function getType() &#123;</span><br><span class=\"line\">  console.log(&apos;fetching type...&apos;);</span><br><span class=\"line\">  // set the default type to &apos;no type&apos;</span><br><span class=\"line\">  var type = this.type || &apos;no type&apos;;</span><br><span class=\"line\">  return type;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// good</span><br><span class=\"line\">function getType() &#123;</span><br><span class=\"line\">  console.log(&apos;fetching type...&apos;);</span><br><span class=\"line\">  // set the default type to &apos;no type&apos;</span><br><span class=\"line\">  var type = this.type || &apos;no type&apos;;</span><br><span class=\"line\">  return type;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>3、给注释增加 FIXME 或 TODO 的前缀可以帮助其他开发者快速了解这是一个需要复查的问题，或是给需要实现的功能提供一个解决方式。这将有别于常见的注释，因为它们是可操作的。使用 FIXME – need to figure this out 或者 TODO – need to implement。</p>\n<p>4、使用 // FIXME: 标注问题。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function Calculator() &#123;</span><br><span class=\"line\">  // FIXME: shouldn&apos;t use a global here</span><br><span class=\"line\">  total = 0;</span><br><span class=\"line\">  return this;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>5、使用 // TODO: 标注问题的解决方式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function Calculator() &#123;</span><br><span class=\"line\">  // TODO: total should be configurable by an options param</span><br><span class=\"line\">  this.total = 0;</span><br><span class=\"line\">  return this;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"空白\"><a href=\"#空白\" class=\"headerlink\" title=\"空白\"></a>空白</h3><p>1、使用 2 个空格作为缩进。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">function () &#123;</span><br><span class=\"line\">∙∙∙∙var name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">function () &#123;</span><br><span class=\"line\">∙var name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// good</span><br><span class=\"line\">function () &#123;</span><br><span class=\"line\">∙∙var name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>2、在大括号前放一个空格。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">function test()&#123;</span><br><span class=\"line\">  console.log(&apos;test&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// good</span><br><span class=\"line\">function test() &#123;</span><br><span class=\"line\">  console.log(&apos;test&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">dog.set(&apos;attr&apos;,&#123;</span><br><span class=\"line\">  age: &apos;1 year&apos;,</span><br><span class=\"line\">  breed: &apos;Bernese Mountain Dog&apos;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// good</span><br><span class=\"line\">dog.set(&apos;attr&apos;, &#123;</span><br><span class=\"line\">  age: &apos;1 year&apos;,</span><br><span class=\"line\">  breed: &apos;Bernese Mountain Dog&apos;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>3、在控制语句（if、while 等）的小括号前放一个空格。在函数调用及声明中，不在函数的参数列表前加空格。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">if(isJedi) &#123;</span><br><span class=\"line\">  fight ();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// good</span><br><span class=\"line\">if (isJedi) &#123;</span><br><span class=\"line\">  fight();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">function fight () &#123;</span><br><span class=\"line\">  console.log (&apos;Swooosh!&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// good</span><br><span class=\"line\">function fight() &#123;</span><br><span class=\"line\">  console.log(&apos;Swooosh!&apos;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>4、使用空格把运算符隔开。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">var x=y+5;</span><br><span class=\"line\">// good</span><br><span class=\"line\">var x = y + 5;</span><br></pre></td></tr></table></figure>\n<p>5、在文件末尾插入一个空行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">(function (global) &#123;</span><br><span class=\"line\">  // ...stuff...</span><br><span class=\"line\">&#125;)(this);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">(function (global) &#123;</span><br><span class=\"line\">  // ...stuff...</span><br><span class=\"line\">&#125;)(this);↵</span><br><span class=\"line\">↵</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// good</span><br><span class=\"line\">(function (global) &#123;</span><br><span class=\"line\">  // ...stuff...</span><br><span class=\"line\">&#125;)(this);↵</span><br></pre></td></tr></table></figure>\n<p>6、在使用长方法链时进行缩进。使用前面的点 . 强调这是方法调用而不是新语句。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">$(&apos;#items&apos;).find(&apos;.selected&apos;).highlight().end().find(&apos;.open&apos;).updateCount();</span><br><span class=\"line\">// bad</span><br><span class=\"line\">$(&apos;#items&apos;).</span><br><span class=\"line\">  find(&apos;.selected&apos;).</span><br><span class=\"line\">    highlight().</span><br><span class=\"line\">    end().</span><br><span class=\"line\">  find(&apos;.open&apos;).</span><br><span class=\"line\">    updateCount();</span><br><span class=\"line\">// good</span><br><span class=\"line\">$(&apos;#items&apos;)</span><br><span class=\"line\">  .find(&apos;.selected&apos;)</span><br><span class=\"line\">    .highlight()</span><br><span class=\"line\">    .end()</span><br><span class=\"line\">  .find(&apos;.open&apos;)</span><br><span class=\"line\">    .updateCount();</span><br><span class=\"line\">// bad</span><br><span class=\"line\">var leds = stage.selectAll(&apos;.led&apos;).data(data).enter().append(&apos;svg:svg&apos;).classed(&apos;led&apos;, true)</span><br><span class=\"line\">    .attr(&apos;width&apos;, (radius + margin) * 2).append(&apos;svg:g&apos;)</span><br><span class=\"line\">    .attr(&apos;transform&apos;, &apos;translate(&apos; + (radius + margin) + &apos;,&apos; + (radius + margin) + &apos;)&apos;)</span><br><span class=\"line\">    .call(tron.led);</span><br><span class=\"line\">// good</span><br><span class=\"line\">var leds = stage.selectAll(&apos;.led&apos;)</span><br><span class=\"line\">    .data(data)</span><br><span class=\"line\">  .enter().append(&apos;svg:svg&apos;)</span><br><span class=\"line\">    .classed(&apos;led&apos;, true)</span><br><span class=\"line\">    .attr(&apos;width&apos;, (radius + margin) * 2)</span><br><span class=\"line\">  .append(&apos;svg:g&apos;)</span><br><span class=\"line\">    .attr(&apos;transform&apos;, &apos;translate(&apos; + (radius + margin) + &apos;,&apos; + (radius + margin) + &apos;)&apos;)</span><br><span class=\"line\">    .call(tron.led);</span><br></pre></td></tr></table></figure>\n<p>7、在块末和新语句前插入空行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">if (foo) &#123;</span><br><span class=\"line\">  return bar;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return baz;</span><br><span class=\"line\">// good</span><br><span class=\"line\">if (foo) &#123;</span><br><span class=\"line\">  return bar;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return baz;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">  foo: function () &#123;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  bar: function () &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">return obj;</span><br><span class=\"line\">// good</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">  foo: function () &#123;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  bar: function () &#123;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">return obj;</span><br></pre></td></tr></table></figure>\n<h3 id=\"分号\"><a href=\"#分号\" class=\"headerlink\" title=\"分号\"></a>分号</h3><p>1、使用分号。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">(function () &#123;</span><br><span class=\"line\">  var name = &apos;Skywalker&apos;</span><br><span class=\"line\">  return name</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\">// good</span><br><span class=\"line\">(function () &#123;</span><br><span class=\"line\">  var name = &apos;Skywalker&apos;;</span><br><span class=\"line\">  return name;</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">// good (防止函数在两个 IIFE 合并时被当成一个参数</span><br><span class=\"line\">;(function () &#123;</span><br><span class=\"line\">  var name = &apos;Skywalker&apos;;</span><br><span class=\"line\">  return name;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><p>1、在语句开始时执行类型转换。<br>2、字符串：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//  =&gt; this.reviewScore = 9;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">var totalScore = this.reviewScore + &apos;&apos;;</span><br><span class=\"line\">// good</span><br><span class=\"line\">var totalScore = &apos;&apos; + this.reviewScore;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">var totalScore = &apos;&apos; + this.reviewScore + &apos; total score&apos;;</span><br><span class=\"line\">// good</span><br><span class=\"line\">var totalScore = this.reviewScore + &apos; total score&apos;;</span><br></pre></td></tr></table></figure>\n<p>3、使用 parseInt 转换数字时总是带上类型转换的基数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var inputValue = &apos;4&apos;;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">var val = new Number(inputValue);</span><br><span class=\"line\">// bad</span><br><span class=\"line\">var val = +inputValue;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">var val = inputValue &gt;&gt; 0;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">var val = parseInt(inputValue);</span><br><span class=\"line\">// good</span><br><span class=\"line\">var val = Number(inputValue);</span><br><span class=\"line\">// good</span><br><span class=\"line\">var val = parseInt(inputValue, 10);</span><br></pre></td></tr></table></figure>\n<p>4、如果因为某些原因 parseInt 成为你所做的事的瓶颈而需要使用位操作解决性能问题时，留个注释说清楚原因和你的目的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// good</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * parseInt was the reason my code was slow.</span><br><span class=\"line\"> * Bitshifting the String to coerce it to a</span><br><span class=\"line\"> * Number made it a lot faster.</span><br><span class=\"line\"> */</span><br><span class=\"line\">var val = inputValue &gt;&gt; 0;</span><br></pre></td></tr></table></figure>\n<p>5、布尔:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var age = 0;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">var hasAge = new Boolean(age);</span><br><span class=\"line\">// good</span><br><span class=\"line\">var hasAge = Boolean(age);</span><br><span class=\"line\">// good</span><br><span class=\"line\">var hasAge = !!age;</span><br></pre></td></tr></table></figure>\n<h3 id=\"命名规则\"><a href=\"#命名规则\" class=\"headerlink\" title=\"命名规则\"></a>命名规则</h3><p>1、避免单字母命名。命名应具备描述性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">function q() &#123;</span><br><span class=\"line\">  // ...stuff...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// good</span><br><span class=\"line\">function query() &#123;</span><br><span class=\"line\">  // ..stuff..</span><br></pre></td></tr></table></figure>\n<p>2、使用驼峰式命名对象、函数和实例。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">var OBJEcttsssss = &#123;&#125;;</span><br><span class=\"line\">var this_is_my_object = &#123;&#125;;</span><br><span class=\"line\">var o = &#123;&#125;;</span><br><span class=\"line\">function c() &#123;&#125;</span><br><span class=\"line\">// good</span><br><span class=\"line\">var thisIsMyObject = &#123;&#125;;</span><br><span class=\"line\">function thisIsMyFunction() &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>3、使用帕斯卡式命名构造函数或类。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">function user(options) &#123;</span><br><span class=\"line\">  this.name = options.name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var bad = new user(&#123;</span><br><span class=\"line\">  name: &apos;nope&apos;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// good</span><br><span class=\"line\">function User(options) &#123;</span><br><span class=\"line\">  this.name = options.name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var good = new User(&#123;</span><br><span class=\"line\">  name: &apos;yup&apos;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>4、不要使用下划线前/后缀。<br>为什么？JavaScript 并没有私有属性或私有方法的概念。虽然使用下划线是表示「私有」的一种共识，但实际上这些属性是完全公开的，它本身就是你公共接口的一部分。这种习惯或许会导致开发者错误的认为改动它不会造成破坏或者不需要去测试。长话短说：如果你想要某处为「私有」，它必须不能是显式提出的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">this.__firstName__ = &apos;Panda&apos;;</span><br><span class=\"line\">this.firstName_ = &apos;Panda&apos;;</span><br><span class=\"line\">this._firstName = &apos;Panda&apos;;</span><br><span class=\"line\">// good</span><br><span class=\"line\">this.firstName = &apos;Panda&apos;;</span><br></pre></td></tr></table></figure>\n<p>5、不要保存 this 的引用。使用 Function#bind。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// bad</span><br><span class=\"line\">function () &#123;</span><br><span class=\"line\">  var self = this;</span><br><span class=\"line\">  return function () &#123;</span><br><span class=\"line\">    console.log(self);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">function () &#123;</span><br><span class=\"line\">  var that = this;</span><br><span class=\"line\">  return function () &#123;</span><br><span class=\"line\">    console.log(that);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// bad</span><br><span class=\"line\">function () &#123;</span><br><span class=\"line\">  var _this = this;</span><br><span class=\"line\">  return function () &#123;</span><br><span class=\"line\">    console.log(_this);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// good</span><br><span class=\"line\">function () &#123;</span><br><span class=\"line\">  return function () &#123;</span><br><span class=\"line\">    console.log(this);</span><br><span class=\"line\">  &#125;.bind(this);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>6、如果你的文件导出一个类，你的文件名应该与类名完全相同。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// file contents</span><br><span class=\"line\">class CheckBox &#123;</span><br><span class=\"line\">  // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">module.exports = CheckBox;</span><br><span class=\"line\">// in some other file</span><br><span class=\"line\">// bad</span><br><span class=\"line\">var CheckBox = require(&apos;./checkBox&apos;);</span><br><span class=\"line\">// bad</span><br><span class=\"line\">var CheckBox = require(&apos;./check_box&apos;);</span><br><span class=\"line\">// good</span><br><span class=\"line\">var CheckBox = require(&apos;./CheckBox&apos;);</span><br></pre></td></tr></table></figure>\n<h3 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h3><p>1、模块应该以 ! 开始。这样确保了当一个不好的模块忘记包含最后的分号时，在合并代码到生产环境后不会产生错误<br>2、文件应该以驼峰式命名，并放在同名的文件夹里，且与导出的名字一致。<br>3、增加一个名为 noConflict() 的方法来设置导出的模块为前一个版本并返回它。<br>4、永远在模块顶部声明 ‘use strict’;。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// fancyInput/fancyInput.js</span><br><span class=\"line\">!function (global) &#123;</span><br><span class=\"line\">  &apos;use strict&apos;;</span><br><span class=\"line\">  var previousFancyInput = global.FancyInput;</span><br><span class=\"line\">  function FancyInput(options) &#123;</span><br><span class=\"line\">    this.options = options || &#123;&#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  FancyInput.noConflict = function noConflict() &#123;</span><br><span class=\"line\">    global.FancyInput = previousFancyInput;</span><br><span class=\"line\">    return FancyInput;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  global.FancyInput = FancyInput;</span><br><span class=\"line\">&#125;(this);</span><br></pre></td></tr></table></figure>\n<p>参考链接：<a href=\"https://github.com/sivan/javascript-style-guide/blob/master/es5/README.md\" target=\"_blank\" rel=\"noopener\">https://github.com/sivan/javascript-style-guide/blob/master/es5/README.md</a></p>"},{"title":"js简单的防抖跟节流","date":"2018-01-25T16:00:00.000Z","photos":["/img/2017/4.jpg"],"_content":"\n前端的优化这个老生常谈的话题，这次我来记录下js的防抖跟节流对于页面优化的实现方式。\n\n<!--more-->\n\n为了使用Web Socket,需要在Web服务器上运行一个Web Socket服务器。这个程序负责协调各方通信，而且启动后就会不间断的运行下去。本厂后端开发语言为php(毕竟是世界上最好的语言)，有兴趣的可以在github上找相关服务端代码阅读。本文只介绍Web Socket客户端的实现。\n\n## 前言\n\n在前端开发中我们会遇到一些频繁的事件触发，比如：window 的 resize、scroll，mousedown、mousemove，keyup、keydown …… 或者根据数据的改变实时得进行数据接口的请求，比如搜索。\n\n下面，我们举个示例代码来了解事件如何频繁的触发：\n\n`index.html` 文件：\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <title>debounce</title>\n    <style>\n        #container{\n            width: 100%; height: 200px; line-height: 200px; text-align: center; color: #fff; background-color: #333; font-size: 30px;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"container\"></div>\n    <script src=\"debounce.js\"></script>\n</body>\n</html>\n```\n`debounce.js` 文件：\n\n```JS\nvar count = 1;\nvar container = document.getElementById('container');\nfunction getMouseMove() {\n    container.innerHTML = count++;\n};\ncontainer.onmousemove = getMouseMove;\n```\n当我们从浏览器这样滑过去时会调用很多次的getMouseMove方法，这只是一个很简单的效果，浏览器完全反应得过来，试想一下，如果是复杂的回调或者是ajax请求那性能会大受打击，会有明显的卡顿。\n\n为了解决这个问题，一般有两种解决方案：\n    1、debounce 防抖\n    2、throttle 节流\n### 防抖\n防抖的原理就是：你尽管触发事件，但是我一定在事件停止触发 n 秒后才执行。\n\n这意味着如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件触发的时间为准，在此时间 n 秒后才执行。\n\n总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行!\n\n#### 防抖函数\n\n```JS\nfunction debounce(func, wait) {\n    var timeout;\n    return function () {\n        var context = this;\n        var args = arguments;\n        clearTimeout(timeout)\n        timeout = setTimeout(function(){\n            func.apply(context, args)\n        }, wait);\n    }\n}\n```\n使用：\n\n```JS\ncontainer.onmousemove = debounce(getMouseMove, 1000);\n```\n### 节流\n\n节流就是：如果你持续触发事件，每隔一段时间，只执行一次事件。\n\n关于节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置定时器。\n#### 使用时间戳\n让我们来看第一种方法：使用时间戳，当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为 0 )，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。\n\n```JS\nfunction throttle(func, wait) {\n    var context, args;\n    var previous = 0;\n    return function() {\n        var now = +new Date();\n        context = this;\n        args = arguments;\n        if (now - previous > wait) {\n            func.apply(context, args);\n            previous = now;\n        }\n    }\n}\n```\n例子依然是用讲 debounce 中的例子，如果你要使用：\n\n```JS\ncontainer.onmousemove = throttle(getMouseMove, 1000);\n```\n#### 使用定时器\n接下来，我们讲讲第二种实现方式，使用定时器。\n\n当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。\n\n```JS\nfunction throttle(func, wait) {\n    var timeout;\n    return function() {\n        context = this;\n        args = arguments;\n        if (!timeout) {\n            timeout = setTimeout(function(){\n                timeout = null;\n                func.apply(context, args)\n            }, wait)\n        }\n    }\n}\n```\n参考链接如下：\nhttps://segmentfault.com/a/1190000009638648\nhttps://segmentfault.com/a/1190000009831691\n\n\n","source":"_posts/debounce_throttle.md","raw":"title: js简单的防抖跟节流\ndate: 2018-01-26\ntag:\n - js\n\nphotos:\n - /img/2017/4.jpg \n\n---\n\n前端的优化这个老生常谈的话题，这次我来记录下js的防抖跟节流对于页面优化的实现方式。\n\n<!--more-->\n\n为了使用Web Socket,需要在Web服务器上运行一个Web Socket服务器。这个程序负责协调各方通信，而且启动后就会不间断的运行下去。本厂后端开发语言为php(毕竟是世界上最好的语言)，有兴趣的可以在github上找相关服务端代码阅读。本文只介绍Web Socket客户端的实现。\n\n## 前言\n\n在前端开发中我们会遇到一些频繁的事件触发，比如：window 的 resize、scroll，mousedown、mousemove，keyup、keydown …… 或者根据数据的改变实时得进行数据接口的请求，比如搜索。\n\n下面，我们举个示例代码来了解事件如何频繁的触发：\n\n`index.html` 文件：\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n    <title>debounce</title>\n    <style>\n        #container{\n            width: 100%; height: 200px; line-height: 200px; text-align: center; color: #fff; background-color: #333; font-size: 30px;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"container\"></div>\n    <script src=\"debounce.js\"></script>\n</body>\n</html>\n```\n`debounce.js` 文件：\n\n```JS\nvar count = 1;\nvar container = document.getElementById('container');\nfunction getMouseMove() {\n    container.innerHTML = count++;\n};\ncontainer.onmousemove = getMouseMove;\n```\n当我们从浏览器这样滑过去时会调用很多次的getMouseMove方法，这只是一个很简单的效果，浏览器完全反应得过来，试想一下，如果是复杂的回调或者是ajax请求那性能会大受打击，会有明显的卡顿。\n\n为了解决这个问题，一般有两种解决方案：\n    1、debounce 防抖\n    2、throttle 节流\n### 防抖\n防抖的原理就是：你尽管触发事件，但是我一定在事件停止触发 n 秒后才执行。\n\n这意味着如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件触发的时间为准，在此时间 n 秒后才执行。\n\n总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行!\n\n#### 防抖函数\n\n```JS\nfunction debounce(func, wait) {\n    var timeout;\n    return function () {\n        var context = this;\n        var args = arguments;\n        clearTimeout(timeout)\n        timeout = setTimeout(function(){\n            func.apply(context, args)\n        }, wait);\n    }\n}\n```\n使用：\n\n```JS\ncontainer.onmousemove = debounce(getMouseMove, 1000);\n```\n### 节流\n\n节流就是：如果你持续触发事件，每隔一段时间，只执行一次事件。\n\n关于节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置定时器。\n#### 使用时间戳\n让我们来看第一种方法：使用时间戳，当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为 0 )，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。\n\n```JS\nfunction throttle(func, wait) {\n    var context, args;\n    var previous = 0;\n    return function() {\n        var now = +new Date();\n        context = this;\n        args = arguments;\n        if (now - previous > wait) {\n            func.apply(context, args);\n            previous = now;\n        }\n    }\n}\n```\n例子依然是用讲 debounce 中的例子，如果你要使用：\n\n```JS\ncontainer.onmousemove = throttle(getMouseMove, 1000);\n```\n#### 使用定时器\n接下来，我们讲讲第二种实现方式，使用定时器。\n\n当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。\n\n```JS\nfunction throttle(func, wait) {\n    var timeout;\n    return function() {\n        context = this;\n        args = arguments;\n        if (!timeout) {\n            timeout = setTimeout(function(){\n                timeout = null;\n                func.apply(context, args)\n            }, wait)\n        }\n    }\n}\n```\n参考链接如下：\nhttps://segmentfault.com/a/1190000009638648\nhttps://segmentfault.com/a/1190000009831691\n\n\n","slug":"debounce_throttle","published":1,"updated":"2018-08-28T10:17:02.466Z","_id":"cjldh03r70005uv6xw3qa2h17","comments":1,"layout":"post","link":"","content":"<p>前端的优化这个老生常谈的话题，这次我来记录下js的防抖跟节流对于页面优化的实现方式。</p>\n<a id=\"more\"></a>\n<p>为了使用Web Socket,需要在Web服务器上运行一个Web Socket服务器。这个程序负责协调各方通信，而且启动后就会不间断的运行下去。本厂后端开发语言为php(毕竟是世界上最好的语言)，有兴趣的可以在github上找相关服务端代码阅读。本文只介绍Web Socket客户端的实现。</p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在前端开发中我们会遇到一些频繁的事件触发，比如：window 的 resize、scroll，mousedown、mousemove，keyup、keydown …… 或者根据数据的改变实时得进行数据接口的请求，比如搜索。</p>\n<p>下面，我们举个示例代码来了解事件如何频繁的触发：</p>\n<p><code>index.html</code> 文件：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>debounce<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">        #container&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            width: 100%; height: 200px; line-height: 200px; text-align: center; color: #fff; background-color: #333; font-size: 30px;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"container\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"debounce.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>debounce.js</code> 文件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> container = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'container'</span>);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getMouseMove</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    container.innerHTML = count++;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">container.onmousemove = getMouseMove;</span><br></pre></td></tr></table></figure>\n<p>当我们从浏览器这样滑过去时会调用很多次的getMouseMove方法，这只是一个很简单的效果，浏览器完全反应得过来，试想一下，如果是复杂的回调或者是ajax请求那性能会大受打击，会有明显的卡顿。</p>\n<p>为了解决这个问题，一般有两种解决方案：<br>    1、debounce 防抖<br>    2、throttle 节流</p>\n<h3 id=\"防抖\"><a href=\"#防抖\" class=\"headerlink\" title=\"防抖\"></a>防抖</h3><p>防抖的原理就是：你尽管触发事件，但是我一定在事件停止触发 n 秒后才执行。</p>\n<p>这意味着如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件触发的时间为准，在此时间 n 秒后才执行。</p>\n<p>总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行!</p>\n<h4 id=\"防抖函数\"><a href=\"#防抖函数\" class=\"headerlink\" title=\"防抖函数\"></a>防抖函数</h4><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">func, wait</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> timeout;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> context = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">        clearTimeout(timeout)</span><br><span class=\"line\">        timeout = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            func.apply(context, args)</span><br><span class=\"line\">        &#125;, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">container.onmousemove = debounce(getMouseMove, <span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"节流\"><a href=\"#节流\" class=\"headerlink\" title=\"节流\"></a>节流</h3><p>节流就是：如果你持续触发事件，每隔一段时间，只执行一次事件。</p>\n<p>关于节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置定时器。</p>\n<h4 id=\"使用时间戳\"><a href=\"#使用时间戳\" class=\"headerlink\" title=\"使用时间戳\"></a>使用时间戳</h4><p>让我们来看第一种方法：使用时间戳，当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为 0 )，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">func, wait</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> context, args;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> previous = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> now = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">        context = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (now - previous &gt; wait) &#123;</span><br><span class=\"line\">            func.apply(context, args);</span><br><span class=\"line\">            previous = now;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>例子依然是用讲 debounce 中的例子，如果你要使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">container.onmousemove = throttle(getMouseMove, <span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用定时器\"><a href=\"#使用定时器\" class=\"headerlink\" title=\"使用定时器\"></a>使用定时器</h4><p>接下来，我们讲讲第二种实现方式，使用定时器。</p>\n<p>当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">func, wait</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> timeout;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        context = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!timeout) &#123;</span><br><span class=\"line\">            timeout = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">                timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                func.apply(context, args)</span><br><span class=\"line\">            &#125;, wait)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>参考链接如下：<br><a href=\"https://segmentfault.com/a/1190000009638648\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000009638648</a><br><a href=\"https://segmentfault.com/a/1190000009831691\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000009831691</a></p>\n","site":{"data":{}},"excerpt":"<p>前端的优化这个老生常谈的话题，这次我来记录下js的防抖跟节流对于页面优化的实现方式。</p>","more":"<p>为了使用Web Socket,需要在Web服务器上运行一个Web Socket服务器。这个程序负责协调各方通信，而且启动后就会不间断的运行下去。本厂后端开发语言为php(毕竟是世界上最好的语言)，有兴趣的可以在github上找相关服务端代码阅读。本文只介绍Web Socket客户端的实现。</p>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在前端开发中我们会遇到一些频繁的事件触发，比如：window 的 resize、scroll，mousedown、mousemove，keyup、keydown …… 或者根据数据的改变实时得进行数据接口的请求，比如搜索。</p>\n<p>下面，我们举个示例代码来了解事件如何频繁的触发：</p>\n<p><code>index.html</code> 文件：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE html&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>debounce<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"undefined\"></span></span><br><span class=\"line\"><span class=\"undefined\">        #container&#123;</span></span><br><span class=\"line\"><span class=\"undefined\">            width: 100%; height: 200px; line-height: 200px; text-align: center; color: #fff; background-color: #333; font-size: 30px;</span></span><br><span class=\"line\"><span class=\"undefined\">        &#125;</span></span><br><span class=\"line\"><span class=\"undefined\">    </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"container\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"debounce.js\"</span>&gt;</span><span class=\"undefined\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>debounce.js</code> 文件：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> container = <span class=\"built_in\">document</span>.getElementById(<span class=\"string\">'container'</span>);</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getMouseMove</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    container.innerHTML = count++;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">container.onmousemove = getMouseMove;</span><br></pre></td></tr></table></figure>\n<p>当我们从浏览器这样滑过去时会调用很多次的getMouseMove方法，这只是一个很简单的效果，浏览器完全反应得过来，试想一下，如果是复杂的回调或者是ajax请求那性能会大受打击，会有明显的卡顿。</p>\n<p>为了解决这个问题，一般有两种解决方案：<br>    1、debounce 防抖<br>    2、throttle 节流</p>\n<h3 id=\"防抖\"><a href=\"#防抖\" class=\"headerlink\" title=\"防抖\"></a>防抖</h3><p>防抖的原理就是：你尽管触发事件，但是我一定在事件停止触发 n 秒后才执行。</p>\n<p>这意味着如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件触发的时间为准，在此时间 n 秒后才执行。</p>\n<p>总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行!</p>\n<h4 id=\"防抖函数\"><a href=\"#防抖函数\" class=\"headerlink\" title=\"防抖函数\"></a>防抖函数</h4><figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">debounce</span>(<span class=\"params\">func, wait</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> timeout;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> context = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">        clearTimeout(timeout)</span><br><span class=\"line\">        timeout = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">            func.apply(context, args)</span><br><span class=\"line\">        &#125;, wait);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">container.onmousemove = debounce(getMouseMove, <span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure>\n<h3 id=\"节流\"><a href=\"#节流\" class=\"headerlink\" title=\"节流\"></a>节流</h3><p>节流就是：如果你持续触发事件，每隔一段时间，只执行一次事件。</p>\n<p>关于节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置定时器。</p>\n<h4 id=\"使用时间戳\"><a href=\"#使用时间戳\" class=\"headerlink\" title=\"使用时间戳\"></a>使用时间戳</h4><p>让我们来看第一种方法：使用时间戳，当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为 0 )，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">func, wait</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> context, args;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> previous = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> now = +<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">        context = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (now - previous &gt; wait) &#123;</span><br><span class=\"line\">            func.apply(context, args);</span><br><span class=\"line\">            previous = now;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>例子依然是用讲 debounce 中的例子，如果你要使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\">container.onmousemove = throttle(getMouseMove, <span class=\"number\">1000</span>);</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用定时器\"><a href=\"#使用定时器\" class=\"headerlink\" title=\"使用定时器\"></a>使用定时器</h4><p>接下来，我们讲讲第二种实现方式，使用定时器。</p>\n<p>当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span>(<span class=\"params\">func, wait</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> timeout;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        context = <span class=\"keyword\">this</span>;</span><br><span class=\"line\">        args = <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!timeout) &#123;</span><br><span class=\"line\">            timeout = setTimeout(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">                timeout = <span class=\"literal\">null</span>;</span><br><span class=\"line\">                func.apply(context, args)</span><br><span class=\"line\">            &#125;, wait)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>参考链接如下：<br><a href=\"https://segmentfault.com/a/1190000009638648\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000009638648</a><br><a href=\"https://segmentfault.com/a/1190000009831691\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000009831691</a></p>"},{"title":"移动端-图片压缩上传实践","date":"2018-08-26T16:00:00.000Z","photos":["/img/2017/npm-node.png"],"_content":"\n本文主要讲解移动端的图片压缩上传，在移动端压缩图片并且上传主要用到filereader、canvas 以及 formdata 这三个h5的api。\n\n<!--more-->\n\n在做移动端图片上传的时候，用户传的都是手机本地图片，而本地图片一般都相对比较大，拿iphone6来说，平时拍很多图片都是一两M的，如果直接这样上传，那图片就太大了，如果用户用的是移动流量，完全把图片上传显然不是一个好办法。\n\n　　目前来说，HTML5的各种新API都在移动端的webkit上得到了较好的实现。根据查看caniuse，本demo里使用到的FileReader、Blob、Formdata对象均已在大部分移动设备浏览器中得到了实现（safari6.0+、android 3.0+），所以直接在前端压缩图片，已经成了很多移动端图片上传的必备功能了。\n\n　　在移动端压缩图片并且上传主要用到filereader、canvas 以及 formdata 这三个h5的api。逻辑并不难。整个过程就是：\n\n　　（1）用户使用input file上传图片的时候，用filereader读取用户上传的图片数据（base64格式）\n\n　　（2）把图片数据传入img对象，然后将img绘制到canvas上，再调用canvas.toDataURL对图片进行压缩\n\n　　（3）获取到压缩后的base64格式图片数据，转成二进制塞入formdata，再通过XmlHttpRequest提交formdata。\n\n　　如此三步，就完成了图片的压缩和上传。\n\n　　说起来好像挺简单，其实还是有些坑的。接下来就直接用代码进行分析：\n　　\n### 获取图片数据\n先是获取图片数据，也就是监听input file的change事件，然后获取到上传的文件对象files，如果是多张图需将类数组的files转成数组，然后进行forEach遍历。\n\n　　接着判断文件类型，如果不是图片则不作处理。如果是图片就实例化一个filereader，以base64格式读取上传的文件数据，判断数据长度，如果大于3M的图片就调用compress方法进行压缩，否则调用upload方法进行上传。　\n\n\n    // 上传图片回显到本地并且判断超过3M走压缩否则直接上传到服务器\n    choosePhoto:function(event){\n                \n                var that = this;\n\t\t\t\tvar target = event.currentTarget;\n                var file = target.files[0];\n                \n                // 判断图片的类型大小\n                var imgType = /\\.jpg|\\.png|\\.jpeg/i;\n                if( !imgType.test(file.name) ){\n                    this.layer(\"只支持图片上传，请选择正确的图片格式\");\n                    return;\n                }\n                // 利用fileReader 预览图片\n                if( typeof FileReader ==\"underfined\" )  {\n                    this.layer(\"您的浏览器不支持图片预览功能，请换浏览器重试\");\n                \n                }else{\n                    var reader = new FileReader();\n                    reader.onload = function(){\n                        that.img.src = reader.result;\n        \t\t\t\t\tvar img = new Image();\n        \t\t\t\timg.src = reader.result;\n\t\t\t\t\t\tif((file.size/1024000)>3){\n\t\t\t\t\t\t\tvar data = that.compress(img);\n\t\t\t\t\t\t\tthat.Upload2(data,file.type,idx);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tthat.Upload(target.files[0],idx);\n\t\t\t\t\t\t} \n                        // input清空，防止两次请求同一个时不能选中\n                        target.value = '';\n\t\t\t\t\t}\n\t\t\t\t\treader.readAsDataURL(file);\n                }\n\t\t\t},\n\t\n\t\n### 压缩图片\n\t\n上面做完图片数据的获取后，就可以做compress压缩图片的方法了。而压缩图片也并不是直接把图片绘制到canvas再调用一下toDataURL就行的。\n\n　　在IOS中，canvas绘制图片是有两个限制的：\n\n　　首先是图片的大小，如果图片的大小超过两百万像素，图片也是无法绘制到canvas上的，调用drawImage的时候不会报错，但是你用toDataURL获取图片数据的时候获取到的是空的图片数据。\n\n　　再者就是canvas的大小有限制，如果canvas的大小大于大概五百万像素（即宽高乘积）的时候，不仅图片画不出来，其他什么东西也都是画不出来的。\n\n　　应对第一种限制，处理办法就是瓦片绘制了。瓦片绘制，也就是将图片分割成多块绘制到canvas上，我代码里的做法是把图片分割成100万像素一块的大小，再绘制到canvas上。\n\n　　而应对第二种限制，我的处理办法是对图片的宽高进行适当压缩，我代码里为了保险起见，设的上限是四百万像素，如果图片大于四百万像素就压缩到小于四百万像素。四百万像素的图片应该够了，算起来宽高都有2000X2000了。\n\n　　如此一来就解决了IOS上的两种限制了。\n\n　　除了上面所述的限制，还有两个坑，一个就是canvas的toDataURL是只能压缩jpg的，当用户上传的图片是png的话，就需要转成jpg，也就是统一用canvas.toDataURL('image/jpeg', 0.1) ， 类型统一设成jpeg，而压缩比就自己控制了。\n\n　　另一个就是如果是png转jpg，绘制到canvas上的时候，canvas存在透明区域的话，当转成jpg的时候透明区域会变成黑色，因为canvas的透明像素默认为rgba(0,0,0,0)，所以转成jpg就变成rgba(0,0,0,1)了，也就是透明背景会变成了黑色。解决办法就是绘制之前在canvas上铺一层白色的底色。\n　　\n\n\n   compress:function(img) {\n    var canvas = document.createElement(\"canvas\");\n    var ctx = canvas.getContext('2d');\n    //瓦片canvas\n    var tCanvas = document.createElement(\"canvas\");\n    var tctx = tCanvas.getContext(\"2d\");\n    var initSize = img.src.length;\n    var width = img.width;\n    var height = img.height;\n\n    //如果图片大于四百万像素，计算压缩比并将大小压至400万以下\n    var ratio;\n    if ((ratio = width * height / 4000000)>1) {\n        ratio = Math.sqrt(ratio);\n        width /= ratio;\n        height /= ratio;\n    }else {\n        ratio = 1;\n    }\n\n    canvas.width = width;\n    canvas.height = height;\n\n    // 铺底色\n    ctx.fillStyle = \"#fff\";\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    //如果图片像素大于100万则使用瓦片绘制\n    var count;\n    if ((count = width * height / 1000000) > 1) {\n        count = ~~(Math.sqrt(count)+1); //计算要分成多少块瓦片\n\n        // 计算每块瓦片的宽和高\n        var nw = ~~(width / count);\n        var nh = ~~(height / count);\n\n        tCanvas.width = nw;\n        tCanvas.height = nh;\n\n        for (var i = 0; i < count; i++) {\n            for (var j = 0; j < count; j++) {\n                tctx.drawImage(img, i * nw * ratio, j * nh * ratio, nw * ratio, nh * ratio, 0, 0, nw, nh);\n                ctx.drawImage(tCanvas, i * nw, j * nh, nw, nh);\n            }\n        }\n    } else {\n        ctx.drawImage(img, 0, 0, width, height);\n    }\n\n    //进行最小压缩\n    var ndata = canvas.toDataURL('image/jpeg', 0.1);\n\n    console.log('压缩前：' + initSize);\n    console.log('压缩后：' + ndata.length);\n    console.log('压缩率：' + ~~(100 * (initSize - ndata.length) / initSize) + \"%\");\n\n    tCanvas.width = tCanvas.height = canvas.width = canvas.height = 0;\n\n    return ndata;\n}\n  \n###  图片上传\n\n完成图片压缩后，就可以塞进formdata里进行上传了，先将base64数据转成字符串，再实例化一个ArrayBuffer，然后将字符串以8位整型的格式传入ArrayBuffer，再通过BlobBuilder或者Blob对象，将8位整型的ArrayBuffer转成二进制对象blob，然后把blob对象append到formdata里，再通过ajax发送给后台即可。\n\ngetBlob:function(buffer, format) {\n    try {\n      return new Blob(buffer, {type: format});\n    } catch (e) {\n      var bb = new (window.BlobBuilder || window.WebKitBlobBuilder || window.MSBlobBuilder);\n      buffer.forEach(function(buf) {\n        bb.append(buf);\n      });\n      return bb.getBlob(format);\n    }\n  },\n\t\t\t// 上传图片的ajax请求\n\t\t\tasync Upload2(fileData,type,index){\n\t\t\t\tconsole.log(\"执行了上传的第二个函数\");\n\t\t\t\tvar text = window.atob(fileData.split(\",\")[1]);\n    var buffer = new Uint8Array(text.length);\n    var pecent = 0, loop = null;\n    for (var i = 0; i < text.length; i++) {\n      buffer[i] = text.charCodeAt(i);\n    }\n    var blob = this.getBlob([buffer], type);\n                let that = this;\n\t\t\t\tlet form = new FormData();\n\t\t\t\tform.append(\"Filedata\",blob);\n\t\t\t\tawait myAjax.post( apiPath.upload ,form,{\n\t\t\t\t\t'headers':{\n\t\t\t\t\t\t'mimeType':'multipart/form-data'\n\t\t\t\t\t}\n\t\t\t\t} ).then( res => {\n\t\t\t\t\t\n\t\t\t\t} ).catch( e => {\n\t\t\t\t} );\n               \n\t\t\t\t\n\t\t\t},\n\t\t\t// 上传图片的ajax请求\n\t\t\tasync Upload(fileData,index){\n                let that = this;\n\t\t\t\tlet form = new FormData();\n\t\t\t\tform.append(\"Filedata\",fileData);\n\t\t\t\tawait myAjax.post( apiPath.upload ,form,{\n\t\t\t\t\t'headers':{\n\t\t\t\t\t\t'mimeType':'multipart/form-data'\n\t\t\t\t\t}\n\t\t\t\t} ).then( res => {\n\t\t\t\t\t\n\t\t\t\t} ).catch( e => {\n\t\t\t\t} );\n               \n\t\t\t},\n\n\n本文代码提供了大概的思路以及主要的代码，具体的demo自己动手做起来吧。这格式真的是见鬼了，凑合着看吧。\n\n\n","source":"_posts/imgUpload.md","raw":"title: 移动端-图片压缩上传实践\ndate: 2018-08-27\ntag:\n - js\n\nphotos:\n - /img/2017/npm-node.png \n\n---\n\n本文主要讲解移动端的图片压缩上传，在移动端压缩图片并且上传主要用到filereader、canvas 以及 formdata 这三个h5的api。\n\n<!--more-->\n\n在做移动端图片上传的时候，用户传的都是手机本地图片，而本地图片一般都相对比较大，拿iphone6来说，平时拍很多图片都是一两M的，如果直接这样上传，那图片就太大了，如果用户用的是移动流量，完全把图片上传显然不是一个好办法。\n\n　　目前来说，HTML5的各种新API都在移动端的webkit上得到了较好的实现。根据查看caniuse，本demo里使用到的FileReader、Blob、Formdata对象均已在大部分移动设备浏览器中得到了实现（safari6.0+、android 3.0+），所以直接在前端压缩图片，已经成了很多移动端图片上传的必备功能了。\n\n　　在移动端压缩图片并且上传主要用到filereader、canvas 以及 formdata 这三个h5的api。逻辑并不难。整个过程就是：\n\n　　（1）用户使用input file上传图片的时候，用filereader读取用户上传的图片数据（base64格式）\n\n　　（2）把图片数据传入img对象，然后将img绘制到canvas上，再调用canvas.toDataURL对图片进行压缩\n\n　　（3）获取到压缩后的base64格式图片数据，转成二进制塞入formdata，再通过XmlHttpRequest提交formdata。\n\n　　如此三步，就完成了图片的压缩和上传。\n\n　　说起来好像挺简单，其实还是有些坑的。接下来就直接用代码进行分析：\n　　\n### 获取图片数据\n先是获取图片数据，也就是监听input file的change事件，然后获取到上传的文件对象files，如果是多张图需将类数组的files转成数组，然后进行forEach遍历。\n\n　　接着判断文件类型，如果不是图片则不作处理。如果是图片就实例化一个filereader，以base64格式读取上传的文件数据，判断数据长度，如果大于3M的图片就调用compress方法进行压缩，否则调用upload方法进行上传。　\n\n\n    // 上传图片回显到本地并且判断超过3M走压缩否则直接上传到服务器\n    choosePhoto:function(event){\n                \n                var that = this;\n\t\t\t\tvar target = event.currentTarget;\n                var file = target.files[0];\n                \n                // 判断图片的类型大小\n                var imgType = /\\.jpg|\\.png|\\.jpeg/i;\n                if( !imgType.test(file.name) ){\n                    this.layer(\"只支持图片上传，请选择正确的图片格式\");\n                    return;\n                }\n                // 利用fileReader 预览图片\n                if( typeof FileReader ==\"underfined\" )  {\n                    this.layer(\"您的浏览器不支持图片预览功能，请换浏览器重试\");\n                \n                }else{\n                    var reader = new FileReader();\n                    reader.onload = function(){\n                        that.img.src = reader.result;\n        \t\t\t\t\tvar img = new Image();\n        \t\t\t\timg.src = reader.result;\n\t\t\t\t\t\tif((file.size/1024000)>3){\n\t\t\t\t\t\t\tvar data = that.compress(img);\n\t\t\t\t\t\t\tthat.Upload2(data,file.type,idx);\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tthat.Upload(target.files[0],idx);\n\t\t\t\t\t\t} \n                        // input清空，防止两次请求同一个时不能选中\n                        target.value = '';\n\t\t\t\t\t}\n\t\t\t\t\treader.readAsDataURL(file);\n                }\n\t\t\t},\n\t\n\t\n### 压缩图片\n\t\n上面做完图片数据的获取后，就可以做compress压缩图片的方法了。而压缩图片也并不是直接把图片绘制到canvas再调用一下toDataURL就行的。\n\n　　在IOS中，canvas绘制图片是有两个限制的：\n\n　　首先是图片的大小，如果图片的大小超过两百万像素，图片也是无法绘制到canvas上的，调用drawImage的时候不会报错，但是你用toDataURL获取图片数据的时候获取到的是空的图片数据。\n\n　　再者就是canvas的大小有限制，如果canvas的大小大于大概五百万像素（即宽高乘积）的时候，不仅图片画不出来，其他什么东西也都是画不出来的。\n\n　　应对第一种限制，处理办法就是瓦片绘制了。瓦片绘制，也就是将图片分割成多块绘制到canvas上，我代码里的做法是把图片分割成100万像素一块的大小，再绘制到canvas上。\n\n　　而应对第二种限制，我的处理办法是对图片的宽高进行适当压缩，我代码里为了保险起见，设的上限是四百万像素，如果图片大于四百万像素就压缩到小于四百万像素。四百万像素的图片应该够了，算起来宽高都有2000X2000了。\n\n　　如此一来就解决了IOS上的两种限制了。\n\n　　除了上面所述的限制，还有两个坑，一个就是canvas的toDataURL是只能压缩jpg的，当用户上传的图片是png的话，就需要转成jpg，也就是统一用canvas.toDataURL('image/jpeg', 0.1) ， 类型统一设成jpeg，而压缩比就自己控制了。\n\n　　另一个就是如果是png转jpg，绘制到canvas上的时候，canvas存在透明区域的话，当转成jpg的时候透明区域会变成黑色，因为canvas的透明像素默认为rgba(0,0,0,0)，所以转成jpg就变成rgba(0,0,0,1)了，也就是透明背景会变成了黑色。解决办法就是绘制之前在canvas上铺一层白色的底色。\n　　\n\n\n   compress:function(img) {\n    var canvas = document.createElement(\"canvas\");\n    var ctx = canvas.getContext('2d');\n    //瓦片canvas\n    var tCanvas = document.createElement(\"canvas\");\n    var tctx = tCanvas.getContext(\"2d\");\n    var initSize = img.src.length;\n    var width = img.width;\n    var height = img.height;\n\n    //如果图片大于四百万像素，计算压缩比并将大小压至400万以下\n    var ratio;\n    if ((ratio = width * height / 4000000)>1) {\n        ratio = Math.sqrt(ratio);\n        width /= ratio;\n        height /= ratio;\n    }else {\n        ratio = 1;\n    }\n\n    canvas.width = width;\n    canvas.height = height;\n\n    // 铺底色\n    ctx.fillStyle = \"#fff\";\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n    //如果图片像素大于100万则使用瓦片绘制\n    var count;\n    if ((count = width * height / 1000000) > 1) {\n        count = ~~(Math.sqrt(count)+1); //计算要分成多少块瓦片\n\n        // 计算每块瓦片的宽和高\n        var nw = ~~(width / count);\n        var nh = ~~(height / count);\n\n        tCanvas.width = nw;\n        tCanvas.height = nh;\n\n        for (var i = 0; i < count; i++) {\n            for (var j = 0; j < count; j++) {\n                tctx.drawImage(img, i * nw * ratio, j * nh * ratio, nw * ratio, nh * ratio, 0, 0, nw, nh);\n                ctx.drawImage(tCanvas, i * nw, j * nh, nw, nh);\n            }\n        }\n    } else {\n        ctx.drawImage(img, 0, 0, width, height);\n    }\n\n    //进行最小压缩\n    var ndata = canvas.toDataURL('image/jpeg', 0.1);\n\n    console.log('压缩前：' + initSize);\n    console.log('压缩后：' + ndata.length);\n    console.log('压缩率：' + ~~(100 * (initSize - ndata.length) / initSize) + \"%\");\n\n    tCanvas.width = tCanvas.height = canvas.width = canvas.height = 0;\n\n    return ndata;\n}\n  \n###  图片上传\n\n完成图片压缩后，就可以塞进formdata里进行上传了，先将base64数据转成字符串，再实例化一个ArrayBuffer，然后将字符串以8位整型的格式传入ArrayBuffer，再通过BlobBuilder或者Blob对象，将8位整型的ArrayBuffer转成二进制对象blob，然后把blob对象append到formdata里，再通过ajax发送给后台即可。\n\ngetBlob:function(buffer, format) {\n    try {\n      return new Blob(buffer, {type: format});\n    } catch (e) {\n      var bb = new (window.BlobBuilder || window.WebKitBlobBuilder || window.MSBlobBuilder);\n      buffer.forEach(function(buf) {\n        bb.append(buf);\n      });\n      return bb.getBlob(format);\n    }\n  },\n\t\t\t// 上传图片的ajax请求\n\t\t\tasync Upload2(fileData,type,index){\n\t\t\t\tconsole.log(\"执行了上传的第二个函数\");\n\t\t\t\tvar text = window.atob(fileData.split(\",\")[1]);\n    var buffer = new Uint8Array(text.length);\n    var pecent = 0, loop = null;\n    for (var i = 0; i < text.length; i++) {\n      buffer[i] = text.charCodeAt(i);\n    }\n    var blob = this.getBlob([buffer], type);\n                let that = this;\n\t\t\t\tlet form = new FormData();\n\t\t\t\tform.append(\"Filedata\",blob);\n\t\t\t\tawait myAjax.post( apiPath.upload ,form,{\n\t\t\t\t\t'headers':{\n\t\t\t\t\t\t'mimeType':'multipart/form-data'\n\t\t\t\t\t}\n\t\t\t\t} ).then( res => {\n\t\t\t\t\t\n\t\t\t\t} ).catch( e => {\n\t\t\t\t} );\n               \n\t\t\t\t\n\t\t\t},\n\t\t\t// 上传图片的ajax请求\n\t\t\tasync Upload(fileData,index){\n                let that = this;\n\t\t\t\tlet form = new FormData();\n\t\t\t\tform.append(\"Filedata\",fileData);\n\t\t\t\tawait myAjax.post( apiPath.upload ,form,{\n\t\t\t\t\t'headers':{\n\t\t\t\t\t\t'mimeType':'multipart/form-data'\n\t\t\t\t\t}\n\t\t\t\t} ).then( res => {\n\t\t\t\t\t\n\t\t\t\t} ).catch( e => {\n\t\t\t\t} );\n               \n\t\t\t},\n\n\n本文代码提供了大概的思路以及主要的代码，具体的demo自己动手做起来吧。这格式真的是见鬼了，凑合着看吧。\n\n\n","slug":"imgUpload","published":1,"updated":"2018-08-28T10:33:10.804Z","_id":"cjldh03ra0006uv6xw4zbq7oq","comments":1,"layout":"post","link":"","content":"<p>本文主要讲解移动端的图片压缩上传，在移动端压缩图片并且上传主要用到filereader、canvas 以及 formdata 这三个h5的api。</p>\n<a id=\"more\"></a>\n<p>在做移动端图片上传的时候，用户传的都是手机本地图片，而本地图片一般都相对比较大，拿iphone6来说，平时拍很多图片都是一两M的，如果直接这样上传，那图片就太大了，如果用户用的是移动流量，完全把图片上传显然不是一个好办法。</p>\n<p>　　目前来说，HTML5的各种新API都在移动端的webkit上得到了较好的实现。根据查看caniuse，本demo里使用到的FileReader、Blob、Formdata对象均已在大部分移动设备浏览器中得到了实现（safari6.0+、android 3.0+），所以直接在前端压缩图片，已经成了很多移动端图片上传的必备功能了。</p>\n<p>　　在移动端压缩图片并且上传主要用到filereader、canvas 以及 formdata 这三个h5的api。逻辑并不难。整个过程就是：</p>\n<p>　　（1）用户使用input file上传图片的时候，用filereader读取用户上传的图片数据（base64格式）</p>\n<p>　　（2）把图片数据传入img对象，然后将img绘制到canvas上，再调用canvas.toDataURL对图片进行压缩</p>\n<p>　　（3）获取到压缩后的base64格式图片数据，转成二进制塞入formdata，再通过XmlHttpRequest提交formdata。</p>\n<p>　　如此三步，就完成了图片的压缩和上传。</p>\n<p>　　说起来好像挺简单，其实还是有些坑的。接下来就直接用代码进行分析：\n　　</p>\n<h3 id=\"获取图片数据\"><a href=\"#获取图片数据\" class=\"headerlink\" title=\"获取图片数据\"></a>获取图片数据</h3><p>先是获取图片数据，也就是监听input file的change事件，然后获取到上传的文件对象files，如果是多张图需将类数组的files转成数组，然后进行forEach遍历。</p>\n<p>　　接着判断文件类型，如果不是图片则不作处理。如果是图片就实例化一个filereader，以base64格式读取上传的文件数据，判断数据长度，如果大于3M的图片就调用compress方法进行压缩，否则调用upload方法进行上传。　</p>\n<pre><code>// 上传图片回显到本地并且判断超过3M走压缩否则直接上传到服务器\nchoosePhoto:function(event){\n\n            var that = this;\n            var target = event.currentTarget;\n            var file = target.files[0];\n\n            // 判断图片的类型大小\n            var imgType = /\\.jpg|\\.png|\\.jpeg/i;\n            if( !imgType.test(file.name) ){\n                this.layer(&quot;只支持图片上传，请选择正确的图片格式&quot;);\n                return;\n            }\n            // 利用fileReader 预览图片\n            if( typeof FileReader ==&quot;underfined&quot; )  {\n                this.layer(&quot;您的浏览器不支持图片预览功能，请换浏览器重试&quot;);\n\n            }else{\n                var reader = new FileReader();\n                reader.onload = function(){\n                    that.img.src = reader.result;\n                        var img = new Image();\n                    img.src = reader.result;\n                    if((file.size/1024000)&gt;3){\n                        var data = that.compress(img);\n                        that.Upload2(data,file.type,idx);\n                    }else{\n                        that.Upload(target.files[0],idx);\n                    } \n                    // input清空，防止两次请求同一个时不能选中\n                    target.value = &apos;&apos;;\n                }\n                reader.readAsDataURL(file);\n            }\n        },\n</code></pre><h3 id=\"压缩图片\"><a href=\"#压缩图片\" class=\"headerlink\" title=\"压缩图片\"></a>压缩图片</h3><p>上面做完图片数据的获取后，就可以做compress压缩图片的方法了。而压缩图片也并不是直接把图片绘制到canvas再调用一下toDataURL就行的。</p>\n<p>　　在IOS中，canvas绘制图片是有两个限制的：</p>\n<p>　　首先是图片的大小，如果图片的大小超过两百万像素，图片也是无法绘制到canvas上的，调用drawImage的时候不会报错，但是你用toDataURL获取图片数据的时候获取到的是空的图片数据。</p>\n<p>　　再者就是canvas的大小有限制，如果canvas的大小大于大概五百万像素（即宽高乘积）的时候，不仅图片画不出来，其他什么东西也都是画不出来的。</p>\n<p>　　应对第一种限制，处理办法就是瓦片绘制了。瓦片绘制，也就是将图片分割成多块绘制到canvas上，我代码里的做法是把图片分割成100万像素一块的大小，再绘制到canvas上。</p>\n<p>　　而应对第二种限制，我的处理办法是对图片的宽高进行适当压缩，我代码里为了保险起见，设的上限是四百万像素，如果图片大于四百万像素就压缩到小于四百万像素。四百万像素的图片应该够了，算起来宽高都有2000X2000了。</p>\n<p>　　如此一来就解决了IOS上的两种限制了。</p>\n<p>　　除了上面所述的限制，还有两个坑，一个就是canvas的toDataURL是只能压缩jpg的，当用户上传的图片是png的话，就需要转成jpg，也就是统一用canvas.toDataURL(‘image/jpeg’, 0.1) ， 类型统一设成jpeg，而压缩比就自己控制了。</p>\n<p>　　另一个就是如果是png转jpg，绘制到canvas上的时候，canvas存在透明区域的话，当转成jpg的时候透明区域会变成黑色，因为canvas的透明像素默认为rgba(0,0,0,0)，所以转成jpg就变成rgba(0,0,0,1)了，也就是透明背景会变成了黑色。解决办法就是绘制之前在canvas上铺一层白色的底色。\n　　</p>\n<p>   compress:function(img) {<br>    var canvas = document.createElement(“canvas”);<br>    var ctx = canvas.getContext(‘2d’);<br>    //瓦片canvas<br>    var tCanvas = document.createElement(“canvas”);<br>    var tctx = tCanvas.getContext(“2d”);<br>    var initSize = img.src.length;<br>    var width = img.width;<br>    var height = img.height;</p>\n<pre><code>//如果图片大于四百万像素，计算压缩比并将大小压至400万以下\nvar ratio;\nif ((ratio = width * height / 4000000)&gt;1) {\n    ratio = Math.sqrt(ratio);\n    width /= ratio;\n    height /= ratio;\n}else {\n    ratio = 1;\n}\n\ncanvas.width = width;\ncanvas.height = height;\n\n// 铺底色\nctx.fillStyle = &quot;#fff&quot;;\nctx.fillRect(0, 0, canvas.width, canvas.height);\n\n//如果图片像素大于100万则使用瓦片绘制\nvar count;\nif ((count = width * height / 1000000) &gt; 1) {\n    count = ~~(Math.sqrt(count)+1); //计算要分成多少块瓦片\n\n    // 计算每块瓦片的宽和高\n    var nw = ~~(width / count);\n    var nh = ~~(height / count);\n\n    tCanvas.width = nw;\n    tCanvas.height = nh;\n\n    for (var i = 0; i &lt; count; i++) {\n        for (var j = 0; j &lt; count; j++) {\n            tctx.drawImage(img, i * nw * ratio, j * nh * ratio, nw * ratio, nh * ratio, 0, 0, nw, nh);\n            ctx.drawImage(tCanvas, i * nw, j * nh, nw, nh);\n        }\n    }\n} else {\n    ctx.drawImage(img, 0, 0, width, height);\n}\n\n//进行最小压缩\nvar ndata = canvas.toDataURL(&apos;image/jpeg&apos;, 0.1);\n\nconsole.log(&apos;压缩前：&apos; + initSize);\nconsole.log(&apos;压缩后：&apos; + ndata.length);\nconsole.log(&apos;压缩率：&apos; + ~~(100 * (initSize - ndata.length) / initSize) + &quot;%&quot;);\n\ntCanvas.width = tCanvas.height = canvas.width = canvas.height = 0;\n\nreturn ndata;\n</code></pre><p>}</p>\n<h3 id=\"图片上传\"><a href=\"#图片上传\" class=\"headerlink\" title=\"图片上传\"></a>图片上传</h3><p>完成图片压缩后，就可以塞进formdata里进行上传了，先将base64数据转成字符串，再实例化一个ArrayBuffer，然后将字符串以8位整型的格式传入ArrayBuffer，再通过BlobBuilder或者Blob对象，将8位整型的ArrayBuffer转成二进制对象blob，然后把blob对象append到formdata里，再通过ajax发送给后台即可。</p>\n<p>getBlob:function(buffer, format) {<br>    try {<br>      return new Blob(buffer, {type: format});<br>    } catch (e) {<br>      var bb = new (window.BlobBuilder || window.WebKitBlobBuilder || window.MSBlobBuilder);<br>      buffer.forEach(function(buf) {<br>        bb.append(buf);<br>      });<br>      return bb.getBlob(format);<br>    }<br>  },<br>            // 上传图片的ajax请求<br>            async Upload2(fileData,type,index){<br>                console.log(“执行了上传的第二个函数”);<br>                var text = window.atob(fileData.split(“,”)[1]);<br>    var buffer = new Uint8Array(text.length);<br>    var pecent = 0, loop = null;<br>    for (var i = 0; i &lt; text.length; i++) {<br>      buffer[i] = text.charCodeAt(i);<br>    }<br>    var blob = this.getBlob([buffer], type);<br>                let that = this;<br>                let form = new FormData();<br>                form.append(“Filedata”,blob);<br>                await myAjax.post( apiPath.upload ,form,{<br>                    ‘headers’:{<br>                        ‘mimeType’:’multipart/form-data’<br>                    }<br>                } ).then( res =&gt; {</p>\n<pre><code>    } ).catch( e =&gt; {\n    } );\n\n\n},\n// 上传图片的ajax请求\nasync Upload(fileData,index){\n    let that = this;\n    let form = new FormData();\n    form.append(&quot;Filedata&quot;,fileData);\n    await myAjax.post( apiPath.upload ,form,{\n        &apos;headers&apos;:{\n            &apos;mimeType&apos;:&apos;multipart/form-data&apos;\n        }\n    } ).then( res =&gt; {\n\n    } ).catch( e =&gt; {\n    } );\n\n},\n</code></pre><p>本文代码提供了大概的思路以及主要的代码，具体的demo自己动手做起来吧。这格式真的是见鬼了，凑合着看吧。</p>\n","site":{"data":{}},"excerpt":"<p>本文主要讲解移动端的图片压缩上传，在移动端压缩图片并且上传主要用到filereader、canvas 以及 formdata 这三个h5的api。</p>","more":"<p>在做移动端图片上传的时候，用户传的都是手机本地图片，而本地图片一般都相对比较大，拿iphone6来说，平时拍很多图片都是一两M的，如果直接这样上传，那图片就太大了，如果用户用的是移动流量，完全把图片上传显然不是一个好办法。</p>\n<p>　　目前来说，HTML5的各种新API都在移动端的webkit上得到了较好的实现。根据查看caniuse，本demo里使用到的FileReader、Blob、Formdata对象均已在大部分移动设备浏览器中得到了实现（safari6.0+、android 3.0+），所以直接在前端压缩图片，已经成了很多移动端图片上传的必备功能了。</p>\n<p>　　在移动端压缩图片并且上传主要用到filereader、canvas 以及 formdata 这三个h5的api。逻辑并不难。整个过程就是：</p>\n<p>　　（1）用户使用input file上传图片的时候，用filereader读取用户上传的图片数据（base64格式）</p>\n<p>　　（2）把图片数据传入img对象，然后将img绘制到canvas上，再调用canvas.toDataURL对图片进行压缩</p>\n<p>　　（3）获取到压缩后的base64格式图片数据，转成二进制塞入formdata，再通过XmlHttpRequest提交formdata。</p>\n<p>　　如此三步，就完成了图片的压缩和上传。</p>\n<p>　　说起来好像挺简单，其实还是有些坑的。接下来就直接用代码进行分析：\n　　</p>\n<h3 id=\"获取图片数据\"><a href=\"#获取图片数据\" class=\"headerlink\" title=\"获取图片数据\"></a>获取图片数据</h3><p>先是获取图片数据，也就是监听input file的change事件，然后获取到上传的文件对象files，如果是多张图需将类数组的files转成数组，然后进行forEach遍历。</p>\n<p>　　接着判断文件类型，如果不是图片则不作处理。如果是图片就实例化一个filereader，以base64格式读取上传的文件数据，判断数据长度，如果大于3M的图片就调用compress方法进行压缩，否则调用upload方法进行上传。　</p>\n<pre><code>// 上传图片回显到本地并且判断超过3M走压缩否则直接上传到服务器\nchoosePhoto:function(event){\n\n            var that = this;\n            var target = event.currentTarget;\n            var file = target.files[0];\n\n            // 判断图片的类型大小\n            var imgType = /\\.jpg|\\.png|\\.jpeg/i;\n            if( !imgType.test(file.name) ){\n                this.layer(&quot;只支持图片上传，请选择正确的图片格式&quot;);\n                return;\n            }\n            // 利用fileReader 预览图片\n            if( typeof FileReader ==&quot;underfined&quot; )  {\n                this.layer(&quot;您的浏览器不支持图片预览功能，请换浏览器重试&quot;);\n\n            }else{\n                var reader = new FileReader();\n                reader.onload = function(){\n                    that.img.src = reader.result;\n                        var img = new Image();\n                    img.src = reader.result;\n                    if((file.size/1024000)&gt;3){\n                        var data = that.compress(img);\n                        that.Upload2(data,file.type,idx);\n                    }else{\n                        that.Upload(target.files[0],idx);\n                    } \n                    // input清空，防止两次请求同一个时不能选中\n                    target.value = &apos;&apos;;\n                }\n                reader.readAsDataURL(file);\n            }\n        },\n</code></pre><h3 id=\"压缩图片\"><a href=\"#压缩图片\" class=\"headerlink\" title=\"压缩图片\"></a>压缩图片</h3><p>上面做完图片数据的获取后，就可以做compress压缩图片的方法了。而压缩图片也并不是直接把图片绘制到canvas再调用一下toDataURL就行的。</p>\n<p>　　在IOS中，canvas绘制图片是有两个限制的：</p>\n<p>　　首先是图片的大小，如果图片的大小超过两百万像素，图片也是无法绘制到canvas上的，调用drawImage的时候不会报错，但是你用toDataURL获取图片数据的时候获取到的是空的图片数据。</p>\n<p>　　再者就是canvas的大小有限制，如果canvas的大小大于大概五百万像素（即宽高乘积）的时候，不仅图片画不出来，其他什么东西也都是画不出来的。</p>\n<p>　　应对第一种限制，处理办法就是瓦片绘制了。瓦片绘制，也就是将图片分割成多块绘制到canvas上，我代码里的做法是把图片分割成100万像素一块的大小，再绘制到canvas上。</p>\n<p>　　而应对第二种限制，我的处理办法是对图片的宽高进行适当压缩，我代码里为了保险起见，设的上限是四百万像素，如果图片大于四百万像素就压缩到小于四百万像素。四百万像素的图片应该够了，算起来宽高都有2000X2000了。</p>\n<p>　　如此一来就解决了IOS上的两种限制了。</p>\n<p>　　除了上面所述的限制，还有两个坑，一个就是canvas的toDataURL是只能压缩jpg的，当用户上传的图片是png的话，就需要转成jpg，也就是统一用canvas.toDataURL(‘image/jpeg’, 0.1) ， 类型统一设成jpeg，而压缩比就自己控制了。</p>\n<p>　　另一个就是如果是png转jpg，绘制到canvas上的时候，canvas存在透明区域的话，当转成jpg的时候透明区域会变成黑色，因为canvas的透明像素默认为rgba(0,0,0,0)，所以转成jpg就变成rgba(0,0,0,1)了，也就是透明背景会变成了黑色。解决办法就是绘制之前在canvas上铺一层白色的底色。\n　　</p>\n<p>   compress:function(img) {<br>    var canvas = document.createElement(“canvas”);<br>    var ctx = canvas.getContext(‘2d’);<br>    //瓦片canvas<br>    var tCanvas = document.createElement(“canvas”);<br>    var tctx = tCanvas.getContext(“2d”);<br>    var initSize = img.src.length;<br>    var width = img.width;<br>    var height = img.height;</p>\n<pre><code>//如果图片大于四百万像素，计算压缩比并将大小压至400万以下\nvar ratio;\nif ((ratio = width * height / 4000000)&gt;1) {\n    ratio = Math.sqrt(ratio);\n    width /= ratio;\n    height /= ratio;\n}else {\n    ratio = 1;\n}\n\ncanvas.width = width;\ncanvas.height = height;\n\n// 铺底色\nctx.fillStyle = &quot;#fff&quot;;\nctx.fillRect(0, 0, canvas.width, canvas.height);\n\n//如果图片像素大于100万则使用瓦片绘制\nvar count;\nif ((count = width * height / 1000000) &gt; 1) {\n    count = ~~(Math.sqrt(count)+1); //计算要分成多少块瓦片\n\n    // 计算每块瓦片的宽和高\n    var nw = ~~(width / count);\n    var nh = ~~(height / count);\n\n    tCanvas.width = nw;\n    tCanvas.height = nh;\n\n    for (var i = 0; i &lt; count; i++) {\n        for (var j = 0; j &lt; count; j++) {\n            tctx.drawImage(img, i * nw * ratio, j * nh * ratio, nw * ratio, nh * ratio, 0, 0, nw, nh);\n            ctx.drawImage(tCanvas, i * nw, j * nh, nw, nh);\n        }\n    }\n} else {\n    ctx.drawImage(img, 0, 0, width, height);\n}\n\n//进行最小压缩\nvar ndata = canvas.toDataURL(&apos;image/jpeg&apos;, 0.1);\n\nconsole.log(&apos;压缩前：&apos; + initSize);\nconsole.log(&apos;压缩后：&apos; + ndata.length);\nconsole.log(&apos;压缩率：&apos; + ~~(100 * (initSize - ndata.length) / initSize) + &quot;%&quot;);\n\ntCanvas.width = tCanvas.height = canvas.width = canvas.height = 0;\n\nreturn ndata;\n</code></pre><p>}</p>\n<h3 id=\"图片上传\"><a href=\"#图片上传\" class=\"headerlink\" title=\"图片上传\"></a>图片上传</h3><p>完成图片压缩后，就可以塞进formdata里进行上传了，先将base64数据转成字符串，再实例化一个ArrayBuffer，然后将字符串以8位整型的格式传入ArrayBuffer，再通过BlobBuilder或者Blob对象，将8位整型的ArrayBuffer转成二进制对象blob，然后把blob对象append到formdata里，再通过ajax发送给后台即可。</p>\n<p>getBlob:function(buffer, format) {<br>    try {<br>      return new Blob(buffer, {type: format});<br>    } catch (e) {<br>      var bb = new (window.BlobBuilder || window.WebKitBlobBuilder || window.MSBlobBuilder);<br>      buffer.forEach(function(buf) {<br>        bb.append(buf);<br>      });<br>      return bb.getBlob(format);<br>    }<br>  },<br>            // 上传图片的ajax请求<br>            async Upload2(fileData,type,index){<br>                console.log(“执行了上传的第二个函数”);<br>                var text = window.atob(fileData.split(“,”)[1]);<br>    var buffer = new Uint8Array(text.length);<br>    var pecent = 0, loop = null;<br>    for (var i = 0; i &lt; text.length; i++) {<br>      buffer[i] = text.charCodeAt(i);<br>    }<br>    var blob = this.getBlob([buffer], type);<br>                let that = this;<br>                let form = new FormData();<br>                form.append(“Filedata”,blob);<br>                await myAjax.post( apiPath.upload ,form,{<br>                    ‘headers’:{<br>                        ‘mimeType’:’multipart/form-data’<br>                    }<br>                } ).then( res =&gt; {</p>\n<pre><code>    } ).catch( e =&gt; {\n    } );\n\n\n},\n// 上传图片的ajax请求\nasync Upload(fileData,index){\n    let that = this;\n    let form = new FormData();\n    form.append(&quot;Filedata&quot;,fileData);\n    await myAjax.post( apiPath.upload ,form,{\n        &apos;headers&apos;:{\n            &apos;mimeType&apos;:&apos;multipart/form-data&apos;\n        }\n    } ).then( res =&gt; {\n\n    } ).catch( e =&gt; {\n    } );\n\n},\n</code></pre><p>本文代码提供了大概的思路以及主要的代码，具体的demo自己动手做起来吧。这格式真的是见鬼了，凑合着看吧。</p>"},{"title":"NPM — JavaScript 的包管理器","date":"2017-11-22T16:00:00.000Z","photos":["/img/2017/1.jpg"],"_content":"\n本文主要介绍npm的常用命令，以及如何发布一些常用的js模块化代码到npm上面方便日后的使用，和举例如何把一个vue组件打包发布到npm到最后下载到本地使用的过程。\n\n<!--more-->\n\nnpm(Node Package Manager)是node的默认模块管理器，一个命令行下的软件，用来安装和管理node模块，同时也可以管理其他开放式的js模块代码。npm有一个好处是除了下载需要的模块外还会帮我们解决依赖关系，同时下载所依赖的模块。\n\n## NPM ——  JavaScript 的包管理器\n\n### npm help\n\n``` \n    access, adduser, bin, bugs, c, cache, completion, config,\n    ddp, dedupe, deprecate, dist-tag, docs, doctor, edit,\n    explore, get, help, help-search, i, init, install,\n    install-test, it, link, list, ln, login, logout, ls,\n    outdated, owner, pack, ping, prefix, prune, publish, rb,\n    rebuild, repo, restart, root, run, run-script, s, se,\n    search, set, shrinkwrap, star, stars, start, stop, t, team,\n    test, tst, un, uninstall, unpublish, unstar, up, update, v,\n    version, view, whoami\n```\n\nnpm help 可以查看所有可使用的命令。\n### npm常用指令\n\n``` \nnpm install 名字      //该命令用于安装模块\nnpm uninstall 名字    //该命令用于卸载模块\nnpm run 名字          //该命令用于执行脚本\n```\n\n### 如何用npm发布自己的模块\n\n我们所有下载以及发布的包是存放在这个地址：https://www.npmjs.com/\n我们发布一个东西，得要有自己的标识吧，所以得先注册账号。\n#### 1.注册用户\n```\nnpm adduser\n运行该命令后会需要你依次输入\nUsername:\nPassword:\nEmail:\n```\n#### 2.检查\n接下来是需要检查一下有没有注册成功\n\n```\nnpm whoami\n```\n#### 3.建立package\n\n```\nnpm init\n//一路回车\nname: (dateFormat) datechange\nversion: (1.0.0) \ndescription: change date format\nentry point: (index.js) \ntest command: \ngit repository: https://github.com/shuangmuyingzi/dateFormat.git\nkeywords: dateformat date datechange\nauthor: lingzi\nlicense: (ISC) \nAbout to write to /Users/linziying/Downloads/npm/dateFormat/package.json:\n\n{\n  \"name\": \"datechange\",\n  \"version\": \"1.0.0\",\n  \"description\": \"change date format\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/shuangmuyingzi/dateFormat.git\"\n  },\n  \"keywords\": [\n    \"dateformat\",\n    \"date\",\n    \"datechange\"\n  ],\n  \"author\": \"lingzi\",\n  \"license\": \"ISC\",\n  \"bugs\": {\n    \"url\": \"https://github.com/shuangmuyingzi/dateFormat/issues\"\n  },\n  \"homepage\": \"https://github.com/shuangmuyingzi/dateFormat#readme\"\n}\n\n\nIs this ok? (yes) \n\n```\n然后会在该目录下多了个package.json文件\n\n#### 添加简单的日期转换格式插件\n每次后台数据接口返回的基本是时间戳，往往需要转换成常用的日期格式。那我就以一个简单的日期转换格式小插件为例。把下面代码放到package.json文件同级目录里。\n\n``` \ndate.js\n\n(function(global) {\n    var datechange = (function() {\n      \n      return function (date) {\n  \n        date = date || new Date;\n  \n        if(!(date instanceof Date)) {\n          date = new Date(date);\n        }\n  \n        if (isNaN(date)) {\n          throw TypeError('Invalid date');\n        }\n        let re = date.getFullYear() + '.' + (date.getMonth()+1) + '.' + date.getDate();\n        return re\n  \n      }\n  })()\n\n  if (typeof define === 'function' && define.amd) {\n    define(function () {\n      return datechange;\n    });\n  } else if (typeof exports === 'object') {\n    module.exports = datechange;\n  } else {\n    global.datechange = datechange;\n  }\n\n})(this);\n```\n\n\n#### 4.发布\nnpm publish\n记得在推之前先登录npm要不然会报错。如果是再次推送同一个项目记得修改版本号。 \n\n### 使用\n\n``` \nnpm install --save-dev datechange\n```\n```\nvar datechange = require('datechange');\nvar now = new Date();\nvar timeStamp = datechange(now);\n```\nOR\n\n```javascript\n<script type=\"text/javascript\" src='date.js'></script>\n\t<script type=\"text/javascript\">\n\t\tvar now = new Date();\n\t\tvar timeStamp = datechange(1511350834583);\n\t\talert(timeStamp)\n\t</script>\n```\n先安装后使用，包的名称为package.json里的name属性。\n具体代码看github:\nhttps://github.com/shuangmuyingzi/dateFormat\n\n### Vue组件如何上传到NPM\n\n#### 方式一\n\n用webpack把项目打包成JS文件，然后在package.json的 main导出该JS文件。\n\n##### 创建                   \n* vue-cli创建vue简单项目 \n\n    `vue init webpack-simple load-ling-zi`\n* 修改package.json\n\n    1. 修改`\"private\": false`\n    \n        npm默认创建的项目是私有的，如果要发布至npm必须将其公开\n    2. 添加`\"main\": \"dist/build.js\"`\n    \n        通过`import loading from 'load-ling-zi'`引用该组件时，项目会自动找到`node_modules/load-ling-zi/dist/build.js`\n*  在src加入组件代码App.vue， 并创建我们的导出文件index.js。\n   在index.js中添加：\n \n    ```\n    import load from './App.vue'\n    export default load\n    //global 情况下 自动安装\n    if (typeof window !== 'undefined' && window.Vue) {\n      window.Vue.component('load', load);\n    }\n    ```\n       \n*  因为最后我们是打包成一个js文件，所以需要修改一下配置文件`webpack.config.js`\n\n    因为不是所有使用你组件的人都是通过npm按住和impor的很多人是通过`<script>`直接引入的,我们要将libraryTarget改为umd,以及修改入口文件与设置导出文件目录以及名称。   \n    \n            entry: './src/index.js',\n            output: {\n            path: path.resolve(__dirname, './dist'),\n            publicPath: '/dist/',\n            filename: 'build.js',\n            library: 'load',\n            libraryTarget: 'umd',\n            umdNamedDefine: true\n            },\n       \n*  最后需要把`.gitignore`文件里面的`/dist`删除掉要不然上传时会忽略掉dist打包的文件。\n\n    具体代码已放到github：\n    https://github.com/shuangmuyingzi/loadingModule/tree/master/load/load-ling-zi\n    \n##### 发布\n`npm publish`，具体参考上面步骤。\n\n##### 应用\n\n1. Installation\n\n``` bash\n# install dependencies\nnpm install load-ling-zi -D\n```\n\n2. Usage\n\n```\n<loading v-if=\"loading.isShow\">\n    <span>{{ loading.text }}</span>\n</loading>\n\n<script>\n    import loading from 'load-ling-zi'\n    export default {\n        components: {\n            loading:loading\n        },\n        data () {\n            return {\n                loading:{\n                    isShow:true,\n                    text:\"加载中\"\n                },   \n            }\n        }\n    }\n</script>\n```\n\n#### 方式二\n在main里直接导出Vue组件（.vue文件）\n具体代码看这里：\nhttps://github.com/shuangmuyingzi/loadingModule/tree/master/loading\n\n### 写在最后\n关于vue组件、插件的实现方式估计还有很多的办法,本文权当抛砖引玉，水平有限，举的例子也是比较简单，一个好的组件也要考虑更多的可配置性以及通用性，数据的可配置，结构的可配置，样式的可配置等等，es里面模块化的写法也是很多，还有一些直接在`<script>`引入，所以要考虑如何导出代码能够满足更多场景的使用。\n\n","source":"_posts/npm.md","raw":"title: NPM — JavaScript 的包管理器\ndate: 2017-11-23\ntag:\n - js\n - 构建\n\nphotos:\n - /img/2017/1.jpg \n\n---\n\n本文主要介绍npm的常用命令，以及如何发布一些常用的js模块化代码到npm上面方便日后的使用，和举例如何把一个vue组件打包发布到npm到最后下载到本地使用的过程。\n\n<!--more-->\n\nnpm(Node Package Manager)是node的默认模块管理器，一个命令行下的软件，用来安装和管理node模块，同时也可以管理其他开放式的js模块代码。npm有一个好处是除了下载需要的模块外还会帮我们解决依赖关系，同时下载所依赖的模块。\n\n## NPM ——  JavaScript 的包管理器\n\n### npm help\n\n``` \n    access, adduser, bin, bugs, c, cache, completion, config,\n    ddp, dedupe, deprecate, dist-tag, docs, doctor, edit,\n    explore, get, help, help-search, i, init, install,\n    install-test, it, link, list, ln, login, logout, ls,\n    outdated, owner, pack, ping, prefix, prune, publish, rb,\n    rebuild, repo, restart, root, run, run-script, s, se,\n    search, set, shrinkwrap, star, stars, start, stop, t, team,\n    test, tst, un, uninstall, unpublish, unstar, up, update, v,\n    version, view, whoami\n```\n\nnpm help 可以查看所有可使用的命令。\n### npm常用指令\n\n``` \nnpm install 名字      //该命令用于安装模块\nnpm uninstall 名字    //该命令用于卸载模块\nnpm run 名字          //该命令用于执行脚本\n```\n\n### 如何用npm发布自己的模块\n\n我们所有下载以及发布的包是存放在这个地址：https://www.npmjs.com/\n我们发布一个东西，得要有自己的标识吧，所以得先注册账号。\n#### 1.注册用户\n```\nnpm adduser\n运行该命令后会需要你依次输入\nUsername:\nPassword:\nEmail:\n```\n#### 2.检查\n接下来是需要检查一下有没有注册成功\n\n```\nnpm whoami\n```\n#### 3.建立package\n\n```\nnpm init\n//一路回车\nname: (dateFormat) datechange\nversion: (1.0.0) \ndescription: change date format\nentry point: (index.js) \ntest command: \ngit repository: https://github.com/shuangmuyingzi/dateFormat.git\nkeywords: dateformat date datechange\nauthor: lingzi\nlicense: (ISC) \nAbout to write to /Users/linziying/Downloads/npm/dateFormat/package.json:\n\n{\n  \"name\": \"datechange\",\n  \"version\": \"1.0.0\",\n  \"description\": \"change date format\",\n  \"main\": \"index.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/shuangmuyingzi/dateFormat.git\"\n  },\n  \"keywords\": [\n    \"dateformat\",\n    \"date\",\n    \"datechange\"\n  ],\n  \"author\": \"lingzi\",\n  \"license\": \"ISC\",\n  \"bugs\": {\n    \"url\": \"https://github.com/shuangmuyingzi/dateFormat/issues\"\n  },\n  \"homepage\": \"https://github.com/shuangmuyingzi/dateFormat#readme\"\n}\n\n\nIs this ok? (yes) \n\n```\n然后会在该目录下多了个package.json文件\n\n#### 添加简单的日期转换格式插件\n每次后台数据接口返回的基本是时间戳，往往需要转换成常用的日期格式。那我就以一个简单的日期转换格式小插件为例。把下面代码放到package.json文件同级目录里。\n\n``` \ndate.js\n\n(function(global) {\n    var datechange = (function() {\n      \n      return function (date) {\n  \n        date = date || new Date;\n  \n        if(!(date instanceof Date)) {\n          date = new Date(date);\n        }\n  \n        if (isNaN(date)) {\n          throw TypeError('Invalid date');\n        }\n        let re = date.getFullYear() + '.' + (date.getMonth()+1) + '.' + date.getDate();\n        return re\n  \n      }\n  })()\n\n  if (typeof define === 'function' && define.amd) {\n    define(function () {\n      return datechange;\n    });\n  } else if (typeof exports === 'object') {\n    module.exports = datechange;\n  } else {\n    global.datechange = datechange;\n  }\n\n})(this);\n```\n\n\n#### 4.发布\nnpm publish\n记得在推之前先登录npm要不然会报错。如果是再次推送同一个项目记得修改版本号。 \n\n### 使用\n\n``` \nnpm install --save-dev datechange\n```\n```\nvar datechange = require('datechange');\nvar now = new Date();\nvar timeStamp = datechange(now);\n```\nOR\n\n```javascript\n<script type=\"text/javascript\" src='date.js'></script>\n\t<script type=\"text/javascript\">\n\t\tvar now = new Date();\n\t\tvar timeStamp = datechange(1511350834583);\n\t\talert(timeStamp)\n\t</script>\n```\n先安装后使用，包的名称为package.json里的name属性。\n具体代码看github:\nhttps://github.com/shuangmuyingzi/dateFormat\n\n### Vue组件如何上传到NPM\n\n#### 方式一\n\n用webpack把项目打包成JS文件，然后在package.json的 main导出该JS文件。\n\n##### 创建                   \n* vue-cli创建vue简单项目 \n\n    `vue init webpack-simple load-ling-zi`\n* 修改package.json\n\n    1. 修改`\"private\": false`\n    \n        npm默认创建的项目是私有的，如果要发布至npm必须将其公开\n    2. 添加`\"main\": \"dist/build.js\"`\n    \n        通过`import loading from 'load-ling-zi'`引用该组件时，项目会自动找到`node_modules/load-ling-zi/dist/build.js`\n*  在src加入组件代码App.vue， 并创建我们的导出文件index.js。\n   在index.js中添加：\n \n    ```\n    import load from './App.vue'\n    export default load\n    //global 情况下 自动安装\n    if (typeof window !== 'undefined' && window.Vue) {\n      window.Vue.component('load', load);\n    }\n    ```\n       \n*  因为最后我们是打包成一个js文件，所以需要修改一下配置文件`webpack.config.js`\n\n    因为不是所有使用你组件的人都是通过npm按住和impor的很多人是通过`<script>`直接引入的,我们要将libraryTarget改为umd,以及修改入口文件与设置导出文件目录以及名称。   \n    \n            entry: './src/index.js',\n            output: {\n            path: path.resolve(__dirname, './dist'),\n            publicPath: '/dist/',\n            filename: 'build.js',\n            library: 'load',\n            libraryTarget: 'umd',\n            umdNamedDefine: true\n            },\n       \n*  最后需要把`.gitignore`文件里面的`/dist`删除掉要不然上传时会忽略掉dist打包的文件。\n\n    具体代码已放到github：\n    https://github.com/shuangmuyingzi/loadingModule/tree/master/load/load-ling-zi\n    \n##### 发布\n`npm publish`，具体参考上面步骤。\n\n##### 应用\n\n1. Installation\n\n``` bash\n# install dependencies\nnpm install load-ling-zi -D\n```\n\n2. Usage\n\n```\n<loading v-if=\"loading.isShow\">\n    <span>{{ loading.text }}</span>\n</loading>\n\n<script>\n    import loading from 'load-ling-zi'\n    export default {\n        components: {\n            loading:loading\n        },\n        data () {\n            return {\n                loading:{\n                    isShow:true,\n                    text:\"加载中\"\n                },   \n            }\n        }\n    }\n</script>\n```\n\n#### 方式二\n在main里直接导出Vue组件（.vue文件）\n具体代码看这里：\nhttps://github.com/shuangmuyingzi/loadingModule/tree/master/loading\n\n### 写在最后\n关于vue组件、插件的实现方式估计还有很多的办法,本文权当抛砖引玉，水平有限，举的例子也是比较简单，一个好的组件也要考虑更多的可配置性以及通用性，数据的可配置，结构的可配置，样式的可配置等等，es里面模块化的写法也是很多，还有一些直接在`<script>`引入，所以要考虑如何导出代码能够满足更多场景的使用。\n\n","slug":"npm","published":1,"updated":"2018-08-28T10:16:19.196Z","_id":"cjldh03rc0009uv6xy35uya1i","comments":1,"layout":"post","link":"","content":"<p>本文主要介绍npm的常用命令，以及如何发布一些常用的js模块化代码到npm上面方便日后的使用，和举例如何把一个vue组件打包发布到npm到最后下载到本地使用的过程。</p>\n<a id=\"more\"></a>\n<p>npm(Node Package Manager)是node的默认模块管理器，一个命令行下的软件，用来安装和管理node模块，同时也可以管理其他开放式的js模块代码。npm有一个好处是除了下载需要的模块外还会帮我们解决依赖关系，同时下载所依赖的模块。</p>\n<h2 id=\"NPM-——-JavaScript-的包管理器\"><a href=\"#NPM-——-JavaScript-的包管理器\" class=\"headerlink\" title=\"NPM ——  JavaScript 的包管理器\"></a>NPM ——  JavaScript 的包管理器</h2><h3 id=\"npm-help\"><a href=\"#npm-help\" class=\"headerlink\" title=\"npm help\"></a>npm help</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">access, adduser, bin, bugs, c, cache, completion, config,</span><br><span class=\"line\">ddp, dedupe, deprecate, dist-tag, docs, doctor, edit,</span><br><span class=\"line\">explore, get, help, help-search, i, init, install,</span><br><span class=\"line\">install-test, it, link, list, ln, login, logout, ls,</span><br><span class=\"line\">outdated, owner, pack, ping, prefix, prune, publish, rb,</span><br><span class=\"line\">rebuild, repo, restart, root, run, run-script, s, se,</span><br><span class=\"line\">search, set, shrinkwrap, star, stars, start, stop, t, team,</span><br><span class=\"line\">test, tst, un, uninstall, unpublish, unstar, up, update, v,</span><br><span class=\"line\">version, view, whoami</span><br></pre></td></tr></table></figure>\n<p>npm help 可以查看所有可使用的命令。</p>\n<h3 id=\"npm常用指令\"><a href=\"#npm常用指令\" class=\"headerlink\" title=\"npm常用指令\"></a>npm常用指令</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install 名字      //该命令用于安装模块</span><br><span class=\"line\">npm uninstall 名字    //该命令用于卸载模块</span><br><span class=\"line\">npm run 名字          //该命令用于执行脚本</span><br></pre></td></tr></table></figure>\n<h3 id=\"如何用npm发布自己的模块\"><a href=\"#如何用npm发布自己的模块\" class=\"headerlink\" title=\"如何用npm发布自己的模块\"></a>如何用npm发布自己的模块</h3><p>我们所有下载以及发布的包是存放在这个地址：<a href=\"https://www.npmjs.com/\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/</a><br>我们发布一个东西，得要有自己的标识吧，所以得先注册账号。</p>\n<h4 id=\"1-注册用户\"><a href=\"#1-注册用户\" class=\"headerlink\" title=\"1.注册用户\"></a>1.注册用户</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm adduser</span><br><span class=\"line\">运行该命令后会需要你依次输入</span><br><span class=\"line\">Username:</span><br><span class=\"line\">Password:</span><br><span class=\"line\">Email:</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-检查\"><a href=\"#2-检查\" class=\"headerlink\" title=\"2.检查\"></a>2.检查</h4><p>接下来是需要检查一下有没有注册成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm whoami</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-建立package\"><a href=\"#3-建立package\" class=\"headerlink\" title=\"3.建立package\"></a>3.建立package</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm init</span><br><span class=\"line\">//一路回车</span><br><span class=\"line\">name: (dateFormat) datechange</span><br><span class=\"line\">version: (1.0.0) </span><br><span class=\"line\">description: change date format</span><br><span class=\"line\">entry point: (index.js) </span><br><span class=\"line\">test command: </span><br><span class=\"line\">git repository: https://github.com/shuangmuyingzi/dateFormat.git</span><br><span class=\"line\">keywords: dateformat date datechange</span><br><span class=\"line\">author: lingzi</span><br><span class=\"line\">license: (ISC) </span><br><span class=\"line\">About to write to /Users/linziying/Downloads/npm/dateFormat/package.json:</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;: &quot;datechange&quot;,</span><br><span class=\"line\">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;description&quot;: &quot;change date format&quot;,</span><br><span class=\"line\">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class=\"line\">  &quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;repository&quot;: &#123;</span><br><span class=\"line\">    &quot;type&quot;: &quot;git&quot;,</span><br><span class=\"line\">    &quot;url&quot;: &quot;git+https://github.com/shuangmuyingzi/dateFormat.git&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;keywords&quot;: [</span><br><span class=\"line\">    &quot;dateformat&quot;,</span><br><span class=\"line\">    &quot;date&quot;,</span><br><span class=\"line\">    &quot;datechange&quot;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;author&quot;: &quot;lingzi&quot;,</span><br><span class=\"line\">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class=\"line\">  &quot;bugs&quot;: &#123;</span><br><span class=\"line\">    &quot;url&quot;: &quot;https://github.com/shuangmuyingzi/dateFormat/issues&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;homepage&quot;: &quot;https://github.com/shuangmuyingzi/dateFormat#readme&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Is this ok? (yes)</span><br></pre></td></tr></table></figure>\n<p>然后会在该目录下多了个package.json文件</p>\n<h4 id=\"添加简单的日期转换格式插件\"><a href=\"#添加简单的日期转换格式插件\" class=\"headerlink\" title=\"添加简单的日期转换格式插件\"></a>添加简单的日期转换格式插件</h4><p>每次后台数据接口返回的基本是时间戳，往往需要转换成常用的日期格式。那我就以一个简单的日期转换格式小插件为例。把下面代码放到package.json文件同级目录里。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">date.js</span><br><span class=\"line\"></span><br><span class=\"line\">(function(global) &#123;</span><br><span class=\"line\">    var datechange = (function() &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">      return function (date) &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">        date = date || new Date;</span><br><span class=\"line\">  </span><br><span class=\"line\">        if(!(date instanceof Date)) &#123;</span><br><span class=\"line\">          date = new Date(date);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">        if (isNaN(date)) &#123;</span><br><span class=\"line\">          throw TypeError(&apos;Invalid date&apos;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        let re = date.getFullYear() + &apos;.&apos; + (date.getMonth()+1) + &apos;.&apos; + date.getDate();</span><br><span class=\"line\">        return re</span><br><span class=\"line\">  </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\">  if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123;</span><br><span class=\"line\">    define(function () &#123;</span><br><span class=\"line\">      return datechange;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125; else if (typeof exports === &apos;object&apos;) &#123;</span><br><span class=\"line\">    module.exports = datechange;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    global.datechange = datechange;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)(this);</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-发布\"><a href=\"#4-发布\" class=\"headerlink\" title=\"4.发布\"></a>4.发布</h4><p>npm publish<br>记得在推之前先登录npm要不然会报错。如果是再次推送同一个项目记得修改版本号。 </p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install --save-dev datechange</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var datechange = require(&apos;datechange&apos;);</span><br><span class=\"line\">var now = new Date();</span><br><span class=\"line\">var timeStamp = datechange(now);</span><br></pre></td></tr></table></figure>\n<p>OR</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">'date.js'</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br><span class=\"line\">\t&lt;script type=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> now = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> timeStamp = datechange(<span class=\"number\">1511350834583</span>);</span><br><span class=\"line\">\t\talert(timeStamp)</span><br><span class=\"line\">\t&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<p>先安装后使用，包的名称为package.json里的name属性。<br>具体代码看github:<br><a href=\"https://github.com/shuangmuyingzi/dateFormat\" target=\"_blank\" rel=\"noopener\">https://github.com/shuangmuyingzi/dateFormat</a></p>\n<h3 id=\"Vue组件如何上传到NPM\"><a href=\"#Vue组件如何上传到NPM\" class=\"headerlink\" title=\"Vue组件如何上传到NPM\"></a>Vue组件如何上传到NPM</h3><h4 id=\"方式一\"><a href=\"#方式一\" class=\"headerlink\" title=\"方式一\"></a>方式一</h4><p>用webpack把项目打包成JS文件，然后在package.json的 main导出该JS文件。</p>\n<h5 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h5><ul>\n<li><p>vue-cli创建vue简单项目 </p>\n<p>  <code>vue init webpack-simple load-ling-zi</code></p>\n</li>\n<li><p>修改package.json</p>\n<ol>\n<li><p>修改<code>&quot;private&quot;: false</code></p>\n<p> npm默认创建的项目是私有的，如果要发布至npm必须将其公开</p>\n</li>\n<li><p>添加<code>&quot;main&quot;: &quot;dist/build.js&quot;</code></p>\n<p> 通过<code>import loading from &#39;load-ling-zi&#39;</code>引用该组件时，项目会自动找到<code>node_modules/load-ling-zi/dist/build.js</code></p>\n</li>\n</ol>\n</li>\n<li><p>在src加入组件代码App.vue， 并创建我们的导出文件index.js。<br>在index.js中添加：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import load from &apos;./App.vue&apos;</span><br><span class=\"line\">export default load</span><br><span class=\"line\">//global 情况下 自动安装</span><br><span class=\"line\">if (typeof window !== &apos;undefined&apos; &amp;&amp; window.Vue) &#123;</span><br><span class=\"line\">  window.Vue.component(&apos;load&apos;, load);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>因为最后我们是打包成一个js文件，所以需要修改一下配置文件<code>webpack.config.js</code></p>\n<p> 因为不是所有使用你组件的人都是通过npm按住和impor的很多人是通过<code>&lt;script&gt;</code>直接引入的,我们要将libraryTarget改为umd,以及修改入口文件与设置导出文件目录以及名称。   </p>\n<pre><code>entry: &apos;./src/index.js&apos;,\noutput: {\npath: path.resolve(__dirname, &apos;./dist&apos;),\npublicPath: &apos;/dist/&apos;,\nfilename: &apos;build.js&apos;,\nlibrary: &apos;load&apos;,\nlibraryTarget: &apos;umd&apos;,\numdNamedDefine: true\n},\n</code></pre></li>\n<li><p>最后需要把<code>.gitignore</code>文件里面的<code>/dist</code>删除掉要不然上传时会忽略掉dist打包的文件。</p>\n<p> 具体代码已放到github：<br> <a href=\"https://github.com/shuangmuyingzi/loadingModule/tree/master/load/load-ling-zi\" target=\"_blank\" rel=\"noopener\">https://github.com/shuangmuyingzi/loadingModule/tree/master/load/load-ling-zi</a></p>\n</li>\n</ul>\n<h5 id=\"发布\"><a href=\"#发布\" class=\"headerlink\" title=\"发布\"></a>发布</h5><p><code>npm publish</code>，具体参考上面步骤。</p>\n<h5 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h5><ol>\n<li>Installation</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># install dependencies</span></span><br><span class=\"line\">npm install load-ling-zi -D</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>Usage</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;loading v-if=&quot;loading.isShow&quot;&gt;</span><br><span class=\"line\">    &lt;span&gt;&#123;&#123; loading.text &#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">&lt;/loading&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    import loading from &apos;load-ling-zi&apos;</span><br><span class=\"line\">    export default &#123;</span><br><span class=\"line\">        components: &#123;</span><br><span class=\"line\">            loading:loading</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        data () &#123;</span><br><span class=\"line\">            return &#123;</span><br><span class=\"line\">                loading:&#123;</span><br><span class=\"line\">                    isShow:true,</span><br><span class=\"line\">                    text:&quot;加载中&quot;</span><br><span class=\"line\">                &#125;,   </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"方式二\"><a href=\"#方式二\" class=\"headerlink\" title=\"方式二\"></a>方式二</h4><p>在main里直接导出Vue组件（.vue文件）<br>具体代码看这里：<br><a href=\"https://github.com/shuangmuyingzi/loadingModule/tree/master/loading\" target=\"_blank\" rel=\"noopener\">https://github.com/shuangmuyingzi/loadingModule/tree/master/loading</a></p>\n<h3 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h3><p>关于vue组件、插件的实现方式估计还有很多的办法,本文权当抛砖引玉，水平有限，举的例子也是比较简单，一个好的组件也要考虑更多的可配置性以及通用性，数据的可配置，结构的可配置，样式的可配置等等，es里面模块化的写法也是很多，还有一些直接在<code>&lt;script&gt;</code>引入，所以要考虑如何导出代码能够满足更多场景的使用。</p>\n","site":{"data":{}},"excerpt":"<p>本文主要介绍npm的常用命令，以及如何发布一些常用的js模块化代码到npm上面方便日后的使用，和举例如何把一个vue组件打包发布到npm到最后下载到本地使用的过程。</p>","more":"<p>npm(Node Package Manager)是node的默认模块管理器，一个命令行下的软件，用来安装和管理node模块，同时也可以管理其他开放式的js模块代码。npm有一个好处是除了下载需要的模块外还会帮我们解决依赖关系，同时下载所依赖的模块。</p>\n<h2 id=\"NPM-——-JavaScript-的包管理器\"><a href=\"#NPM-——-JavaScript-的包管理器\" class=\"headerlink\" title=\"NPM ——  JavaScript 的包管理器\"></a>NPM ——  JavaScript 的包管理器</h2><h3 id=\"npm-help\"><a href=\"#npm-help\" class=\"headerlink\" title=\"npm help\"></a>npm help</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">access, adduser, bin, bugs, c, cache, completion, config,</span><br><span class=\"line\">ddp, dedupe, deprecate, dist-tag, docs, doctor, edit,</span><br><span class=\"line\">explore, get, help, help-search, i, init, install,</span><br><span class=\"line\">install-test, it, link, list, ln, login, logout, ls,</span><br><span class=\"line\">outdated, owner, pack, ping, prefix, prune, publish, rb,</span><br><span class=\"line\">rebuild, repo, restart, root, run, run-script, s, se,</span><br><span class=\"line\">search, set, shrinkwrap, star, stars, start, stop, t, team,</span><br><span class=\"line\">test, tst, un, uninstall, unpublish, unstar, up, update, v,</span><br><span class=\"line\">version, view, whoami</span><br></pre></td></tr></table></figure>\n<p>npm help 可以查看所有可使用的命令。</p>\n<h3 id=\"npm常用指令\"><a href=\"#npm常用指令\" class=\"headerlink\" title=\"npm常用指令\"></a>npm常用指令</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install 名字      //该命令用于安装模块</span><br><span class=\"line\">npm uninstall 名字    //该命令用于卸载模块</span><br><span class=\"line\">npm run 名字          //该命令用于执行脚本</span><br></pre></td></tr></table></figure>\n<h3 id=\"如何用npm发布自己的模块\"><a href=\"#如何用npm发布自己的模块\" class=\"headerlink\" title=\"如何用npm发布自己的模块\"></a>如何用npm发布自己的模块</h3><p>我们所有下载以及发布的包是存放在这个地址：<a href=\"https://www.npmjs.com/\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/</a><br>我们发布一个东西，得要有自己的标识吧，所以得先注册账号。</p>\n<h4 id=\"1-注册用户\"><a href=\"#1-注册用户\" class=\"headerlink\" title=\"1.注册用户\"></a>1.注册用户</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm adduser</span><br><span class=\"line\">运行该命令后会需要你依次输入</span><br><span class=\"line\">Username:</span><br><span class=\"line\">Password:</span><br><span class=\"line\">Email:</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-检查\"><a href=\"#2-检查\" class=\"headerlink\" title=\"2.检查\"></a>2.检查</h4><p>接下来是需要检查一下有没有注册成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm whoami</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-建立package\"><a href=\"#3-建立package\" class=\"headerlink\" title=\"3.建立package\"></a>3.建立package</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm init</span><br><span class=\"line\">//一路回车</span><br><span class=\"line\">name: (dateFormat) datechange</span><br><span class=\"line\">version: (1.0.0) </span><br><span class=\"line\">description: change date format</span><br><span class=\"line\">entry point: (index.js) </span><br><span class=\"line\">test command: </span><br><span class=\"line\">git repository: https://github.com/shuangmuyingzi/dateFormat.git</span><br><span class=\"line\">keywords: dateformat date datechange</span><br><span class=\"line\">author: lingzi</span><br><span class=\"line\">license: (ISC) </span><br><span class=\"line\">About to write to /Users/linziying/Downloads/npm/dateFormat/package.json:</span><br><span class=\"line\"></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;name&quot;: &quot;datechange&quot;,</span><br><span class=\"line\">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class=\"line\">  &quot;description&quot;: &quot;change date format&quot;,</span><br><span class=\"line\">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class=\"line\">  &quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;repository&quot;: &#123;</span><br><span class=\"line\">    &quot;type&quot;: &quot;git&quot;,</span><br><span class=\"line\">    &quot;url&quot;: &quot;git+https://github.com/shuangmuyingzi/dateFormat.git&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;keywords&quot;: [</span><br><span class=\"line\">    &quot;dateformat&quot;,</span><br><span class=\"line\">    &quot;date&quot;,</span><br><span class=\"line\">    &quot;datechange&quot;</span><br><span class=\"line\">  ],</span><br><span class=\"line\">  &quot;author&quot;: &quot;lingzi&quot;,</span><br><span class=\"line\">  &quot;license&quot;: &quot;ISC&quot;,</span><br><span class=\"line\">  &quot;bugs&quot;: &#123;</span><br><span class=\"line\">    &quot;url&quot;: &quot;https://github.com/shuangmuyingzi/dateFormat/issues&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;homepage&quot;: &quot;https://github.com/shuangmuyingzi/dateFormat#readme&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Is this ok? (yes)</span><br></pre></td></tr></table></figure>\n<p>然后会在该目录下多了个package.json文件</p>\n<h4 id=\"添加简单的日期转换格式插件\"><a href=\"#添加简单的日期转换格式插件\" class=\"headerlink\" title=\"添加简单的日期转换格式插件\"></a>添加简单的日期转换格式插件</h4><p>每次后台数据接口返回的基本是时间戳，往往需要转换成常用的日期格式。那我就以一个简单的日期转换格式小插件为例。把下面代码放到package.json文件同级目录里。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">date.js</span><br><span class=\"line\"></span><br><span class=\"line\">(function(global) &#123;</span><br><span class=\"line\">    var datechange = (function() &#123;</span><br><span class=\"line\">      </span><br><span class=\"line\">      return function (date) &#123;</span><br><span class=\"line\">  </span><br><span class=\"line\">        date = date || new Date;</span><br><span class=\"line\">  </span><br><span class=\"line\">        if(!(date instanceof Date)) &#123;</span><br><span class=\"line\">          date = new Date(date);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">        if (isNaN(date)) &#123;</span><br><span class=\"line\">          throw TypeError(&apos;Invalid date&apos;);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        let re = date.getFullYear() + &apos;.&apos; + (date.getMonth()+1) + &apos;.&apos; + date.getDate();</span><br><span class=\"line\">        return re</span><br><span class=\"line\">  </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;)()</span><br><span class=\"line\"></span><br><span class=\"line\">  if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123;</span><br><span class=\"line\">    define(function () &#123;</span><br><span class=\"line\">      return datechange;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125; else if (typeof exports === &apos;object&apos;) &#123;</span><br><span class=\"line\">    module.exports = datechange;</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    global.datechange = datechange;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)(this);</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-发布\"><a href=\"#4-发布\" class=\"headerlink\" title=\"4.发布\"></a>4.发布</h4><p>npm publish<br>记得在推之前先登录npm要不然会报错。如果是再次推送同一个项目记得修改版本号。 </p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install --save-dev datechange</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var datechange = require(&apos;datechange&apos;);</span><br><span class=\"line\">var now = new Date();</span><br><span class=\"line\">var timeStamp = datechange(now);</span><br></pre></td></tr></table></figure>\n<p>OR</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;script type=<span class=\"string\">\"text/javascript\"</span> src=<span class=\"string\">'date.js'</span>&gt;<span class=\"xml\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span></span><br><span class=\"line\">\t&lt;script type=<span class=\"string\">\"text/javascript\"</span>&gt;</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> now = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>();</span><br><span class=\"line\">\t\t<span class=\"keyword\">var</span> timeStamp = datechange(<span class=\"number\">1511350834583</span>);</span><br><span class=\"line\">\t\talert(timeStamp)</span><br><span class=\"line\">\t&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure>\n<p>先安装后使用，包的名称为package.json里的name属性。<br>具体代码看github:<br><a href=\"https://github.com/shuangmuyingzi/dateFormat\" target=\"_blank\" rel=\"noopener\">https://github.com/shuangmuyingzi/dateFormat</a></p>\n<h3 id=\"Vue组件如何上传到NPM\"><a href=\"#Vue组件如何上传到NPM\" class=\"headerlink\" title=\"Vue组件如何上传到NPM\"></a>Vue组件如何上传到NPM</h3><h4 id=\"方式一\"><a href=\"#方式一\" class=\"headerlink\" title=\"方式一\"></a>方式一</h4><p>用webpack把项目打包成JS文件，然后在package.json的 main导出该JS文件。</p>\n<h5 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h5><ul>\n<li><p>vue-cli创建vue简单项目 </p>\n<p>  <code>vue init webpack-simple load-ling-zi</code></p>\n</li>\n<li><p>修改package.json</p>\n<ol>\n<li><p>修改<code>&quot;private&quot;: false</code></p>\n<p> npm默认创建的项目是私有的，如果要发布至npm必须将其公开</p>\n</li>\n<li><p>添加<code>&quot;main&quot;: &quot;dist/build.js&quot;</code></p>\n<p> 通过<code>import loading from &#39;load-ling-zi&#39;</code>引用该组件时，项目会自动找到<code>node_modules/load-ling-zi/dist/build.js</code></p>\n</li>\n</ol>\n</li>\n<li><p>在src加入组件代码App.vue， 并创建我们的导出文件index.js。<br>在index.js中添加：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">import load from &apos;./App.vue&apos;</span><br><span class=\"line\">export default load</span><br><span class=\"line\">//global 情况下 自动安装</span><br><span class=\"line\">if (typeof window !== &apos;undefined&apos; &amp;&amp; window.Vue) &#123;</span><br><span class=\"line\">  window.Vue.component(&apos;load&apos;, load);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>因为最后我们是打包成一个js文件，所以需要修改一下配置文件<code>webpack.config.js</code></p>\n<p> 因为不是所有使用你组件的人都是通过npm按住和impor的很多人是通过<code>&lt;script&gt;</code>直接引入的,我们要将libraryTarget改为umd,以及修改入口文件与设置导出文件目录以及名称。   </p>\n<pre><code>entry: &apos;./src/index.js&apos;,\noutput: {\npath: path.resolve(__dirname, &apos;./dist&apos;),\npublicPath: &apos;/dist/&apos;,\nfilename: &apos;build.js&apos;,\nlibrary: &apos;load&apos;,\nlibraryTarget: &apos;umd&apos;,\numdNamedDefine: true\n},\n</code></pre></li>\n<li><p>最后需要把<code>.gitignore</code>文件里面的<code>/dist</code>删除掉要不然上传时会忽略掉dist打包的文件。</p>\n<p> 具体代码已放到github：<br> <a href=\"https://github.com/shuangmuyingzi/loadingModule/tree/master/load/load-ling-zi\" target=\"_blank\" rel=\"noopener\">https://github.com/shuangmuyingzi/loadingModule/tree/master/load/load-ling-zi</a></p>\n</li>\n</ul>\n<h5 id=\"发布\"><a href=\"#发布\" class=\"headerlink\" title=\"发布\"></a>发布</h5><p><code>npm publish</code>，具体参考上面步骤。</p>\n<h5 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h5><ol>\n<li>Installation</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># install dependencies</span></span><br><span class=\"line\">npm install load-ling-zi -D</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>Usage</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;loading v-if=&quot;loading.isShow&quot;&gt;</span><br><span class=\"line\">    &lt;span&gt;&#123;&#123; loading.text &#125;&#125;&lt;/span&gt;</span><br><span class=\"line\">&lt;/loading&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    import loading from &apos;load-ling-zi&apos;</span><br><span class=\"line\">    export default &#123;</span><br><span class=\"line\">        components: &#123;</span><br><span class=\"line\">            loading:loading</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        data () &#123;</span><br><span class=\"line\">            return &#123;</span><br><span class=\"line\">                loading:&#123;</span><br><span class=\"line\">                    isShow:true,</span><br><span class=\"line\">                    text:&quot;加载中&quot;</span><br><span class=\"line\">                &#125;,   </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"方式二\"><a href=\"#方式二\" class=\"headerlink\" title=\"方式二\"></a>方式二</h4><p>在main里直接导出Vue组件（.vue文件）<br>具体代码看这里：<br><a href=\"https://github.com/shuangmuyingzi/loadingModule/tree/master/loading\" target=\"_blank\" rel=\"noopener\">https://github.com/shuangmuyingzi/loadingModule/tree/master/loading</a></p>\n<h3 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h3><p>关于vue组件、插件的实现方式估计还有很多的办法,本文权当抛砖引玉，水平有限，举的例子也是比较简单，一个好的组件也要考虑更多的可配置性以及通用性，数据的可配置，结构的可配置，样式的可配置等等，es里面模块化的写法也是很多，还有一些直接在<code>&lt;script&gt;</code>引入，所以要考虑如何导出代码能够满足更多场景的使用。</p>"},{"title":"移动端的彩蛋","date":"2018-07-27T16:00:00.000Z","photos":["/img/2017/3.jpg"],"_content":"\n本文会持续更新做移动端开发的时候遇到的坑或者是需要注意的点。\n\n<!--more-->\n# 关于图片\n## 阻止移动端浏览器点击图片会放大的几种方法\n下面介绍几种方法：\n1.在img元素上添加 onclick=\"return false\"\n\n```\n<img src=\"a.png\" onclick=\"return false\" />\n```\n2.图片用背景图的方式插入\n3.使用js事件阻止默认行为的方法！\n\n```\nvar img = document.getElementById('banner');\nimg.addEventListener('click',function(e){\n　　e.preventDefault();\n});\n```\n## 拼接图片时的缝隙问题\n一般如果图切得好是不会出现缝隙的问题，但是有时候出现的话也有办法处理。\n之前是说可以给img标签的父级元素设置font-size:0.或者去掉<img>标签之间的空格，但是现在用着发现不起作用了，然后就寻找另一些的方式。\n1、将img显示设置成  display：block;\n\n```\nimg{display：block;}\n```\n2、可以在img上加这个样式，让图片按照底部对齐，就可消除缝隙\n\n```\nvertical-align: bottom;\n```\n但是如果是背景图拼接之间的缝隙呢\n## js number长度问题引起的bug\njs number类型最长为17位，所有的语音都是有位数限制的，应该用字符串的形式\n## 微信文章阅读原文的链接跳转自带参数问题\n以下链接是从微信阅读原文进去的：\n\n```\nhttps://www.weiixn.com/dist/abc.html?from=singlemessage&isappinstalled=0#/?bianhao=1234567\n```\n这样子的话那个bianhao是拿不到的\n\n```\n(function(){\n    if( location.href.split(\"?\").length >= 3 ){\n        let path = location.href.split(\"?\")[1].split('#')[1];\n        location.href = location.href.split(\"?\")[0] + '#' + path + '?' + location.href.split(\"?\")[2];\n    }else if( location.href.split(\"?\").length == 2 ){\n        let path = location.href.split(\"?\")[1].split('#')[1];\n        if( path ){\n            location.href = location.href.split(\"?\")[0] + '#' + path;\n        }\n    }\n    // 保存链接中的渠道号到本地\n    let bianhao = commonFn.getParams()['bianhao'];\n    if( bianhao ){\n        localStorage.setItem('bianhao',bianhao);\n    }\n})();\n```\n### iPhoneX的兼容，小刘海\n参考链接：https://aotu.io/notes/2017/11/27/iphonex/\n\n```\n\n一、<meta name=\"viewport\" content=\"width=device-width, viewport-fit=cover\">\n\nbody {\n  padding-bottom: constant(safe-area-inset-bottom);\n  padding-bottom: env(safe-area-inset-bottom);\n}\n\n1padding-bottom: constant(safe-area-inset-bottom); /* 兼容 iOS < 11.2 */\n2padding-bottom: env(safe-area-inset-bottom); /* 兼容 iOS >= 11.2 */\n```\n类型二：fixed 非完全吸底元素（bottom ≠ 0），比如 “返回顶部”、“侧边广告” 等\n像这种只是位置需要对应向上调整，可以仅通过外边距 margin 来处理：\n\n```\n{\n  margin-bottom: constant(safe-area-inset-bottom);\n  margin-bottom: env(safe-area-inset-bottom);\n}\n\n```\n\n\n\n","source":"_posts/mobile.md","raw":"title: 移动端的彩蛋\ndate: 2018-07-28\ntag:\n - js\n - 移动端\n\nphotos:\n - /img/2017/3.jpg \n\n---\n\n本文会持续更新做移动端开发的时候遇到的坑或者是需要注意的点。\n\n<!--more-->\n# 关于图片\n## 阻止移动端浏览器点击图片会放大的几种方法\n下面介绍几种方法：\n1.在img元素上添加 onclick=\"return false\"\n\n```\n<img src=\"a.png\" onclick=\"return false\" />\n```\n2.图片用背景图的方式插入\n3.使用js事件阻止默认行为的方法！\n\n```\nvar img = document.getElementById('banner');\nimg.addEventListener('click',function(e){\n　　e.preventDefault();\n});\n```\n## 拼接图片时的缝隙问题\n一般如果图切得好是不会出现缝隙的问题，但是有时候出现的话也有办法处理。\n之前是说可以给img标签的父级元素设置font-size:0.或者去掉<img>标签之间的空格，但是现在用着发现不起作用了，然后就寻找另一些的方式。\n1、将img显示设置成  display：block;\n\n```\nimg{display：block;}\n```\n2、可以在img上加这个样式，让图片按照底部对齐，就可消除缝隙\n\n```\nvertical-align: bottom;\n```\n但是如果是背景图拼接之间的缝隙呢\n## js number长度问题引起的bug\njs number类型最长为17位，所有的语音都是有位数限制的，应该用字符串的形式\n## 微信文章阅读原文的链接跳转自带参数问题\n以下链接是从微信阅读原文进去的：\n\n```\nhttps://www.weiixn.com/dist/abc.html?from=singlemessage&isappinstalled=0#/?bianhao=1234567\n```\n这样子的话那个bianhao是拿不到的\n\n```\n(function(){\n    if( location.href.split(\"?\").length >= 3 ){\n        let path = location.href.split(\"?\")[1].split('#')[1];\n        location.href = location.href.split(\"?\")[0] + '#' + path + '?' + location.href.split(\"?\")[2];\n    }else if( location.href.split(\"?\").length == 2 ){\n        let path = location.href.split(\"?\")[1].split('#')[1];\n        if( path ){\n            location.href = location.href.split(\"?\")[0] + '#' + path;\n        }\n    }\n    // 保存链接中的渠道号到本地\n    let bianhao = commonFn.getParams()['bianhao'];\n    if( bianhao ){\n        localStorage.setItem('bianhao',bianhao);\n    }\n})();\n```\n### iPhoneX的兼容，小刘海\n参考链接：https://aotu.io/notes/2017/11/27/iphonex/\n\n```\n\n一、<meta name=\"viewport\" content=\"width=device-width, viewport-fit=cover\">\n\nbody {\n  padding-bottom: constant(safe-area-inset-bottom);\n  padding-bottom: env(safe-area-inset-bottom);\n}\n\n1padding-bottom: constant(safe-area-inset-bottom); /* 兼容 iOS < 11.2 */\n2padding-bottom: env(safe-area-inset-bottom); /* 兼容 iOS >= 11.2 */\n```\n类型二：fixed 非完全吸底元素（bottom ≠ 0），比如 “返回顶部”、“侧边广告” 等\n像这种只是位置需要对应向上调整，可以仅通过外边距 margin 来处理：\n\n```\n{\n  margin-bottom: constant(safe-area-inset-bottom);\n  margin-bottom: env(safe-area-inset-bottom);\n}\n\n```\n\n\n\n","slug":"mobile","published":1,"updated":"2018-08-28T10:16:25.878Z","_id":"cjldh03rg000auv6xnp5dqyek","comments":1,"layout":"post","link":"","content":"<p>本文会持续更新做移动端开发的时候遇到的坑或者是需要注意的点。</p>\n<a id=\"more\"></a>\n<h1 id=\"关于图片\"><a href=\"#关于图片\" class=\"headerlink\" title=\"关于图片\"></a>关于图片</h1><h2 id=\"阻止移动端浏览器点击图片会放大的几种方法\"><a href=\"#阻止移动端浏览器点击图片会放大的几种方法\" class=\"headerlink\" title=\"阻止移动端浏览器点击图片会放大的几种方法\"></a>阻止移动端浏览器点击图片会放大的几种方法</h2><p>下面介绍几种方法：<br>1.在img元素上添加 onclick=”return false”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;img src=&quot;a.png&quot; onclick=&quot;return false&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<p>2.图片用背景图的方式插入<br>3.使用js事件阻止默认行为的方法！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var img = document.getElementById(&apos;banner&apos;);</span><br><span class=\"line\">img.addEventListener(&apos;click&apos;,function(e)&#123;</span><br><span class=\"line\">　　e.preventDefault();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"拼接图片时的缝隙问题\"><a href=\"#拼接图片时的缝隙问题\" class=\"headerlink\" title=\"拼接图片时的缝隙问题\"></a>拼接图片时的缝隙问题</h2><p>一般如果图切得好是不会出现缝隙的问题，但是有时候出现的话也有办法处理。<br>之前是说可以给img标签的父级元素设置font-size:0.或者去掉<img>标签之间的空格，但是现在用着发现不起作用了，然后就寻找另一些的方式。<br>1、将img显示设置成  display：block;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">img&#123;display：block;&#125;</span><br></pre></td></tr></table></figure>\n<p>2、可以在img上加这个样式，让图片按照底部对齐，就可消除缝隙</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">vertical-align: bottom;</span><br></pre></td></tr></table></figure>\n<p>但是如果是背景图拼接之间的缝隙呢</p>\n<h2 id=\"js-number长度问题引起的bug\"><a href=\"#js-number长度问题引起的bug\" class=\"headerlink\" title=\"js number长度问题引起的bug\"></a>js number长度问题引起的bug</h2><p>js number类型最长为17位，所有的语音都是有位数限制的，应该用字符串的形式</p>\n<h2 id=\"微信文章阅读原文的链接跳转自带参数问题\"><a href=\"#微信文章阅读原文的链接跳转自带参数问题\" class=\"headerlink\" title=\"微信文章阅读原文的链接跳转自带参数问题\"></a>微信文章阅读原文的链接跳转自带参数问题</h2><p>以下链接是从微信阅读原文进去的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://www.weiixn.com/dist/abc.html?from=singlemessage&amp;isappinstalled=0#/?bianhao=1234567</span><br></pre></td></tr></table></figure>\n<p>这样子的话那个bianhao是拿不到的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">(function()&#123;</span><br><span class=\"line\">    if( location.href.split(&quot;?&quot;).length &gt;= 3 )&#123;</span><br><span class=\"line\">        let path = location.href.split(&quot;?&quot;)[1].split(&apos;#&apos;)[1];</span><br><span class=\"line\">        location.href = location.href.split(&quot;?&quot;)[0] + &apos;#&apos; + path + &apos;?&apos; + location.href.split(&quot;?&quot;)[2];</span><br><span class=\"line\">    &#125;else if( location.href.split(&quot;?&quot;).length == 2 )&#123;</span><br><span class=\"line\">        let path = location.href.split(&quot;?&quot;)[1].split(&apos;#&apos;)[1];</span><br><span class=\"line\">        if( path )&#123;</span><br><span class=\"line\">            location.href = location.href.split(&quot;?&quot;)[0] + &apos;#&apos; + path;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 保存链接中的渠道号到本地</span><br><span class=\"line\">    let bianhao = commonFn.getParams()[&apos;bianhao&apos;];</span><br><span class=\"line\">    if( bianhao )&#123;</span><br><span class=\"line\">        localStorage.setItem(&apos;bianhao&apos;,bianhao);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<h3 id=\"iPhoneX的兼容，小刘海\"><a href=\"#iPhoneX的兼容，小刘海\" class=\"headerlink\" title=\"iPhoneX的兼容，小刘海\"></a>iPhoneX的兼容，小刘海</h3><p>参考链接：<a href=\"https://aotu.io/notes/2017/11/27/iphonex/\" target=\"_blank\" rel=\"noopener\">https://aotu.io/notes/2017/11/27/iphonex/</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">一、&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, viewport-fit=cover&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">body &#123;</span><br><span class=\"line\">  padding-bottom: constant(safe-area-inset-bottom);</span><br><span class=\"line\">  padding-bottom: env(safe-area-inset-bottom);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">1padding-bottom: constant(safe-area-inset-bottom); /* 兼容 iOS &lt; 11.2 */</span><br><span class=\"line\">2padding-bottom: env(safe-area-inset-bottom); /* 兼容 iOS &gt;= 11.2 */</span><br></pre></td></tr></table></figure>\n<p>类型二：fixed 非完全吸底元素（bottom ≠ 0），比如 “返回顶部”、“侧边广告” 等<br>像这种只是位置需要对应向上调整，可以仅通过外边距 margin 来处理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  margin-bottom: constant(safe-area-inset-bottom);</span><br><span class=\"line\">  margin-bottom: env(safe-area-inset-bottom);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>本文会持续更新做移动端开发的时候遇到的坑或者是需要注意的点。</p>","more":"<h1 id=\"关于图片\"><a href=\"#关于图片\" class=\"headerlink\" title=\"关于图片\"></a>关于图片</h1><h2 id=\"阻止移动端浏览器点击图片会放大的几种方法\"><a href=\"#阻止移动端浏览器点击图片会放大的几种方法\" class=\"headerlink\" title=\"阻止移动端浏览器点击图片会放大的几种方法\"></a>阻止移动端浏览器点击图片会放大的几种方法</h2><p>下面介绍几种方法：<br>1.在img元素上添加 onclick=”return false”</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;img src=&quot;a.png&quot; onclick=&quot;return false&quot; /&gt;</span><br></pre></td></tr></table></figure>\n<p>2.图片用背景图的方式插入<br>3.使用js事件阻止默认行为的方法！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var img = document.getElementById(&apos;banner&apos;);</span><br><span class=\"line\">img.addEventListener(&apos;click&apos;,function(e)&#123;</span><br><span class=\"line\">　　e.preventDefault();</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"拼接图片时的缝隙问题\"><a href=\"#拼接图片时的缝隙问题\" class=\"headerlink\" title=\"拼接图片时的缝隙问题\"></a>拼接图片时的缝隙问题</h2><p>一般如果图切得好是不会出现缝隙的问题，但是有时候出现的话也有办法处理。<br>之前是说可以给img标签的父级元素设置font-size:0.或者去掉<img>标签之间的空格，但是现在用着发现不起作用了，然后就寻找另一些的方式。<br>1、将img显示设置成  display：block;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">img&#123;display：block;&#125;</span><br></pre></td></tr></table></figure>\n<p>2、可以在img上加这个样式，让图片按照底部对齐，就可消除缝隙</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">vertical-align: bottom;</span><br></pre></td></tr></table></figure>\n<p>但是如果是背景图拼接之间的缝隙呢</p>\n<h2 id=\"js-number长度问题引起的bug\"><a href=\"#js-number长度问题引起的bug\" class=\"headerlink\" title=\"js number长度问题引起的bug\"></a>js number长度问题引起的bug</h2><p>js number类型最长为17位，所有的语音都是有位数限制的，应该用字符串的形式</p>\n<h2 id=\"微信文章阅读原文的链接跳转自带参数问题\"><a href=\"#微信文章阅读原文的链接跳转自带参数问题\" class=\"headerlink\" title=\"微信文章阅读原文的链接跳转自带参数问题\"></a>微信文章阅读原文的链接跳转自带参数问题</h2><p>以下链接是从微信阅读原文进去的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://www.weiixn.com/dist/abc.html?from=singlemessage&amp;isappinstalled=0#/?bianhao=1234567</span><br></pre></td></tr></table></figure>\n<p>这样子的话那个bianhao是拿不到的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">(function()&#123;</span><br><span class=\"line\">    if( location.href.split(&quot;?&quot;).length &gt;= 3 )&#123;</span><br><span class=\"line\">        let path = location.href.split(&quot;?&quot;)[1].split(&apos;#&apos;)[1];</span><br><span class=\"line\">        location.href = location.href.split(&quot;?&quot;)[0] + &apos;#&apos; + path + &apos;?&apos; + location.href.split(&quot;?&quot;)[2];</span><br><span class=\"line\">    &#125;else if( location.href.split(&quot;?&quot;).length == 2 )&#123;</span><br><span class=\"line\">        let path = location.href.split(&quot;?&quot;)[1].split(&apos;#&apos;)[1];</span><br><span class=\"line\">        if( path )&#123;</span><br><span class=\"line\">            location.href = location.href.split(&quot;?&quot;)[0] + &apos;#&apos; + path;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    // 保存链接中的渠道号到本地</span><br><span class=\"line\">    let bianhao = commonFn.getParams()[&apos;bianhao&apos;];</span><br><span class=\"line\">    if( bianhao )&#123;</span><br><span class=\"line\">        localStorage.setItem(&apos;bianhao&apos;,bianhao);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<h3 id=\"iPhoneX的兼容，小刘海\"><a href=\"#iPhoneX的兼容，小刘海\" class=\"headerlink\" title=\"iPhoneX的兼容，小刘海\"></a>iPhoneX的兼容，小刘海</h3><p>参考链接：<a href=\"https://aotu.io/notes/2017/11/27/iphonex/\" target=\"_blank\" rel=\"noopener\">https://aotu.io/notes/2017/11/27/iphonex/</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">一、&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, viewport-fit=cover&quot;&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">body &#123;</span><br><span class=\"line\">  padding-bottom: constant(safe-area-inset-bottom);</span><br><span class=\"line\">  padding-bottom: env(safe-area-inset-bottom);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">1padding-bottom: constant(safe-area-inset-bottom); /* 兼容 iOS &lt; 11.2 */</span><br><span class=\"line\">2padding-bottom: env(safe-area-inset-bottom); /* 兼容 iOS &gt;= 11.2 */</span><br></pre></td></tr></table></figure>\n<p>类型二：fixed 非完全吸底元素（bottom ≠ 0），比如 “返回顶部”、“侧边广告” 等<br>像这种只是位置需要对应向上调整，可以仅通过外边距 margin 来处理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  margin-bottom: constant(safe-area-inset-bottom);</span><br><span class=\"line\">  margin-bottom: env(safe-area-inset-bottom);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Promise学习","date":"2018-05-27T16:00:00.000Z","photos":["/img/2017/5.jpg"],"_content":"\nPromise对象是一个构造函数，其接受一个函数作为参数，resolve、reject为这个函数的参数，函数内部一般为异步执行的代码，resolve作为异步执行完成之后成功的回调，reject作为异步执行抛错的回调。Promise构造函数可以理解为执行异步的过程，其resolve和reject为执行异步调用结果的回调函数。\n\n<!--more-->\n\n### 初识Promise\nPromise对象是一个构造函数，其接受一个函数作为参数，resolve、reject为这个函数的参数，函数内部一般为异步执行的代码，resolve作为异步执行完成之后成功的回调，reject作为异步执行抛错的回调。Promise构造函数可以理解为执行异步的过程，其resolve和reject为执行异步调用结果的回调函数。\n```\n// 代码1\nvar p = new Promise((resolve, reject) => {\n  // 执行一系列的异步执行\n  // some codes...\n  if (true) {\n    resolve(\"异步执行成功\");\n  } else {\n    reject(\"异步执行抛错\");\n  }\n}); // fulfilled: 异步执行成功 ; 非fulfilled: 异步执行抛错\n```\n\n### Promise的异步处理\n\n#### then和catch的使用\nPromise构造函数返回一个异步执行之后的promise对象，该对象对异步的结果进一步处理。\n\n```\n// 代码2\np\n  .then((res) => {\n    // try catch 手动抛错\n    try {\n      // console.log(\"异步返回成功状态\");\n      throw Error(\"错误代码\");\n    } catch(e) {\n      console.log(\"执行catch\");\n      return Promise.reject(e);\n    }\n  })\n  .catch((res) => {\n    console.log(res); // 输出上一个 then 中 catch 的 e\n    return \"这里由错误信息过去的数据\";\n  })\n  .then((res) => {\n    console.log(res); // 若上一个catch执行，输出：这里由错误信息过去的数据\n  })\n```\n以上代码执行结果：\n\n```\n# 结果1\n执行catch\nError: 错误代码\n    at p.then (**/promise.js:77:10)\n    at process._tickCallback (internal/process/next_tick.js:109:7)\n    at Module.runMain (module.js:607:11)\n    at run (bootstrap_node.js:423:7)\n    at startup (bootstrap_node.js:147:9)\n    at bootstrap_node.js:538:3\n这里由错误信息过去的数据\n```\n### promise对象的链式调用\n由代码2可以看出，promise对象状态为resolve的时候，执行then方法，而且在不抛错情况下会持续执行链式调用的then方法，若then方法抛出异常或者抛出返回Promise.reject()方法，会转到执行catch方法，若catch方法返回的不是Promise.reject()方法或者不抛出异常，则所有使用return返回的数据都会作为参数传给下一个then函数参数的参数，即代码2中的最后一个then方法指定函数参数的res是上一个catch所return的数据。\n\n```\nvar p = new Promise((resolve, reject) => {\n  resolve(\"ok\");\n});\np.then((msg) => {\n  console.log(msg);\n  return Promise.reject(\"then01抛错\");\n}).catch((errMsg) => {\n  console.warn(errMsg);\n}).then(() => {\n  console.log(\"then02再执行\");\n}).then(() => {\n  console.log(\"then03再执行\");\n  return Promise.reject(\"then03抛错\");\n}).catch((errMsg) => {\n  console.warn(errMsg);\n  return \"catch02 return 给下一个then指定方法的值\";\n}).then((msg) => {\n  console.log(msg);\n});\n```\n运行结果如下：\n\n```\nok\nthen01抛错\nthen02再执行\nthen03再执行\nthen03抛错\ncatch02 return 给下一个then指定方法的值\n```\n这是因为then方法和catch方法返回的都是一个promise对象。then方法指定的回调函数抛出错误会被下一个catch方法捕获，多个then方法执行也是如此。catch方法会捕获上一个catch方法（如果有的话）之后抛错的错误。\n\n换言之，无论是then方法还是catch方法,返回的都是一个promise对象，其状态取决于上一个方法指定的函数是否顺利执行或者没有返回Promise.reject（）。\n\n### Promise状态\n一旦Promise的状态变为resolved或者rejected，就会永久保持该状态，不会再变。\n\n```\n var p = new Promise((resolve, reject) => {\n  resolve(\"ok\");\n  throw new Error(\"wrong\");\n});\np.then((msg) => {\n  console.log(msg);\n}).catch((errMsg) => {\n  console.warn(errMsg);\n});\n\n// ok\n```\n在Promise的参数函数中，由于先断定了resolved状态，所以在之后只会执行then函数，后面抛出的错误会等于没抛出来。\n\n另外，“事件循环”会对抛出的结果有影响。\n\n```\nvar p = new Promise((resolve, reject) => {\n  resolve(\"ok\");\n  setTimeout(() => {\n    throw new Error(\"wrong\");\n  }, 0);\n});\np.then((msg) => {\n  console.log(msg);\n}).catch((errMsg) => {\n  console.warn(errMsg);\n});\n\n// ok\n\n// 浏览器抛出的错误\n// index.js:4 Uncaught Error: wrong\n//    at setTimeout (index.js:4)\n// setTimeout    @    index.js:4\n```\n在本轮“事件循环”中，promise对象p先执行，所以构造函数Promise的指定函数先输出‘ok’；在进入到下一次的“事件循环”的时候，由于Promise函数体已经执行完毕，故后面抛出的错误是在Promise函数体外抛出的，Promise函数体无法捕获到这个错误。\n\n#### Promise.resolve()\nPromise.resolve()接受一个参数，其返回一个promise对象的状态会因为传入的参数的不同而不同。\n\n参数分别以下几种情况：\n空\n\n返回一个状态为resolved的promise对象，也就是下一步会执行then方法。\n\n```\nvar p = Promise.resolve();\n\np.then((res) => {\n  console.log(\"then\");\n}).catch((res) => {\n  console.log(\"catch\");\n});\n\n// then\n```\nthenable对象\n\n```\nvar thenable = {\n  then: function (resolve, reject) {\n    console.log(\"立即执行thenable的then的方法\" + Date.now());\n    resolve(\"断定之后的信息\");\n  }\n}\n\nvar p = Promise.resolve(thenable);\n\np.then((res) => {\n  console.log(res);\n});\n\n// 立即执行thenable的then的方法1494485393447\n// 断定之后的信息\n\n// 相当于\n\nvar p = new Promise(function (resolve, reject) {\n  console.log(\"立即执行thenable的then的方法\" + Date.now());\n  resolve(\"断定之后的信息\");\n});\n\np.then((res) => {\n  console.log(res);\n});\n\n// 立即执行thenable的then的方法1494485454503\n// 断定之后的信息\n```\nthenable对象作为参数，在执行Promise.resolve(thenable)方法的时候，会立即执行thenable对象中的then方法，并且其返回的Promise对象的状态取决于thenable对象的then方法执行的是resolve()还是reject()。这种情况下，就相当于Promise构造函数以thenable对象的then方法作为参数，实例化一个Promise实例。\n\n一个非Promise对象，且不含有then方法的对象------非thenable对象\n\n```\nvar p = Promise.resolve({\n  a: 1\n});\np.then((res) => {\n  console.log(res);\n});\n\n// { a: 1 }\n\nvar p01 = Promise.resolve('Hello Promise!');\np01.then((res) => {\n  console.log(res);\n});\n\n// Hello Promise!\n```\n这种情况下，Promise.resolve()的状态为resolved，其接收的参数会作为then方法指定函数的参数。\n\nPromise对象\n\n```\nvar p01 = new Promise((resolve, reject) => {\n  reject('Throw some error! Come on! You bite me.');\n});\n\nvar p = Promise.resolve(p01);\n\np.then((res) => {\n  console.log(\"这是then方法\");\n}).catch((errMsg) => {\n  console.log(errMsg);\n});\n\n// Throw some error! Come on! You bite me.\n```\n传入的是一个Promise对象，Promise.resolve()返回的对象的状态就是传入的Promise对象的状态。\n\n\n#### Promise.reject()\nPromise.reject(reason)方法同样返回一个状态为rejected的Promise对象实例。值得注意的是，参数reason(Promise状态rejected的原因)不论是什么值，都会传给返回的Promise对象的catch方法指定的函数作为参数。\n\n```\nvar p = Promise.reject('Throw some error! Come on! You bite me.');\n\np.then((res) => {\n  console.log(\"这是then方法\");\n}).catch((errMsg) => {\n  console.log(errMsg);\n});\n\n// Throw some error! Come on! You bite me\n```\n#### promise对象的使用场景——图片加载\n\n```\nvar imgPromise = function (url) {\n  return new Promise((resolve, reject) => {\n    var img = new Image();\n    img.src = url;\n    img.onload = resolve;\n    img.onerror = reject;\n  });\n}\nimgPromise(\"http://imgurl\")\n  .then((res) => {\n    console.log(\"图片加载完成\");\n  })\n  .catch((res) => {\n    console.log(\"图片加载失败\");\n  })：\n```\n\n\n\n\n\n\n","source":"_posts/promise.md","raw":"title: Promise学习\ndate: 2018-05-28\ntag:\n - js\n - promise\n\nphotos:\n - /img/2017/5.jpg \n\n---\n\nPromise对象是一个构造函数，其接受一个函数作为参数，resolve、reject为这个函数的参数，函数内部一般为异步执行的代码，resolve作为异步执行完成之后成功的回调，reject作为异步执行抛错的回调。Promise构造函数可以理解为执行异步的过程，其resolve和reject为执行异步调用结果的回调函数。\n\n<!--more-->\n\n### 初识Promise\nPromise对象是一个构造函数，其接受一个函数作为参数，resolve、reject为这个函数的参数，函数内部一般为异步执行的代码，resolve作为异步执行完成之后成功的回调，reject作为异步执行抛错的回调。Promise构造函数可以理解为执行异步的过程，其resolve和reject为执行异步调用结果的回调函数。\n```\n// 代码1\nvar p = new Promise((resolve, reject) => {\n  // 执行一系列的异步执行\n  // some codes...\n  if (true) {\n    resolve(\"异步执行成功\");\n  } else {\n    reject(\"异步执行抛错\");\n  }\n}); // fulfilled: 异步执行成功 ; 非fulfilled: 异步执行抛错\n```\n\n### Promise的异步处理\n\n#### then和catch的使用\nPromise构造函数返回一个异步执行之后的promise对象，该对象对异步的结果进一步处理。\n\n```\n// 代码2\np\n  .then((res) => {\n    // try catch 手动抛错\n    try {\n      // console.log(\"异步返回成功状态\");\n      throw Error(\"错误代码\");\n    } catch(e) {\n      console.log(\"执行catch\");\n      return Promise.reject(e);\n    }\n  })\n  .catch((res) => {\n    console.log(res); // 输出上一个 then 中 catch 的 e\n    return \"这里由错误信息过去的数据\";\n  })\n  .then((res) => {\n    console.log(res); // 若上一个catch执行，输出：这里由错误信息过去的数据\n  })\n```\n以上代码执行结果：\n\n```\n# 结果1\n执行catch\nError: 错误代码\n    at p.then (**/promise.js:77:10)\n    at process._tickCallback (internal/process/next_tick.js:109:7)\n    at Module.runMain (module.js:607:11)\n    at run (bootstrap_node.js:423:7)\n    at startup (bootstrap_node.js:147:9)\n    at bootstrap_node.js:538:3\n这里由错误信息过去的数据\n```\n### promise对象的链式调用\n由代码2可以看出，promise对象状态为resolve的时候，执行then方法，而且在不抛错情况下会持续执行链式调用的then方法，若then方法抛出异常或者抛出返回Promise.reject()方法，会转到执行catch方法，若catch方法返回的不是Promise.reject()方法或者不抛出异常，则所有使用return返回的数据都会作为参数传给下一个then函数参数的参数，即代码2中的最后一个then方法指定函数参数的res是上一个catch所return的数据。\n\n```\nvar p = new Promise((resolve, reject) => {\n  resolve(\"ok\");\n});\np.then((msg) => {\n  console.log(msg);\n  return Promise.reject(\"then01抛错\");\n}).catch((errMsg) => {\n  console.warn(errMsg);\n}).then(() => {\n  console.log(\"then02再执行\");\n}).then(() => {\n  console.log(\"then03再执行\");\n  return Promise.reject(\"then03抛错\");\n}).catch((errMsg) => {\n  console.warn(errMsg);\n  return \"catch02 return 给下一个then指定方法的值\";\n}).then((msg) => {\n  console.log(msg);\n});\n```\n运行结果如下：\n\n```\nok\nthen01抛错\nthen02再执行\nthen03再执行\nthen03抛错\ncatch02 return 给下一个then指定方法的值\n```\n这是因为then方法和catch方法返回的都是一个promise对象。then方法指定的回调函数抛出错误会被下一个catch方法捕获，多个then方法执行也是如此。catch方法会捕获上一个catch方法（如果有的话）之后抛错的错误。\n\n换言之，无论是then方法还是catch方法,返回的都是一个promise对象，其状态取决于上一个方法指定的函数是否顺利执行或者没有返回Promise.reject（）。\n\n### Promise状态\n一旦Promise的状态变为resolved或者rejected，就会永久保持该状态，不会再变。\n\n```\n var p = new Promise((resolve, reject) => {\n  resolve(\"ok\");\n  throw new Error(\"wrong\");\n});\np.then((msg) => {\n  console.log(msg);\n}).catch((errMsg) => {\n  console.warn(errMsg);\n});\n\n// ok\n```\n在Promise的参数函数中，由于先断定了resolved状态，所以在之后只会执行then函数，后面抛出的错误会等于没抛出来。\n\n另外，“事件循环”会对抛出的结果有影响。\n\n```\nvar p = new Promise((resolve, reject) => {\n  resolve(\"ok\");\n  setTimeout(() => {\n    throw new Error(\"wrong\");\n  }, 0);\n});\np.then((msg) => {\n  console.log(msg);\n}).catch((errMsg) => {\n  console.warn(errMsg);\n});\n\n// ok\n\n// 浏览器抛出的错误\n// index.js:4 Uncaught Error: wrong\n//    at setTimeout (index.js:4)\n// setTimeout    @    index.js:4\n```\n在本轮“事件循环”中，promise对象p先执行，所以构造函数Promise的指定函数先输出‘ok’；在进入到下一次的“事件循环”的时候，由于Promise函数体已经执行完毕，故后面抛出的错误是在Promise函数体外抛出的，Promise函数体无法捕获到这个错误。\n\n#### Promise.resolve()\nPromise.resolve()接受一个参数，其返回一个promise对象的状态会因为传入的参数的不同而不同。\n\n参数分别以下几种情况：\n空\n\n返回一个状态为resolved的promise对象，也就是下一步会执行then方法。\n\n```\nvar p = Promise.resolve();\n\np.then((res) => {\n  console.log(\"then\");\n}).catch((res) => {\n  console.log(\"catch\");\n});\n\n// then\n```\nthenable对象\n\n```\nvar thenable = {\n  then: function (resolve, reject) {\n    console.log(\"立即执行thenable的then的方法\" + Date.now());\n    resolve(\"断定之后的信息\");\n  }\n}\n\nvar p = Promise.resolve(thenable);\n\np.then((res) => {\n  console.log(res);\n});\n\n// 立即执行thenable的then的方法1494485393447\n// 断定之后的信息\n\n// 相当于\n\nvar p = new Promise(function (resolve, reject) {\n  console.log(\"立即执行thenable的then的方法\" + Date.now());\n  resolve(\"断定之后的信息\");\n});\n\np.then((res) => {\n  console.log(res);\n});\n\n// 立即执行thenable的then的方法1494485454503\n// 断定之后的信息\n```\nthenable对象作为参数，在执行Promise.resolve(thenable)方法的时候，会立即执行thenable对象中的then方法，并且其返回的Promise对象的状态取决于thenable对象的then方法执行的是resolve()还是reject()。这种情况下，就相当于Promise构造函数以thenable对象的then方法作为参数，实例化一个Promise实例。\n\n一个非Promise对象，且不含有then方法的对象------非thenable对象\n\n```\nvar p = Promise.resolve({\n  a: 1\n});\np.then((res) => {\n  console.log(res);\n});\n\n// { a: 1 }\n\nvar p01 = Promise.resolve('Hello Promise!');\np01.then((res) => {\n  console.log(res);\n});\n\n// Hello Promise!\n```\n这种情况下，Promise.resolve()的状态为resolved，其接收的参数会作为then方法指定函数的参数。\n\nPromise对象\n\n```\nvar p01 = new Promise((resolve, reject) => {\n  reject('Throw some error! Come on! You bite me.');\n});\n\nvar p = Promise.resolve(p01);\n\np.then((res) => {\n  console.log(\"这是then方法\");\n}).catch((errMsg) => {\n  console.log(errMsg);\n});\n\n// Throw some error! Come on! You bite me.\n```\n传入的是一个Promise对象，Promise.resolve()返回的对象的状态就是传入的Promise对象的状态。\n\n\n#### Promise.reject()\nPromise.reject(reason)方法同样返回一个状态为rejected的Promise对象实例。值得注意的是，参数reason(Promise状态rejected的原因)不论是什么值，都会传给返回的Promise对象的catch方法指定的函数作为参数。\n\n```\nvar p = Promise.reject('Throw some error! Come on! You bite me.');\n\np.then((res) => {\n  console.log(\"这是then方法\");\n}).catch((errMsg) => {\n  console.log(errMsg);\n});\n\n// Throw some error! Come on! You bite me\n```\n#### promise对象的使用场景——图片加载\n\n```\nvar imgPromise = function (url) {\n  return new Promise((resolve, reject) => {\n    var img = new Image();\n    img.src = url;\n    img.onload = resolve;\n    img.onerror = reject;\n  });\n}\nimgPromise(\"http://imgurl\")\n  .then((res) => {\n    console.log(\"图片加载完成\");\n  })\n  .catch((res) => {\n    console.log(\"图片加载失败\");\n  })：\n```\n\n\n\n\n\n\n","slug":"promise","published":1,"updated":"2018-08-28T10:16:11.020Z","_id":"cjldh03rh000cuv6x0m70iwv3","comments":1,"layout":"post","link":"","content":"<p>Promise对象是一个构造函数，其接受一个函数作为参数，resolve、reject为这个函数的参数，函数内部一般为异步执行的代码，resolve作为异步执行完成之后成功的回调，reject作为异步执行抛错的回调。Promise构造函数可以理解为执行异步的过程，其resolve和reject为执行异步调用结果的回调函数。</p>\n<a id=\"more\"></a>\n<h3 id=\"初识Promise\"><a href=\"#初识Promise\" class=\"headerlink\" title=\"初识Promise\"></a>初识Promise</h3><p>Promise对象是一个构造函数，其接受一个函数作为参数，resolve、reject为这个函数的参数，函数内部一般为异步执行的代码，resolve作为异步执行完成之后成功的回调，reject作为异步执行抛错的回调。Promise构造函数可以理解为执行异步的过程，其resolve和reject为执行异步调用结果的回调函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 代码1</span><br><span class=\"line\">var p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  // 执行一系列的异步执行</span><br><span class=\"line\">  // some codes...</span><br><span class=\"line\">  if (true) &#123;</span><br><span class=\"line\">    resolve(&quot;异步执行成功&quot;);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    reject(&quot;异步执行抛错&quot;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;); // fulfilled: 异步执行成功 ; 非fulfilled: 异步执行抛错</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Promise的异步处理\"><a href=\"#Promise的异步处理\" class=\"headerlink\" title=\"Promise的异步处理\"></a>Promise的异步处理</h3><h4 id=\"then和catch的使用\"><a href=\"#then和catch的使用\" class=\"headerlink\" title=\"then和catch的使用\"></a>then和catch的使用</h4><p>Promise构造函数返回一个异步执行之后的promise对象，该对象对异步的结果进一步处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 代码2</span><br><span class=\"line\">p</span><br><span class=\"line\">  .then((res) =&gt; &#123;</span><br><span class=\"line\">    // try catch 手动抛错</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      // console.log(&quot;异步返回成功状态&quot;);</span><br><span class=\"line\">      throw Error(&quot;错误代码&quot;);</span><br><span class=\"line\">    &#125; catch(e) &#123;</span><br><span class=\"line\">      console.log(&quot;执行catch&quot;);</span><br><span class=\"line\">      return Promise.reject(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch((res) =&gt; &#123;</span><br><span class=\"line\">    console.log(res); // 输出上一个 then 中 catch 的 e</span><br><span class=\"line\">    return &quot;这里由错误信息过去的数据&quot;;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then((res) =&gt; &#123;</span><br><span class=\"line\">    console.log(res); // 若上一个catch执行，输出：这里由错误信息过去的数据</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n<p>以上代码执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 结果1</span><br><span class=\"line\">执行catch</span><br><span class=\"line\">Error: 错误代码</span><br><span class=\"line\">    at p.then (**/promise.js:77:10)</span><br><span class=\"line\">    at process._tickCallback (internal/process/next_tick.js:109:7)</span><br><span class=\"line\">    at Module.runMain (module.js:607:11)</span><br><span class=\"line\">    at run (bootstrap_node.js:423:7)</span><br><span class=\"line\">    at startup (bootstrap_node.js:147:9)</span><br><span class=\"line\">    at bootstrap_node.js:538:3</span><br><span class=\"line\">这里由错误信息过去的数据</span><br></pre></td></tr></table></figure>\n<h3 id=\"promise对象的链式调用\"><a href=\"#promise对象的链式调用\" class=\"headerlink\" title=\"promise对象的链式调用\"></a>promise对象的链式调用</h3><p>由代码2可以看出，promise对象状态为resolve的时候，执行then方法，而且在不抛错情况下会持续执行链式调用的then方法，若then方法抛出异常或者抛出返回Promise.reject()方法，会转到执行catch方法，若catch方法返回的不是Promise.reject()方法或者不抛出异常，则所有使用return返回的数据都会作为参数传给下一个then函数参数的参数，即代码2中的最后一个then方法指定函数参数的res是上一个catch所return的数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  resolve(&quot;ok&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p.then((msg) =&gt; &#123;</span><br><span class=\"line\">  console.log(msg);</span><br><span class=\"line\">  return Promise.reject(&quot;then01抛错&quot;);</span><br><span class=\"line\">&#125;).catch((errMsg) =&gt; &#123;</span><br><span class=\"line\">  console.warn(errMsg);</span><br><span class=\"line\">&#125;).then(() =&gt; &#123;</span><br><span class=\"line\">  console.log(&quot;then02再执行&quot;);</span><br><span class=\"line\">&#125;).then(() =&gt; &#123;</span><br><span class=\"line\">  console.log(&quot;then03再执行&quot;);</span><br><span class=\"line\">  return Promise.reject(&quot;then03抛错&quot;);</span><br><span class=\"line\">&#125;).catch((errMsg) =&gt; &#123;</span><br><span class=\"line\">  console.warn(errMsg);</span><br><span class=\"line\">  return &quot;catch02 return 给下一个then指定方法的值&quot;;</span><br><span class=\"line\">&#125;).then((msg) =&gt; &#123;</span><br><span class=\"line\">  console.log(msg);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>运行结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ok</span><br><span class=\"line\">then01抛错</span><br><span class=\"line\">then02再执行</span><br><span class=\"line\">then03再执行</span><br><span class=\"line\">then03抛错</span><br><span class=\"line\">catch02 return 给下一个then指定方法的值</span><br></pre></td></tr></table></figure>\n<p>这是因为then方法和catch方法返回的都是一个promise对象。then方法指定的回调函数抛出错误会被下一个catch方法捕获，多个then方法执行也是如此。catch方法会捕获上一个catch方法（如果有的话）之后抛错的错误。</p>\n<p>换言之，无论是then方法还是catch方法,返回的都是一个promise对象，其状态取决于上一个方法指定的函数是否顺利执行或者没有返回Promise.reject（）。</p>\n<h3 id=\"Promise状态\"><a href=\"#Promise状态\" class=\"headerlink\" title=\"Promise状态\"></a>Promise状态</h3><p>一旦Promise的状态变为resolved或者rejected，就会永久保持该状态，不会再变。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"> var p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  resolve(&quot;ok&quot;);</span><br><span class=\"line\">  throw new Error(&quot;wrong&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p.then((msg) =&gt; &#123;</span><br><span class=\"line\">  console.log(msg);</span><br><span class=\"line\">&#125;).catch((errMsg) =&gt; &#123;</span><br><span class=\"line\">  console.warn(errMsg);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// ok</span><br></pre></td></tr></table></figure>\n<p>在Promise的参数函数中，由于先断定了resolved状态，所以在之后只会执行then函数，后面抛出的错误会等于没抛出来。</p>\n<p>另外，“事件循环”会对抛出的结果有影响。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  resolve(&quot;ok&quot;);</span><br><span class=\"line\">  setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    throw new Error(&quot;wrong&quot;);</span><br><span class=\"line\">  &#125;, 0);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p.then((msg) =&gt; &#123;</span><br><span class=\"line\">  console.log(msg);</span><br><span class=\"line\">&#125;).catch((errMsg) =&gt; &#123;</span><br><span class=\"line\">  console.warn(errMsg);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// ok</span><br><span class=\"line\"></span><br><span class=\"line\">// 浏览器抛出的错误</span><br><span class=\"line\">// index.js:4 Uncaught Error: wrong</span><br><span class=\"line\">//    at setTimeout (index.js:4)</span><br><span class=\"line\">// setTimeout    @    index.js:4</span><br></pre></td></tr></table></figure>\n<p>在本轮“事件循环”中，promise对象p先执行，所以构造函数Promise的指定函数先输出‘ok’；在进入到下一次的“事件循环”的时候，由于Promise函数体已经执行完毕，故后面抛出的错误是在Promise函数体外抛出的，Promise函数体无法捕获到这个错误。</p>\n<h4 id=\"Promise-resolve\"><a href=\"#Promise-resolve\" class=\"headerlink\" title=\"Promise.resolve()\"></a>Promise.resolve()</h4><p>Promise.resolve()接受一个参数，其返回一个promise对象的状态会因为传入的参数的不同而不同。</p>\n<p>参数分别以下几种情况：<br>空</p>\n<p>返回一个状态为resolved的promise对象，也就是下一步会执行then方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var p = Promise.resolve();</span><br><span class=\"line\"></span><br><span class=\"line\">p.then((res) =&gt; &#123;</span><br><span class=\"line\">  console.log(&quot;then&quot;);</span><br><span class=\"line\">&#125;).catch((res) =&gt; &#123;</span><br><span class=\"line\">  console.log(&quot;catch&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// then</span><br></pre></td></tr></table></figure>\n<p>thenable对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var thenable = &#123;</span><br><span class=\"line\">  then: function (resolve, reject) &#123;</span><br><span class=\"line\">    console.log(&quot;立即执行thenable的then的方法&quot; + Date.now());</span><br><span class=\"line\">    resolve(&quot;断定之后的信息&quot;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var p = Promise.resolve(thenable);</span><br><span class=\"line\"></span><br><span class=\"line\">p.then((res) =&gt; &#123;</span><br><span class=\"line\">  console.log(res);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 立即执行thenable的then的方法1494485393447</span><br><span class=\"line\">// 断定之后的信息</span><br><span class=\"line\"></span><br><span class=\"line\">// 相当于</span><br><span class=\"line\"></span><br><span class=\"line\">var p = new Promise(function (resolve, reject) &#123;</span><br><span class=\"line\">  console.log(&quot;立即执行thenable的then的方法&quot; + Date.now());</span><br><span class=\"line\">  resolve(&quot;断定之后的信息&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">p.then((res) =&gt; &#123;</span><br><span class=\"line\">  console.log(res);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 立即执行thenable的then的方法1494485454503</span><br><span class=\"line\">// 断定之后的信息</span><br></pre></td></tr></table></figure>\n<p>thenable对象作为参数，在执行Promise.resolve(thenable)方法的时候，会立即执行thenable对象中的then方法，并且其返回的Promise对象的状态取决于thenable对象的then方法执行的是resolve()还是reject()。这种情况下，就相当于Promise构造函数以thenable对象的then方法作为参数，实例化一个Promise实例。</p>\n<p>一个非Promise对象，且不含有then方法的对象——非thenable对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var p = Promise.resolve(&#123;</span><br><span class=\"line\">  a: 1</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p.then((res) =&gt; &#123;</span><br><span class=\"line\">  console.log(res);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// &#123; a: 1 &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var p01 = Promise.resolve(&apos;Hello Promise!&apos;);</span><br><span class=\"line\">p01.then((res) =&gt; &#123;</span><br><span class=\"line\">  console.log(res);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// Hello Promise!</span><br></pre></td></tr></table></figure>\n<p>这种情况下，Promise.resolve()的状态为resolved，其接收的参数会作为then方法指定函数的参数。</p>\n<p>Promise对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var p01 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  reject(&apos;Throw some error! Come on! You bite me.&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">var p = Promise.resolve(p01);</span><br><span class=\"line\"></span><br><span class=\"line\">p.then((res) =&gt; &#123;</span><br><span class=\"line\">  console.log(&quot;这是then方法&quot;);</span><br><span class=\"line\">&#125;).catch((errMsg) =&gt; &#123;</span><br><span class=\"line\">  console.log(errMsg);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// Throw some error! Come on! You bite me.</span><br></pre></td></tr></table></figure>\n<p>传入的是一个Promise对象，Promise.resolve()返回的对象的状态就是传入的Promise对象的状态。</p>\n<h4 id=\"Promise-reject\"><a href=\"#Promise-reject\" class=\"headerlink\" title=\"Promise.reject()\"></a>Promise.reject()</h4><p>Promise.reject(reason)方法同样返回一个状态为rejected的Promise对象实例。值得注意的是，参数reason(Promise状态rejected的原因)不论是什么值，都会传给返回的Promise对象的catch方法指定的函数作为参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var p = Promise.reject(&apos;Throw some error! Come on! You bite me.&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">p.then((res) =&gt; &#123;</span><br><span class=\"line\">  console.log(&quot;这是then方法&quot;);</span><br><span class=\"line\">&#125;).catch((errMsg) =&gt; &#123;</span><br><span class=\"line\">  console.log(errMsg);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// Throw some error! Come on! You bite me</span><br></pre></td></tr></table></figure>\n<h4 id=\"promise对象的使用场景——图片加载\"><a href=\"#promise对象的使用场景——图片加载\" class=\"headerlink\" title=\"promise对象的使用场景——图片加载\"></a>promise对象的使用场景——图片加载</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var imgPromise = function (url) &#123;</span><br><span class=\"line\">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    var img = new Image();</span><br><span class=\"line\">    img.src = url;</span><br><span class=\"line\">    img.onload = resolve;</span><br><span class=\"line\">    img.onerror = reject;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">imgPromise(&quot;http://imgurl&quot;)</span><br><span class=\"line\">  .then((res) =&gt; &#123;</span><br><span class=\"line\">    console.log(&quot;图片加载完成&quot;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch((res) =&gt; &#123;</span><br><span class=\"line\">    console.log(&quot;图片加载失败&quot;);</span><br><span class=\"line\">  &#125;)：</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>Promise对象是一个构造函数，其接受一个函数作为参数，resolve、reject为这个函数的参数，函数内部一般为异步执行的代码，resolve作为异步执行完成之后成功的回调，reject作为异步执行抛错的回调。Promise构造函数可以理解为执行异步的过程，其resolve和reject为执行异步调用结果的回调函数。</p>","more":"<h3 id=\"初识Promise\"><a href=\"#初识Promise\" class=\"headerlink\" title=\"初识Promise\"></a>初识Promise</h3><p>Promise对象是一个构造函数，其接受一个函数作为参数，resolve、reject为这个函数的参数，函数内部一般为异步执行的代码，resolve作为异步执行完成之后成功的回调，reject作为异步执行抛错的回调。Promise构造函数可以理解为执行异步的过程，其resolve和reject为执行异步调用结果的回调函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 代码1</span><br><span class=\"line\">var p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  // 执行一系列的异步执行</span><br><span class=\"line\">  // some codes...</span><br><span class=\"line\">  if (true) &#123;</span><br><span class=\"line\">    resolve(&quot;异步执行成功&quot;);</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    reject(&quot;异步执行抛错&quot;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;); // fulfilled: 异步执行成功 ; 非fulfilled: 异步执行抛错</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Promise的异步处理\"><a href=\"#Promise的异步处理\" class=\"headerlink\" title=\"Promise的异步处理\"></a>Promise的异步处理</h3><h4 id=\"then和catch的使用\"><a href=\"#then和catch的使用\" class=\"headerlink\" title=\"then和catch的使用\"></a>then和catch的使用</h4><p>Promise构造函数返回一个异步执行之后的promise对象，该对象对异步的结果进一步处理。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 代码2</span><br><span class=\"line\">p</span><br><span class=\"line\">  .then((res) =&gt; &#123;</span><br><span class=\"line\">    // try catch 手动抛错</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">      // console.log(&quot;异步返回成功状态&quot;);</span><br><span class=\"line\">      throw Error(&quot;错误代码&quot;);</span><br><span class=\"line\">    &#125; catch(e) &#123;</span><br><span class=\"line\">      console.log(&quot;执行catch&quot;);</span><br><span class=\"line\">      return Promise.reject(e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch((res) =&gt; &#123;</span><br><span class=\"line\">    console.log(res); // 输出上一个 then 中 catch 的 e</span><br><span class=\"line\">    return &quot;这里由错误信息过去的数据&quot;;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .then((res) =&gt; &#123;</span><br><span class=\"line\">    console.log(res); // 若上一个catch执行，输出：这里由错误信息过去的数据</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n<p>以上代码执行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># 结果1</span><br><span class=\"line\">执行catch</span><br><span class=\"line\">Error: 错误代码</span><br><span class=\"line\">    at p.then (**/promise.js:77:10)</span><br><span class=\"line\">    at process._tickCallback (internal/process/next_tick.js:109:7)</span><br><span class=\"line\">    at Module.runMain (module.js:607:11)</span><br><span class=\"line\">    at run (bootstrap_node.js:423:7)</span><br><span class=\"line\">    at startup (bootstrap_node.js:147:9)</span><br><span class=\"line\">    at bootstrap_node.js:538:3</span><br><span class=\"line\">这里由错误信息过去的数据</span><br></pre></td></tr></table></figure>\n<h3 id=\"promise对象的链式调用\"><a href=\"#promise对象的链式调用\" class=\"headerlink\" title=\"promise对象的链式调用\"></a>promise对象的链式调用</h3><p>由代码2可以看出，promise对象状态为resolve的时候，执行then方法，而且在不抛错情况下会持续执行链式调用的then方法，若then方法抛出异常或者抛出返回Promise.reject()方法，会转到执行catch方法，若catch方法返回的不是Promise.reject()方法或者不抛出异常，则所有使用return返回的数据都会作为参数传给下一个then函数参数的参数，即代码2中的最后一个then方法指定函数参数的res是上一个catch所return的数据。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  resolve(&quot;ok&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p.then((msg) =&gt; &#123;</span><br><span class=\"line\">  console.log(msg);</span><br><span class=\"line\">  return Promise.reject(&quot;then01抛错&quot;);</span><br><span class=\"line\">&#125;).catch((errMsg) =&gt; &#123;</span><br><span class=\"line\">  console.warn(errMsg);</span><br><span class=\"line\">&#125;).then(() =&gt; &#123;</span><br><span class=\"line\">  console.log(&quot;then02再执行&quot;);</span><br><span class=\"line\">&#125;).then(() =&gt; &#123;</span><br><span class=\"line\">  console.log(&quot;then03再执行&quot;);</span><br><span class=\"line\">  return Promise.reject(&quot;then03抛错&quot;);</span><br><span class=\"line\">&#125;).catch((errMsg) =&gt; &#123;</span><br><span class=\"line\">  console.warn(errMsg);</span><br><span class=\"line\">  return &quot;catch02 return 给下一个then指定方法的值&quot;;</span><br><span class=\"line\">&#125;).then((msg) =&gt; &#123;</span><br><span class=\"line\">  console.log(msg);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>运行结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ok</span><br><span class=\"line\">then01抛错</span><br><span class=\"line\">then02再执行</span><br><span class=\"line\">then03再执行</span><br><span class=\"line\">then03抛错</span><br><span class=\"line\">catch02 return 给下一个then指定方法的值</span><br></pre></td></tr></table></figure>\n<p>这是因为then方法和catch方法返回的都是一个promise对象。then方法指定的回调函数抛出错误会被下一个catch方法捕获，多个then方法执行也是如此。catch方法会捕获上一个catch方法（如果有的话）之后抛错的错误。</p>\n<p>换言之，无论是then方法还是catch方法,返回的都是一个promise对象，其状态取决于上一个方法指定的函数是否顺利执行或者没有返回Promise.reject（）。</p>\n<h3 id=\"Promise状态\"><a href=\"#Promise状态\" class=\"headerlink\" title=\"Promise状态\"></a>Promise状态</h3><p>一旦Promise的状态变为resolved或者rejected，就会永久保持该状态，不会再变。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"> var p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  resolve(&quot;ok&quot;);</span><br><span class=\"line\">  throw new Error(&quot;wrong&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p.then((msg) =&gt; &#123;</span><br><span class=\"line\">  console.log(msg);</span><br><span class=\"line\">&#125;).catch((errMsg) =&gt; &#123;</span><br><span class=\"line\">  console.warn(errMsg);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// ok</span><br></pre></td></tr></table></figure>\n<p>在Promise的参数函数中，由于先断定了resolved状态，所以在之后只会执行then函数，后面抛出的错误会等于没抛出来。</p>\n<p>另外，“事件循环”会对抛出的结果有影响。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  resolve(&quot;ok&quot;);</span><br><span class=\"line\">  setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    throw new Error(&quot;wrong&quot;);</span><br><span class=\"line\">  &#125;, 0);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p.then((msg) =&gt; &#123;</span><br><span class=\"line\">  console.log(msg);</span><br><span class=\"line\">&#125;).catch((errMsg) =&gt; &#123;</span><br><span class=\"line\">  console.warn(errMsg);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// ok</span><br><span class=\"line\"></span><br><span class=\"line\">// 浏览器抛出的错误</span><br><span class=\"line\">// index.js:4 Uncaught Error: wrong</span><br><span class=\"line\">//    at setTimeout (index.js:4)</span><br><span class=\"line\">// setTimeout    @    index.js:4</span><br></pre></td></tr></table></figure>\n<p>在本轮“事件循环”中，promise对象p先执行，所以构造函数Promise的指定函数先输出‘ok’；在进入到下一次的“事件循环”的时候，由于Promise函数体已经执行完毕，故后面抛出的错误是在Promise函数体外抛出的，Promise函数体无法捕获到这个错误。</p>\n<h4 id=\"Promise-resolve\"><a href=\"#Promise-resolve\" class=\"headerlink\" title=\"Promise.resolve()\"></a>Promise.resolve()</h4><p>Promise.resolve()接受一个参数，其返回一个promise对象的状态会因为传入的参数的不同而不同。</p>\n<p>参数分别以下几种情况：<br>空</p>\n<p>返回一个状态为resolved的promise对象，也就是下一步会执行then方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var p = Promise.resolve();</span><br><span class=\"line\"></span><br><span class=\"line\">p.then((res) =&gt; &#123;</span><br><span class=\"line\">  console.log(&quot;then&quot;);</span><br><span class=\"line\">&#125;).catch((res) =&gt; &#123;</span><br><span class=\"line\">  console.log(&quot;catch&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// then</span><br></pre></td></tr></table></figure>\n<p>thenable对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var thenable = &#123;</span><br><span class=\"line\">  then: function (resolve, reject) &#123;</span><br><span class=\"line\">    console.log(&quot;立即执行thenable的then的方法&quot; + Date.now());</span><br><span class=\"line\">    resolve(&quot;断定之后的信息&quot;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var p = Promise.resolve(thenable);</span><br><span class=\"line\"></span><br><span class=\"line\">p.then((res) =&gt; &#123;</span><br><span class=\"line\">  console.log(res);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 立即执行thenable的then的方法1494485393447</span><br><span class=\"line\">// 断定之后的信息</span><br><span class=\"line\"></span><br><span class=\"line\">// 相当于</span><br><span class=\"line\"></span><br><span class=\"line\">var p = new Promise(function (resolve, reject) &#123;</span><br><span class=\"line\">  console.log(&quot;立即执行thenable的then的方法&quot; + Date.now());</span><br><span class=\"line\">  resolve(&quot;断定之后的信息&quot;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">p.then((res) =&gt; &#123;</span><br><span class=\"line\">  console.log(res);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 立即执行thenable的then的方法1494485454503</span><br><span class=\"line\">// 断定之后的信息</span><br></pre></td></tr></table></figure>\n<p>thenable对象作为参数，在执行Promise.resolve(thenable)方法的时候，会立即执行thenable对象中的then方法，并且其返回的Promise对象的状态取决于thenable对象的then方法执行的是resolve()还是reject()。这种情况下，就相当于Promise构造函数以thenable对象的then方法作为参数，实例化一个Promise实例。</p>\n<p>一个非Promise对象，且不含有then方法的对象——非thenable对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var p = Promise.resolve(&#123;</span><br><span class=\"line\">  a: 1</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">p.then((res) =&gt; &#123;</span><br><span class=\"line\">  console.log(res);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// &#123; a: 1 &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var p01 = Promise.resolve(&apos;Hello Promise!&apos;);</span><br><span class=\"line\">p01.then((res) =&gt; &#123;</span><br><span class=\"line\">  console.log(res);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// Hello Promise!</span><br></pre></td></tr></table></figure>\n<p>这种情况下，Promise.resolve()的状态为resolved，其接收的参数会作为then方法指定函数的参数。</p>\n<p>Promise对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var p01 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  reject(&apos;Throw some error! Come on! You bite me.&apos;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">var p = Promise.resolve(p01);</span><br><span class=\"line\"></span><br><span class=\"line\">p.then((res) =&gt; &#123;</span><br><span class=\"line\">  console.log(&quot;这是then方法&quot;);</span><br><span class=\"line\">&#125;).catch((errMsg) =&gt; &#123;</span><br><span class=\"line\">  console.log(errMsg);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// Throw some error! Come on! You bite me.</span><br></pre></td></tr></table></figure>\n<p>传入的是一个Promise对象，Promise.resolve()返回的对象的状态就是传入的Promise对象的状态。</p>\n<h4 id=\"Promise-reject\"><a href=\"#Promise-reject\" class=\"headerlink\" title=\"Promise.reject()\"></a>Promise.reject()</h4><p>Promise.reject(reason)方法同样返回一个状态为rejected的Promise对象实例。值得注意的是，参数reason(Promise状态rejected的原因)不论是什么值，都会传给返回的Promise对象的catch方法指定的函数作为参数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var p = Promise.reject(&apos;Throw some error! Come on! You bite me.&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">p.then((res) =&gt; &#123;</span><br><span class=\"line\">  console.log(&quot;这是then方法&quot;);</span><br><span class=\"line\">&#125;).catch((errMsg) =&gt; &#123;</span><br><span class=\"line\">  console.log(errMsg);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">// Throw some error! Come on! You bite me</span><br></pre></td></tr></table></figure>\n<h4 id=\"promise对象的使用场景——图片加载\"><a href=\"#promise对象的使用场景——图片加载\" class=\"headerlink\" title=\"promise对象的使用场景——图片加载\"></a>promise对象的使用场景——图片加载</h4><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var imgPromise = function (url) &#123;</span><br><span class=\"line\">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    var img = new Image();</span><br><span class=\"line\">    img.src = url;</span><br><span class=\"line\">    img.onload = resolve;</span><br><span class=\"line\">    img.onerror = reject;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">imgPromise(&quot;http://imgurl&quot;)</span><br><span class=\"line\">  .then((res) =&gt; &#123;</span><br><span class=\"line\">    console.log(&quot;图片加载完成&quot;);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .catch((res) =&gt; &#123;</span><br><span class=\"line\">    console.log(&quot;图片加载失败&quot;);</span><br><span class=\"line\">  &#125;)：</span><br></pre></td></tr></table></figure>"},{"title":"js递归","date":"2018-02-26T16:00:00.000Z","photos":["/img/2017/4.jpg"],"_content":"\n程序调用自身的编程技巧称为递归。递归思想也是软件开发中非常重要的基本思想之一。当然这种思想是要有，但是确实递归会影响效率。\n\n<!--more-->\n\n### 定义\n我们称自己调用自己就叫做递归。\n### 阶乘\n从小学就接触的阶乘就可以用递归实现。\n示例：\n\n```\nfunction factorial(n) {\n    if (n == 1) return n;\n    return n * factorial(n - 1)\n}\nconsole.log(factorial(4)) // 4 * 3 * 2 * 1 = 24\n```\n### 斐波那契数列\n曾经去面试时，就有这样一道题目，说是写出一个函数实现如下数列：1, 1, 2, 3, 5, 8, 13, 21, 34 … 。当时自以为很机智地一直在找规律，回来后跟别人说起，结果被深深的鄙视.\n\n递归实现斐波那契数列：\n\n```\nfunction fibonacci(n){\n    return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);\n}\nconsole.log(fibonacci(8)) // 1 1 2 3 5 8 13 21\n```\n### 递归条件\n从这两个例子中，我们可以看出：\n\n构成递归需具备边界条件、递归前进段和递归返回段，当边界条件不满足时，递归前进，当边界条件满足时，递归返回。阶乘中的 n == 1 和 斐波那契数列中的 n < 2 都是边界条件。递归不能无限制地调用本身，边界条件就是递归的出口。\n\n### 递归优化\n我们知道当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。我们看上面阶乘的列子会发现JavaScript会不停的创建执行上下文压入执行上下文栈，对于内存而言，维护这么多的执行上下文是一笔不小的开销。\n\n接下来我们试试用尾调用来优化它。\n### 尾调用\n尾调用，是指函数内部的最后一个动作是函数调用。该调用的返回值，直接返回给函数。\n举个例子：\n\n```\n// 尾调用\nfunction a(x){\n    return b(x);\n}\n```\n然而\n\n```\n// 非尾调用\nfunction a(x){\n    return b(x) + 1;\n}\n```\n因为 b(x) 的返回值还需要跟 1 进行计算后，a(x)才会返回值。\n\n也就说尾调用函数执行时，虽然也调用了一个函数，但是因为原来的函数执行完毕，执行上下文会被弹出，执行上下文栈中相当于只多压入了一个执行上下文。然而非尾调用函数，就会创建多个执行上下文压入执行上下文栈。\n\n接下来我们用尾调用来优化递归：\n\n```\nfunction factorial(n, res) {\n    if (n == 1) return res;\n    return factorial(n - 1, n * res)\n}\nconsole.log(factorial(4, 1)) // 24\n```\n参考链接：https://segmentfault.com/a/1190000011142875\n\n\n\n","source":"_posts/recursion.md","raw":"title: js递归\ndate: 2018-02-27\ntag:\n - js\n\nphotos:\n - /img/2017/4.jpg \n\n---\n\n程序调用自身的编程技巧称为递归。递归思想也是软件开发中非常重要的基本思想之一。当然这种思想是要有，但是确实递归会影响效率。\n\n<!--more-->\n\n### 定义\n我们称自己调用自己就叫做递归。\n### 阶乘\n从小学就接触的阶乘就可以用递归实现。\n示例：\n\n```\nfunction factorial(n) {\n    if (n == 1) return n;\n    return n * factorial(n - 1)\n}\nconsole.log(factorial(4)) // 4 * 3 * 2 * 1 = 24\n```\n### 斐波那契数列\n曾经去面试时，就有这样一道题目，说是写出一个函数实现如下数列：1, 1, 2, 3, 5, 8, 13, 21, 34 … 。当时自以为很机智地一直在找规律，回来后跟别人说起，结果被深深的鄙视.\n\n递归实现斐波那契数列：\n\n```\nfunction fibonacci(n){\n    return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);\n}\nconsole.log(fibonacci(8)) // 1 1 2 3 5 8 13 21\n```\n### 递归条件\n从这两个例子中，我们可以看出：\n\n构成递归需具备边界条件、递归前进段和递归返回段，当边界条件不满足时，递归前进，当边界条件满足时，递归返回。阶乘中的 n == 1 和 斐波那契数列中的 n < 2 都是边界条件。递归不能无限制地调用本身，边界条件就是递归的出口。\n\n### 递归优化\n我们知道当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。我们看上面阶乘的列子会发现JavaScript会不停的创建执行上下文压入执行上下文栈，对于内存而言，维护这么多的执行上下文是一笔不小的开销。\n\n接下来我们试试用尾调用来优化它。\n### 尾调用\n尾调用，是指函数内部的最后一个动作是函数调用。该调用的返回值，直接返回给函数。\n举个例子：\n\n```\n// 尾调用\nfunction a(x){\n    return b(x);\n}\n```\n然而\n\n```\n// 非尾调用\nfunction a(x){\n    return b(x) + 1;\n}\n```\n因为 b(x) 的返回值还需要跟 1 进行计算后，a(x)才会返回值。\n\n也就说尾调用函数执行时，虽然也调用了一个函数，但是因为原来的函数执行完毕，执行上下文会被弹出，执行上下文栈中相当于只多压入了一个执行上下文。然而非尾调用函数，就会创建多个执行上下文压入执行上下文栈。\n\n接下来我们用尾调用来优化递归：\n\n```\nfunction factorial(n, res) {\n    if (n == 1) return res;\n    return factorial(n - 1, n * res)\n}\nconsole.log(factorial(4, 1)) // 24\n```\n参考链接：https://segmentfault.com/a/1190000011142875\n\n\n\n","slug":"recursion","published":1,"updated":"2018-08-28T10:15:58.781Z","_id":"cjldh03rj000euv6xsbliagbt","comments":1,"layout":"post","link":"","content":"<p>程序调用自身的编程技巧称为递归。递归思想也是软件开发中非常重要的基本思想之一。当然这种思想是要有，但是确实递归会影响效率。</p>\n<a id=\"more\"></a>\n<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>我们称自己调用自己就叫做递归。</p>\n<h3 id=\"阶乘\"><a href=\"#阶乘\" class=\"headerlink\" title=\"阶乘\"></a>阶乘</h3><p>从小学就接触的阶乘就可以用递归实现。<br>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function factorial(n) &#123;</span><br><span class=\"line\">    if (n == 1) return n;</span><br><span class=\"line\">    return n * factorial(n - 1)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(factorial(4)) // 4 * 3 * 2 * 1 = 24</span><br></pre></td></tr></table></figure>\n<h3 id=\"斐波那契数列\"><a href=\"#斐波那契数列\" class=\"headerlink\" title=\"斐波那契数列\"></a>斐波那契数列</h3><p>曾经去面试时，就有这样一道题目，说是写出一个函数实现如下数列：1, 1, 2, 3, 5, 8, 13, 21, 34 … 。当时自以为很机智地一直在找规律，回来后跟别人说起，结果被深深的鄙视.</p>\n<p>递归实现斐波那契数列：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function fibonacci(n)&#123;</span><br><span class=\"line\">    return n &lt; 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(fibonacci(8)) // 1 1 2 3 5 8 13 21</span><br></pre></td></tr></table></figure>\n<h3 id=\"递归条件\"><a href=\"#递归条件\" class=\"headerlink\" title=\"递归条件\"></a>递归条件</h3><p>从这两个例子中，我们可以看出：</p>\n<p>构成递归需具备边界条件、递归前进段和递归返回段，当边界条件不满足时，递归前进，当边界条件满足时，递归返回。阶乘中的 n == 1 和 斐波那契数列中的 n &lt; 2 都是边界条件。递归不能无限制地调用本身，边界条件就是递归的出口。</p>\n<h3 id=\"递归优化\"><a href=\"#递归优化\" class=\"headerlink\" title=\"递归优化\"></a>递归优化</h3><p>我们知道当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。我们看上面阶乘的列子会发现JavaScript会不停的创建执行上下文压入执行上下文栈，对于内存而言，维护这么多的执行上下文是一笔不小的开销。</p>\n<p>接下来我们试试用尾调用来优化它。</p>\n<h3 id=\"尾调用\"><a href=\"#尾调用\" class=\"headerlink\" title=\"尾调用\"></a>尾调用</h3><p>尾调用，是指函数内部的最后一个动作是函数调用。该调用的返回值，直接返回给函数。<br>举个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 尾调用</span><br><span class=\"line\">function a(x)&#123;</span><br><span class=\"line\">    return b(x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然而</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 非尾调用</span><br><span class=\"line\">function a(x)&#123;</span><br><span class=\"line\">    return b(x) + 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为 b(x) 的返回值还需要跟 1 进行计算后，a(x)才会返回值。</p>\n<p>也就说尾调用函数执行时，虽然也调用了一个函数，但是因为原来的函数执行完毕，执行上下文会被弹出，执行上下文栈中相当于只多压入了一个执行上下文。然而非尾调用函数，就会创建多个执行上下文压入执行上下文栈。</p>\n<p>接下来我们用尾调用来优化递归：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function factorial(n, res) &#123;</span><br><span class=\"line\">    if (n == 1) return res;</span><br><span class=\"line\">    return factorial(n - 1, n * res)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(factorial(4, 1)) // 24</span><br></pre></td></tr></table></figure>\n<p>参考链接：<a href=\"https://segmentfault.com/a/1190000011142875\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000011142875</a></p>\n","site":{"data":{}},"excerpt":"<p>程序调用自身的编程技巧称为递归。递归思想也是软件开发中非常重要的基本思想之一。当然这种思想是要有，但是确实递归会影响效率。</p>","more":"<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>我们称自己调用自己就叫做递归。</p>\n<h3 id=\"阶乘\"><a href=\"#阶乘\" class=\"headerlink\" title=\"阶乘\"></a>阶乘</h3><p>从小学就接触的阶乘就可以用递归实现。<br>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function factorial(n) &#123;</span><br><span class=\"line\">    if (n == 1) return n;</span><br><span class=\"line\">    return n * factorial(n - 1)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(factorial(4)) // 4 * 3 * 2 * 1 = 24</span><br></pre></td></tr></table></figure>\n<h3 id=\"斐波那契数列\"><a href=\"#斐波那契数列\" class=\"headerlink\" title=\"斐波那契数列\"></a>斐波那契数列</h3><p>曾经去面试时，就有这样一道题目，说是写出一个函数实现如下数列：1, 1, 2, 3, 5, 8, 13, 21, 34 … 。当时自以为很机智地一直在找规律，回来后跟别人说起，结果被深深的鄙视.</p>\n<p>递归实现斐波那契数列：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function fibonacci(n)&#123;</span><br><span class=\"line\">    return n &lt; 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(fibonacci(8)) // 1 1 2 3 5 8 13 21</span><br></pre></td></tr></table></figure>\n<h3 id=\"递归条件\"><a href=\"#递归条件\" class=\"headerlink\" title=\"递归条件\"></a>递归条件</h3><p>从这两个例子中，我们可以看出：</p>\n<p>构成递归需具备边界条件、递归前进段和递归返回段，当边界条件不满足时，递归前进，当边界条件满足时，递归返回。阶乘中的 n == 1 和 斐波那契数列中的 n &lt; 2 都是边界条件。递归不能无限制地调用本身，边界条件就是递归的出口。</p>\n<h3 id=\"递归优化\"><a href=\"#递归优化\" class=\"headerlink\" title=\"递归优化\"></a>递归优化</h3><p>我们知道当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。我们看上面阶乘的列子会发现JavaScript会不停的创建执行上下文压入执行上下文栈，对于内存而言，维护这么多的执行上下文是一笔不小的开销。</p>\n<p>接下来我们试试用尾调用来优化它。</p>\n<h3 id=\"尾调用\"><a href=\"#尾调用\" class=\"headerlink\" title=\"尾调用\"></a>尾调用</h3><p>尾调用，是指函数内部的最后一个动作是函数调用。该调用的返回值，直接返回给函数。<br>举个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 尾调用</span><br><span class=\"line\">function a(x)&#123;</span><br><span class=\"line\">    return b(x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>然而</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 非尾调用</span><br><span class=\"line\">function a(x)&#123;</span><br><span class=\"line\">    return b(x) + 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为 b(x) 的返回值还需要跟 1 进行计算后，a(x)才会返回值。</p>\n<p>也就说尾调用函数执行时，虽然也调用了一个函数，但是因为原来的函数执行完毕，执行上下文会被弹出，执行上下文栈中相当于只多压入了一个执行上下文。然而非尾调用函数，就会创建多个执行上下文压入执行上下文栈。</p>\n<p>接下来我们用尾调用来优化递归：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">function factorial(n, res) &#123;</span><br><span class=\"line\">    if (n == 1) return res;</span><br><span class=\"line\">    return factorial(n - 1, n * res)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(factorial(4, 1)) // 24</span><br></pre></td></tr></table></figure>\n<p>参考链接：<a href=\"https://segmentfault.com/a/1190000011142875\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000011142875</a></p>"},{"title":"简单的 Web Socket 客户端","date":"2017-10-30T16:00:00.000Z","photos":["/img/2017/2.jpg"],"_content":"\nHTML5之webSocket的客户端实现，建立webSocket连接、交换信息及最终关闭webSocket连接过程。\n\n<!--more-->\n\n为了使用Web Socket,需要在Web服务器上运行一个Web Socket服务器。这个程序负责协调各方通信，而且启动后就会不间断的运行下去。本厂后端开发语言为php(毕竟是世界上最好的语言)，有兴趣的可以在github上找相关服务端代码阅读。本文只介绍Web Socket客户端的实现。\n\n## 一个聊天室的Web Socket简单客户端\n\n### 创建Web Socket对象\n\n```\nvar ws = new WebSocket('ws://127.0.0.1:8000'); //填写具体服务端地址\n```\nws对象值如下：\n\n```\nbinaryType:\"blob\",\nbufferedAmount:0,\nextensions:\"\",\nonclose:null,\nonerror:null,\nonmessage:null,\nonopen:null,\nprotocol:\"\",\nreadyState:1,\nurl:\"\",\n__proto__:\n```\n创建WebSocket对象后，页面就会尝试连接服务器。接下来，就是使用WebSocket对象的四个事件一个方法以及一个属性：onOpen、onError、onClose和onMessage还有send以及readyState。利用这些事件、方法、属性就可以实现与服务端的简单通信。\n### ws.onopen\n```\nws.onopen = function () {\n        var bindData = {\n                \"type\": \"bind\",\n                \"from_uid\": '',\n                \"to_uid\": '',\n                \"room_id\":'',\n                \"time\": ''\n        }\n        ws.send( JSON.stringify( bindData ) );\n    };\n```\nonOpen是在建立连接后触发,代表连接成功。send()方法发送连接的相关信息给服务器端。\n### ws.onmessage\n```\nws.onmessage = function (e) {\n        var result = JSON.parse( e.data );\n        switch(result.type){\n            case 'speak':\n                handleSpeak(result.data);\n                break;\n            case 'sendMsg':\n                break;     \n            default:\n                break;\n        }        \n };\n```\nonmessage是在页面从服务器接收到消息时触发。type区分服务器端返回消息的类型，可跟后端约定好，根据type的不同去执行不同的业务。\n### ws.onclose\n```\nws.onclose = function (error) {\n        console.log('关闭连接');\n    };\n```\nonclose是在连接关闭时触发,连接关闭考虑是否需要做相应的提示或者重连。\n### ws.onerror\n```\nws.onerror = function (error) {\n        console.log('连接出错');\n    };\n```\nonerror是在连接出现问题时触发，连接出错考虑是否需要做相应的提示或者重连。\n### ws.send()\n```\n<input type=\"button\" id=\"btn\" value=\"发送\" onclick=\"sendMsg()\" >\n```\n\n```\n//发送信息到服务端\n    function sendMsg(){\n        var inputText = document.querySelector('#inputText');\n        var data = {\n                \"type\": \"sendMsg\",\n                \"from_uid\": '',\n                \"to_uid\": '',\n                \"room_id\":'',\n                \"time\": ''\n                \"data\": {\n                    'text': inputText.value\n                },\n            }\n        ws.send( JSON.stringify( data ) );\n    }\n```\nsend方法用于向服务器发送数据。假设type为’sendMsg’,在onmessage事件里面监听该type对应值的服务端返回，进而做相应的处理。\n\n### ws.readyState\nreadyState返回对象的当前状态，一共有四种。可在需要做处理的地方判断状态值进而做相应的提示，一般判断状态值是否为’3’。\n\n```\n* CONNECTING：值为0，表示正在连接。\n* OPEN：值为1，表示连接成功，可以通信了。\n* CLOSING：值为2，表示连接正在关闭。\n* CLOSED：值为3，表示连接已经关闭，或者打开连接失败。\n```\n\n\n\n","source":"_posts/websocket.md","raw":"title: 简单的 Web Socket 客户端\ndate: 2017-10-31\ntag:\n - js\n - websocket\n\nphotos:\n - /img/2017/2.jpg \n\n---\n\nHTML5之webSocket的客户端实现，建立webSocket连接、交换信息及最终关闭webSocket连接过程。\n\n<!--more-->\n\n为了使用Web Socket,需要在Web服务器上运行一个Web Socket服务器。这个程序负责协调各方通信，而且启动后就会不间断的运行下去。本厂后端开发语言为php(毕竟是世界上最好的语言)，有兴趣的可以在github上找相关服务端代码阅读。本文只介绍Web Socket客户端的实现。\n\n## 一个聊天室的Web Socket简单客户端\n\n### 创建Web Socket对象\n\n```\nvar ws = new WebSocket('ws://127.0.0.1:8000'); //填写具体服务端地址\n```\nws对象值如下：\n\n```\nbinaryType:\"blob\",\nbufferedAmount:0,\nextensions:\"\",\nonclose:null,\nonerror:null,\nonmessage:null,\nonopen:null,\nprotocol:\"\",\nreadyState:1,\nurl:\"\",\n__proto__:\n```\n创建WebSocket对象后，页面就会尝试连接服务器。接下来，就是使用WebSocket对象的四个事件一个方法以及一个属性：onOpen、onError、onClose和onMessage还有send以及readyState。利用这些事件、方法、属性就可以实现与服务端的简单通信。\n### ws.onopen\n```\nws.onopen = function () {\n        var bindData = {\n                \"type\": \"bind\",\n                \"from_uid\": '',\n                \"to_uid\": '',\n                \"room_id\":'',\n                \"time\": ''\n        }\n        ws.send( JSON.stringify( bindData ) );\n    };\n```\nonOpen是在建立连接后触发,代表连接成功。send()方法发送连接的相关信息给服务器端。\n### ws.onmessage\n```\nws.onmessage = function (e) {\n        var result = JSON.parse( e.data );\n        switch(result.type){\n            case 'speak':\n                handleSpeak(result.data);\n                break;\n            case 'sendMsg':\n                break;     \n            default:\n                break;\n        }        \n };\n```\nonmessage是在页面从服务器接收到消息时触发。type区分服务器端返回消息的类型，可跟后端约定好，根据type的不同去执行不同的业务。\n### ws.onclose\n```\nws.onclose = function (error) {\n        console.log('关闭连接');\n    };\n```\nonclose是在连接关闭时触发,连接关闭考虑是否需要做相应的提示或者重连。\n### ws.onerror\n```\nws.onerror = function (error) {\n        console.log('连接出错');\n    };\n```\nonerror是在连接出现问题时触发，连接出错考虑是否需要做相应的提示或者重连。\n### ws.send()\n```\n<input type=\"button\" id=\"btn\" value=\"发送\" onclick=\"sendMsg()\" >\n```\n\n```\n//发送信息到服务端\n    function sendMsg(){\n        var inputText = document.querySelector('#inputText');\n        var data = {\n                \"type\": \"sendMsg\",\n                \"from_uid\": '',\n                \"to_uid\": '',\n                \"room_id\":'',\n                \"time\": ''\n                \"data\": {\n                    'text': inputText.value\n                },\n            }\n        ws.send( JSON.stringify( data ) );\n    }\n```\nsend方法用于向服务器发送数据。假设type为’sendMsg’,在onmessage事件里面监听该type对应值的服务端返回，进而做相应的处理。\n\n### ws.readyState\nreadyState返回对象的当前状态，一共有四种。可在需要做处理的地方判断状态值进而做相应的提示，一般判断状态值是否为’3’。\n\n```\n* CONNECTING：值为0，表示正在连接。\n* OPEN：值为1，表示连接成功，可以通信了。\n* CLOSING：值为2，表示连接正在关闭。\n* CLOSED：值为3，表示连接已经关闭，或者打开连接失败。\n```\n\n\n\n","slug":"websocket","published":1,"updated":"2018-08-28T10:15:32.704Z","_id":"cjldh03rm000guv6xc0d6ais4","comments":1,"layout":"post","link":"","content":"<p>HTML5之webSocket的客户端实现，建立webSocket连接、交换信息及最终关闭webSocket连接过程。</p>\n<a id=\"more\"></a>\n<p>为了使用Web Socket,需要在Web服务器上运行一个Web Socket服务器。这个程序负责协调各方通信，而且启动后就会不间断的运行下去。本厂后端开发语言为php(毕竟是世界上最好的语言)，有兴趣的可以在github上找相关服务端代码阅读。本文只介绍Web Socket客户端的实现。</p>\n<h2 id=\"一个聊天室的Web-Socket简单客户端\"><a href=\"#一个聊天室的Web-Socket简单客户端\" class=\"headerlink\" title=\"一个聊天室的Web Socket简单客户端\"></a>一个聊天室的Web Socket简单客户端</h2><h3 id=\"创建Web-Socket对象\"><a href=\"#创建Web-Socket对象\" class=\"headerlink\" title=\"创建Web Socket对象\"></a>创建Web Socket对象</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var ws = new WebSocket(&apos;ws://127.0.0.1:8000&apos;); //填写具体服务端地址</span><br></pre></td></tr></table></figure>\n<p>ws对象值如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">binaryType:&quot;blob&quot;,</span><br><span class=\"line\">bufferedAmount:0,</span><br><span class=\"line\">extensions:&quot;&quot;,</span><br><span class=\"line\">onclose:null,</span><br><span class=\"line\">onerror:null,</span><br><span class=\"line\">onmessage:null,</span><br><span class=\"line\">onopen:null,</span><br><span class=\"line\">protocol:&quot;&quot;,</span><br><span class=\"line\">readyState:1,</span><br><span class=\"line\">url:&quot;&quot;,</span><br><span class=\"line\">__proto__:</span><br></pre></td></tr></table></figure>\n<p>创建WebSocket对象后，页面就会尝试连接服务器。接下来，就是使用WebSocket对象的四个事件一个方法以及一个属性：onOpen、onError、onClose和onMessage还有send以及readyState。利用这些事件、方法、属性就可以实现与服务端的简单通信。</p>\n<h3 id=\"ws-onopen\"><a href=\"#ws-onopen\" class=\"headerlink\" title=\"ws.onopen\"></a>ws.onopen</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ws.onopen = function () &#123;</span><br><span class=\"line\">        var bindData = &#123;</span><br><span class=\"line\">                &quot;type&quot;: &quot;bind&quot;,</span><br><span class=\"line\">                &quot;from_uid&quot;: &apos;&apos;,</span><br><span class=\"line\">                &quot;to_uid&quot;: &apos;&apos;,</span><br><span class=\"line\">                &quot;room_id&quot;:&apos;&apos;,</span><br><span class=\"line\">                &quot;time&quot;: &apos;&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ws.send( JSON.stringify( bindData ) );</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n<p>onOpen是在建立连接后触发,代表连接成功。send()方法发送连接的相关信息给服务器端。</p>\n<h3 id=\"ws-onmessage\"><a href=\"#ws-onmessage\" class=\"headerlink\" title=\"ws.onmessage\"></a>ws.onmessage</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ws.onmessage = function (e) &#123;</span><br><span class=\"line\">        var result = JSON.parse( e.data );</span><br><span class=\"line\">        switch(result.type)&#123;</span><br><span class=\"line\">            case &apos;speak&apos;:</span><br><span class=\"line\">                handleSpeak(result.data);</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            case &apos;sendMsg&apos;:</span><br><span class=\"line\">                break;     </span><br><span class=\"line\">            default:</span><br><span class=\"line\">                break;</span><br><span class=\"line\">        &#125;        </span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure>\n<p>onmessage是在页面从服务器接收到消息时触发。type区分服务器端返回消息的类型，可跟后端约定好，根据type的不同去执行不同的业务。</p>\n<h3 id=\"ws-onclose\"><a href=\"#ws-onclose\" class=\"headerlink\" title=\"ws.onclose\"></a>ws.onclose</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ws.onclose = function (error) &#123;</span><br><span class=\"line\">        console.log(&apos;关闭连接&apos;);</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n<p>onclose是在连接关闭时触发,连接关闭考虑是否需要做相应的提示或者重连。</p>\n<h3 id=\"ws-onerror\"><a href=\"#ws-onerror\" class=\"headerlink\" title=\"ws.onerror\"></a>ws.onerror</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ws.onerror = function (error) &#123;</span><br><span class=\"line\">        console.log(&apos;连接出错&apos;);</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n<p>onerror是在连接出现问题时触发，连接出错考虑是否需要做相应的提示或者重连。</p>\n<h3 id=\"ws-send\"><a href=\"#ws-send\" class=\"headerlink\" title=\"ws.send()\"></a>ws.send()</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;发送&quot; onclick=&quot;sendMsg()&quot; &gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//发送信息到服务端</span><br><span class=\"line\">    function sendMsg()&#123;</span><br><span class=\"line\">        var inputText = document.querySelector(&apos;#inputText&apos;);</span><br><span class=\"line\">        var data = &#123;</span><br><span class=\"line\">                &quot;type&quot;: &quot;sendMsg&quot;,</span><br><span class=\"line\">                &quot;from_uid&quot;: &apos;&apos;,</span><br><span class=\"line\">                &quot;to_uid&quot;: &apos;&apos;,</span><br><span class=\"line\">                &quot;room_id&quot;:&apos;&apos;,</span><br><span class=\"line\">                &quot;time&quot;: &apos;&apos;</span><br><span class=\"line\">                &quot;data&quot;: &#123;</span><br><span class=\"line\">                    &apos;text&apos;: inputText.value</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ws.send( JSON.stringify( data ) );</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>send方法用于向服务器发送数据。假设type为’sendMsg’,在onmessage事件里面监听该type对应值的服务端返回，进而做相应的处理。</p>\n<h3 id=\"ws-readyState\"><a href=\"#ws-readyState\" class=\"headerlink\" title=\"ws.readyState\"></a>ws.readyState</h3><p>readyState返回对象的当前状态，一共有四种。可在需要做处理的地方判断状态值进而做相应的提示，一般判断状态值是否为’3’。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">* CONNECTING：值为0，表示正在连接。</span><br><span class=\"line\">* OPEN：值为1，表示连接成功，可以通信了。</span><br><span class=\"line\">* CLOSING：值为2，表示连接正在关闭。</span><br><span class=\"line\">* CLOSED：值为3，表示连接已经关闭，或者打开连接失败。</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>HTML5之webSocket的客户端实现，建立webSocket连接、交换信息及最终关闭webSocket连接过程。</p>","more":"<p>为了使用Web Socket,需要在Web服务器上运行一个Web Socket服务器。这个程序负责协调各方通信，而且启动后就会不间断的运行下去。本厂后端开发语言为php(毕竟是世界上最好的语言)，有兴趣的可以在github上找相关服务端代码阅读。本文只介绍Web Socket客户端的实现。</p>\n<h2 id=\"一个聊天室的Web-Socket简单客户端\"><a href=\"#一个聊天室的Web-Socket简单客户端\" class=\"headerlink\" title=\"一个聊天室的Web Socket简单客户端\"></a>一个聊天室的Web Socket简单客户端</h2><h3 id=\"创建Web-Socket对象\"><a href=\"#创建Web-Socket对象\" class=\"headerlink\" title=\"创建Web Socket对象\"></a>创建Web Socket对象</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var ws = new WebSocket(&apos;ws://127.0.0.1:8000&apos;); //填写具体服务端地址</span><br></pre></td></tr></table></figure>\n<p>ws对象值如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">binaryType:&quot;blob&quot;,</span><br><span class=\"line\">bufferedAmount:0,</span><br><span class=\"line\">extensions:&quot;&quot;,</span><br><span class=\"line\">onclose:null,</span><br><span class=\"line\">onerror:null,</span><br><span class=\"line\">onmessage:null,</span><br><span class=\"line\">onopen:null,</span><br><span class=\"line\">protocol:&quot;&quot;,</span><br><span class=\"line\">readyState:1,</span><br><span class=\"line\">url:&quot;&quot;,</span><br><span class=\"line\">__proto__:</span><br></pre></td></tr></table></figure>\n<p>创建WebSocket对象后，页面就会尝试连接服务器。接下来，就是使用WebSocket对象的四个事件一个方法以及一个属性：onOpen、onError、onClose和onMessage还有send以及readyState。利用这些事件、方法、属性就可以实现与服务端的简单通信。</p>\n<h3 id=\"ws-onopen\"><a href=\"#ws-onopen\" class=\"headerlink\" title=\"ws.onopen\"></a>ws.onopen</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ws.onopen = function () &#123;</span><br><span class=\"line\">        var bindData = &#123;</span><br><span class=\"line\">                &quot;type&quot;: &quot;bind&quot;,</span><br><span class=\"line\">                &quot;from_uid&quot;: &apos;&apos;,</span><br><span class=\"line\">                &quot;to_uid&quot;: &apos;&apos;,</span><br><span class=\"line\">                &quot;room_id&quot;:&apos;&apos;,</span><br><span class=\"line\">                &quot;time&quot;: &apos;&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        ws.send( JSON.stringify( bindData ) );</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n<p>onOpen是在建立连接后触发,代表连接成功。send()方法发送连接的相关信息给服务器端。</p>\n<h3 id=\"ws-onmessage\"><a href=\"#ws-onmessage\" class=\"headerlink\" title=\"ws.onmessage\"></a>ws.onmessage</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ws.onmessage = function (e) &#123;</span><br><span class=\"line\">        var result = JSON.parse( e.data );</span><br><span class=\"line\">        switch(result.type)&#123;</span><br><span class=\"line\">            case &apos;speak&apos;:</span><br><span class=\"line\">                handleSpeak(result.data);</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            case &apos;sendMsg&apos;:</span><br><span class=\"line\">                break;     </span><br><span class=\"line\">            default:</span><br><span class=\"line\">                break;</span><br><span class=\"line\">        &#125;        </span><br><span class=\"line\"> &#125;;</span><br></pre></td></tr></table></figure>\n<p>onmessage是在页面从服务器接收到消息时触发。type区分服务器端返回消息的类型，可跟后端约定好，根据type的不同去执行不同的业务。</p>\n<h3 id=\"ws-onclose\"><a href=\"#ws-onclose\" class=\"headerlink\" title=\"ws.onclose\"></a>ws.onclose</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ws.onclose = function (error) &#123;</span><br><span class=\"line\">        console.log(&apos;关闭连接&apos;);</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n<p>onclose是在连接关闭时触发,连接关闭考虑是否需要做相应的提示或者重连。</p>\n<h3 id=\"ws-onerror\"><a href=\"#ws-onerror\" class=\"headerlink\" title=\"ws.onerror\"></a>ws.onerror</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ws.onerror = function (error) &#123;</span><br><span class=\"line\">        console.log(&apos;连接出错&apos;);</span><br><span class=\"line\">    &#125;;</span><br></pre></td></tr></table></figure>\n<p>onerror是在连接出现问题时触发，连接出错考虑是否需要做相应的提示或者重连。</p>\n<h3 id=\"ws-send\"><a href=\"#ws-send\" class=\"headerlink\" title=\"ws.send()\"></a>ws.send()</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;发送&quot; onclick=&quot;sendMsg()&quot; &gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//发送信息到服务端</span><br><span class=\"line\">    function sendMsg()&#123;</span><br><span class=\"line\">        var inputText = document.querySelector(&apos;#inputText&apos;);</span><br><span class=\"line\">        var data = &#123;</span><br><span class=\"line\">                &quot;type&quot;: &quot;sendMsg&quot;,</span><br><span class=\"line\">                &quot;from_uid&quot;: &apos;&apos;,</span><br><span class=\"line\">                &quot;to_uid&quot;: &apos;&apos;,</span><br><span class=\"line\">                &quot;room_id&quot;:&apos;&apos;,</span><br><span class=\"line\">                &quot;time&quot;: &apos;&apos;</span><br><span class=\"line\">                &quot;data&quot;: &#123;</span><br><span class=\"line\">                    &apos;text&apos;: inputText.value</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ws.send( JSON.stringify( data ) );</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>send方法用于向服务器发送数据。假设type为’sendMsg’,在onmessage事件里面监听该type对应值的服务端返回，进而做相应的处理。</p>\n<h3 id=\"ws-readyState\"><a href=\"#ws-readyState\" class=\"headerlink\" title=\"ws.readyState\"></a>ws.readyState</h3><p>readyState返回对象的当前状态，一共有四种。可在需要做处理的地方判断状态值进而做相应的提示，一般判断状态值是否为’3’。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">* CONNECTING：值为0，表示正在连接。</span><br><span class=\"line\">* OPEN：值为1，表示连接成功，可以通信了。</span><br><span class=\"line\">* CLOSING：值为2，表示连接正在关闭。</span><br><span class=\"line\">* CLOSED：值为3，表示连接已经关闭，或者打开连接失败。</span><br></pre></td></tr></table></figure>"},{"title":"js基础","date":"2018-06-27T16:00:00.000Z","photos":["/img/2017/6.jpg"],"_content":"\njs基础备忘\n\n<!--more-->\n\n### valueOf()\nvalueOf方法是一个所有对象都拥有的方法，表示对该对象求值。不同对象的valueOf方法不尽一致，数组的valueOf方法返回数组本身。\n\n```\nvar arr = [1, 2, 3];\narr.valueOf() // [1, 2, 3]\n```\n日期对象\nvalueOf方法返回实例对象距离时间零点（1970年1月1日00:00:00 UTC）对应的毫秒数，该方法等同于getTime方法\n\n```\nnew Date()\nThu Jun 21 2018 16:43:00 GMT+0800 (中国标准时间)\nnew Date().valueOf()\n1529570590072\n```\n### toString()\ntoString方法也是对象的通用方法，数组的toString方法返回数组的字符串形式。\n\n```\nvar arr = [1, 2, 3];\narr.toString() // \"1,2,3\"\n\nvar arr = [1, 2, 3, [4, 5, 6]];\narr.toString() // \"1,2,3,4,5,6\"\n```\n```\nnew Date()\nThu Jun 21 2018 16:43:00 GMT+0800 (中国标准时间)\nnew Date().valueOf()\n1529570590072\nvar a = 1;\nundefined\na.toString();\n\"1\"\nnew Date().toString()\n\"Thu Jun 21 2018 17:15:52 GMT+0800 (中国标准时间)\"\n```\n### slice()\nslice方法用于提取目标数组的一部分，返回一个新数组，原数组不变。\n\n```\nvar a = ['a', 'b', 'c'];\na.slice(0) // [\"a\", \"b\", \"c\"]\na.slice(1) // [\"b\", \"c\"]\n```\n`String.prototype.slice()`\nslice方法用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。\n\n```\n'JavaScript'.slice(0, 4) // \"Java\"\n```\n控制文字长度\n\n```\n{{item.user_name.slice(0,4)}}\n```\n### indexOf()\nindexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。\n\n```\nvar a = ['a', 'b', 'c'];\na.indexOf('b') // 1\na.indexOf('y') // -1\n```\n`String.prototype.indexOf()`\n\nindexOf方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回-1，就表示不匹配。\n\n```\n'hello world'.indexOf('o') // 4\n'JavaScript'.indexOf('script') // -1\n```\n截取url\n\n```\nvar index = location.href.indexOf(\"order_id\");\nvar re_url = location.href.slice(0,index);\n```\n根据不同环境设置token\n\n```\nlet host = location.host,token = '';\nif( host.indexOf('localhost') !== -1 || host.indexOf('127.0.0.1') !== -1 ){\n    token = ''\n}\n```\n### splice()\nsplice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。\nsplice的第一个参数是删除的起始位置（从0开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。\n\n```\nvar a = ['a', 'b', 'c', 'd', 'e', 'f'];\na.splice(4, 2) // [\"e\", \"f\"]\na // [\"a\", \"b\", \"c\", \"d\"]\n```\n### push()、pop()，shift()、unshift()，concat()\n### join()\njoin方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。\n\n```\nvar a = [1, 2, 3, 4];\na.join(' ') // '1 2 3 4'\na.join(' | ') // \"1 | 2 | 3 | 4\"\na.join() // \"1,2,3,4\"\n```\n### map()\nmap方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。\n\n```\nvar numbers = [1, 2, 3];\n\nnumbers.map(function (n) {\n  return n + 1;\n});\n// [2, 3, 4]\n\nnumbers\n// [1, 2, 3]\n```\nmap方法接受一个函数作为参数。该函数调用时，map方法向它传入三个参数：当前成员、当前位置和数组本身。\n\n```\n[1, 2, 3].map(function(elem, index, arr) {\n  return elem * index;\n});\n// [0, 2, 6]\n```\nmap方法还可以接受第二个参数，用来绑定回调函数内部的this变量\n\n```\nvar arr = ['a', 'b', 'c'];\n[1, 2].map(function (e) {\n  return this[e];\n}, arr)\n// ['b', 'c']\n```\n上面代码通过map方法的第二个参数，将回调函数内部的this对象，指向arr数组。\n### Object.keys() & forEach()\nObject.keys()用于获得由对象属性名组成的数组，可与数组遍历相结合使用，用起来效果杠杠滴。\n\n```\n//创建对象\nvar person = {\n    ChineseName: \"wjh\",\n    EnglishName: \"Bruce\",\n    age: 10,\n    school:\"HQ University\"\n}\n//用forEach()进行遍历\nvar keys = Object.keys(person).forEach(function (tz) {\n    console.log(\"person \", tz, \": \", person[tz]);\n});\n```\n把url参数的类对象模式转化为对象\n\n```\nlet keys = Object.keys( to.query );\nif ( keys.length ){\n\t\tquery = '?';\n\t\tkeys.forEach( key => {\n\t\tif( keys.length == 1 ){\n\t\t\t\tquery += `${key}=${to.query[key]}`\n\t\t}else{\n\t\t\t   query += `${key}=${to.query[key]}&`\n\t\t}\n\t})\n}\t\t\t\n```\n### filter()\nfilter方法用于过滤数组成员，满足条件的成员组成一个新数组返回。\n\n它的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。\n\n```\n[1, 2, 3, 4, 5].filter(function (elem) {\n  return (elem > 3);\n})\n// [4, 5]\n```\n### some()，every()\n这两个方法类似“断言”（assert），返回一个布尔值，表示判断数组成员是否符合某种条件。\n\n它们接受一个函数作为参数，所有数组成员依次执行该函数。该函数接受三个参数：当前成员、当前位置和整个数组，然后返回一个布尔值。\n\nsome方法是只要一个成员的返回值是true，则整个some方法的返回值就是true，否则返回false。\nevery方法是所有成员的返回值都是true，整个every方法才返回true，否则返回false。\n是否是苹果机型的判断\n\n```\nisIphone:function(){\n\t\t\tlet ua = navigator.userAgent,\n\t\t\t\tAgents = [\"iPhone\", \"iPad\", \"iPod\"];\n\t\t\treturn Agents.some(function(v){\n\t\t\t\treturn new RegExp(v,'i').test(ua);\n\t\t\t})\n\t\t}\n```\n### reduce()\nreduce方法和reduceRight方法的第一个参数都是一个函数。该函数接受以下四个参数。\n我们在reduce的第二个参数里面初始了回调函数第一个参数的类型和值\n获取url任意参数值的方法\n\n```\ngetParams:function(){\n            var search = location.href.split(\"?\")[1];\n            if(!search){\n                return {};\n            }\n            var params = search.split(\"&\");\n            return params.reduce(function(res,items){\n                var parts = items.split(\"=\");\n                res[parts[0]] = parts[1] + \"\";\n                return res;\n            },{});\n        },\n```\n{}初始化res为空对象\n## Date对象\n### Date()\nDate对象可以作为普通函数直接调用，返回一个代表当前时间的字符串。\n`·Tue Jun 26 2018 10:19:28 GMT+0800 (中国标准时间)·`\n这个对象里面可以加各种参数，返回的都是如上字符串显示\nDate还可以当作构造函数使用。对它使用new命令，会返回一个Date对象的实例。如果不加参数，实例代表的就是当前时间。\n`new Date();`\n使用\n\n```\ndateFormat:function(time){\n                time = time * 1000 ;\n                time = new Date(time);\n                var year = time.getFullYear(),\n                    month = time.getMonth() + 1,\n                    date = time.getDate(),\n                    hour = time.getHours(),\n                    minute = time.getMinutes(),\n                    second = time.getSeconds(),\n                    m = month >= 10 ? month : \"0\" + month,\n                    d = date >= 10 ? date : \"0\" + date,\n                    h = hour >= 10 ? hour : \"0\" + hour,\n                    mt = minute >= 10 ? minute : \"0\" + minute,\n                    s = second >= 10 ? second : \"0\" + second;\n                return year + \"-\" + m + \"-\" + date + \" \" + h + \":\" + mt + \":\" + s;\n            }\n```\n### Date.now()\nDate.now方法返回当前时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数，相当于 Unix 时间戳乘以1000。\n### Date.parse()\nDate.parse方法用来解析日期字符串，返回该时间距离时间零点（1970年1月1日 00:00:00）的毫秒数。\n\n```\nDate.parse('2018/06/26 23:13:40')\n1530026020000\n```\n### Date.UTC()\nDate.UTC方法接受年、月、日等变量作为参数，返回该时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数。\n\n```\n// 用法\nDate.UTC(2011, 0, 1, 2, 3, 4, 567)\n// 1293847384567\n```\n该方法的参数用法与Date构造函数完全一致，比如月从0开始计算，日期从1开始计算。区别在于Date.UTC方法的参数，会被解释为 UTC 时间（世界标准时间），Date构造函数的参数会被解释为当前时区的时间。\n\nhttp://javascript.ruanyifeng.com/stdlib/date.html\n## RegExp对象\n如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的length属性等于组匹配的数量再加1。\n例子：\n\n```\nvar type = function (o){\n  var s = Object.prototype.toString.call(o);\n  return s.match(/\\[object (.*?)\\]/)[1].toLowerCase();\n};\n\ntype({}); // \"object\"\ntype([]); // \"array\"\n```\n\\s 匹配空格 （包括换行符、制表符、空格符等），相等于[ \\t\\r\\n\\v\\f]\n（1）点字符（.)\n点字符（.）匹配除回车（\\r）、换行(\\n) 、行分隔符（\\u2028）和段分隔符（\\u2029）以外的所有字符。\n（2）位置字符\n位置字符用来提示字符所处的位置，主要有两个字符。\n^ 表示字符串的开始位置\n$ 表示字符串的结束位置\n（3）选择符（|）\n竖线符号（|）在正则表达式中表示“或关系”（OR），即cat|dog表示匹配cat或dog。\n正则表达式中，需要反斜杠转义的，一共有12个字符：^、.、[、$、(、)、|、*、+、?、{和\\\\。\n\n字符类\n字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[xyz] 表示x、y、z之中任选一个匹配。\n量词符\n量词符用来设定某个模式出现的次数。\n\n? 问号表示某个模式出现0次或1次，等同于{0, 1}。\n* 星号表示某个模式出现0次或多次，等同于{0,}。\n+ 加号表示某个模式出现1次或多次，等同于{1,}。\n\n预定义模式指的是某些常见模式的简写方式。\n\\d 匹配0-9之间的任一数字，相当于[0-9]。\n\\D 匹配所有0-9以外的字符，相当于[^0-9]。\n\\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。\n\\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。\n\\s 匹配空格（包括换行符、制表符、空格符等），相等于[ \\t\\r\\n\\v\\f]。\n\\S 匹配非空格的字符，相当于[^ \\t\\r\\n\\v\\f]。\n\\b 匹配词的边界。\n\\B 匹配非词边界，即在词的内部。\n重复类\n模式的精确匹配次数，使用大括号（{}）表示。{n}表示恰好重复n次，{n,}表示至少重复n次，{n,m}表示重复不少于n次，不多于m次。\n量词符\n量词符用来设定某个模式出现的次数。\n\n? 问号表示某个模式出现0次或1次，等同于{0, 1}。\n* 星号表示某个模式出现0次或多次，等同于{0,}。\n+ 加号表示某个模式出现1次或多次，等同于{1,}。\n\n上一小节的三个量词符，默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。\nvar s = 'aaa';\ns.match(/a+/) // [\"aaa\"]\n上面代码中，模式是/a+/，表示匹配1个a或多个a，那么到底会匹配几个a呢？因为默认是贪婪模式，会一直匹配到字符a不出现为止，所以匹配结果是3个a。\n\n如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。\n\nvar s = 'aaa';\ns.match(/a+?/) // [\"a\"]\n*?：表示某个模式出现0次或多次，匹配时采用非贪婪模式。\n+?：表示某个模式出现1次或多次，匹配时采用非贪婪模式。\n## 包装对象\n使用双重的否运算符（!）也可以将任意值转为对应的布尔值。\n\n```\n!!undefined // false\n!!null // false\n!!0 // false\n!!'' // false\n!!NaN // false\n!!1 // true\n!!'false' // true\n!![] // true\n!!{} // true\n!!function(){} // true\n!!/foo/ // true\n```\nNumber、String和Boolean如果不作为构造函数调用（即调用时不加new），常常用于将任意类型的值转为数值、字符串和布尔值。\n\n```\nNumber(123) // 123\nString('abc') // \"abc\"\nBoolean(true) // true\n```\n总结一下，这三个对象作为构造函数使用（带有new）时，可以将原始类型的值转为对象；作为普通函数使用时（不带有new），可以将任意类型的值，转为原始类型的值。\n### Boolean 函数的类型转换作用\nBoolean对象除了可以作为构造函数，还可以单独使用，将任意值转为布尔值。这时Boolean就是一个单纯的工具方法。\n对于一些特殊值，Boolean对象前面加不加new，会得到完全相反的结果，必须小心\n\n```\nif (Boolean(false)) {\n  console.log('true');\n} // 无输出\n\nif (new Boolean(false)) {\n  console.log('true');\n} // true\n\nif (Boolean(null)) {\n  console.log('true');\n} // 无输出\n\nif (new Boolean(null)) {\n  console.log('true');\n} // true\n```\n## JSON对象\n### Number.prototype.toFixed()\ntoFixed方法先将一个数转为指定位数的小数，然后返回这个小数对应的字符串。\n\n```\n(10).toFixed(2) // \"10.00\"\n10.005.toFixed(2) // \"10.01\"\n```\n使用：转化时间\n\n```\ngetTime(time){\n    return (time/3600).toFixed(2) + '小时';\n}\n```\n## Math对象\nMath是 JavaScript 的原生对象，提供各种数学功能。该对象不是构造函数，不能生成实例，所有的属性和方法都必须在Math对象上调用。\nMath对象提供以下一些静态方法。\n\n```\nMath.abs()：绝对值\nMath.ceil()：向上取整\nMath.floor()：向下取整\nMath.max()：最大值\nMath.min()：最小值\nMath.pow()：指数运算\nMath.sqrt()：平方根\nMath.log()：自然对数\nMath.exp()：e的指数\nMath.round()：四舍五入\nMath.random()：随机数\n```\n### Math.floor()\n方法返回小于参数值的最大整数（地板值）。\n\n```\nMath.floor(3.2) // 3\nMath.floor(-3.2) // -4\n```\n时间倒数取整\n\n```\nh = Math.floor(leftTime/1000/60/60%48),\nm = Math.floor(leftTime/1000/60%60),\ns = Math.floor(leftTime/1000%60);\n```\n### Math.ceil()\n方法返回大于参数值的最小整数（天花板值）。\n\n```\nMath.ceil(3.2) // 4\nMath.ceil(-3.2) // -3\n```\n### Math.round()\nMath.round方法用于四舍五入。\n注意，它对负数的处理（主要是对0.5的处理）。\n\n```\nMath.round(-1.1) // -1\nMath.round(-1.5) // -1\nMath.round(-1.6) // -2\n```\n### Object.prototype.toLocaleString()\n这个方法的主要作用是留出一个接口，让各种不同的对象实现自己版本的toLocaleString，用来返回针对某些地域的特定的值。目前，主要有三个对象自定义了toLocaleString方法。\n返回当地时间的写法模式\n\n```\ndateFormat:function(time){\n            var unixTimestamp = new Date( time*1000 ) ;\n            var commonTime;\n            commonTime = unixTimestamp.toLocaleString(\"zh-CN\");\n            return commonTime;\n        }\n```\n\n```\nvar type = function (o){\n  var s = Object.prototype.toString.call(o);\n  return s.match(/\\[object (.*?)\\]/)[1].toLowerCase();\n};\n\ntype({}); // \"object\"\ntype([]); // \"array\"\ntype(5); // \"number\"\ntype(null); // \"null\"\ntype(); // \"undefined\"\ntype(/abcd/); // \"regex\"\ntype(new Date()); // \"date\"\n```\n#### location\n`let curPath = location.pathname;`\n如：\n\n```\nhttp://localhost:8081/courseIndex?channel=123&lin=linziying\nlocation.pathname\n\"/courseIndex\"\nlocation.search\n\"?channel=1524653365&lin=linziying\"\n\nhttp://localhost:8081/home/index/index\nlocation.pathname\n\"/home/index/index\"\nlocation.origin\n\"http://localhost:8081\"\nlocation.host\n\"localhost:8081\"\n```\n### replace\n是字符串写在前面，字符串的实例方法\nString.prototype.replace()：按照给定的正则表达式进行替换，返回替换后的字符串\n字符串对象的replace方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容。\n下面再来说location.replace\nlocation.replace 是替换当前页面，如果a页面 跳转到 b页面  b页面 写location.replace（c） 当点击返回按钮时，就会回到a页面，换句话说，location.replace 是清除了本页面的访问记录，直接回到上一个页面\n如果是 b页面href到c页面的话，按c页面的回退按钮，会回到b页面\n### history 对象\nhistory.replaceState\n\n```\nif( window.history && history.pushState ){\n\thistory.replaceState({state:1},'','/usercateList');\n}\n```\n## DOM 模型概述\n\n## 错误处理机制\n### try…catch 结构\n一旦发生错误，程序就中止执行了。JavaScript 提供了try...catch结构，允许对错误进行处理，选择是否往下执行。\n\n如果你不确定某些代码是否会报错，就可以把它们放在try...catch代码块之中，便于进一步对错误进行处理。因为一旦报错js会阻塞，然后就卡在那里不执行。\n例如json.parse方法，ocalStorage.setItem在iphone的混合模式下会报错，以及下面这个\n\n```\ndateFormat:function(time){\n    var unixTimestamp = new Date( time*1000 ) ;\n    var commonTime;\n    try{\n        commonTime = unixTimestamp.toLocaleString(\"zh-CN\");\n    }catch(err){\n        console.log(err);\n        commonTime = unixTimestamp.toLocaleString();\n    }\n    return commonTime;\n},\n```\n### document.referrer\n此返回上一页相关HTML代码如下：\n\n```\n<a href=\"javascript:history.go(-1)\" class=\"header-back jsBack\">返回</a>\n```\n在大部分场景下，上面办法可以满足我们的交互需求，但是，在有些时候，上面的代码就有些心有力而气不足，因为当前页面的referrer并不总是存在的。\n\n比方说用户是通过微信分享进来的，直接进入了内页，此时是没有上一页的，返回按钮再怎么点击都没有任何反应，就会让用户很奇怪，十有八九会认为是实现了bug，则会让用户对产品的品质抱有疑虑，那问题可就大了。\n\n怎么办呢！后来我想了一招，那就是如果发现浏览器没有上一页来源信息，我们就把返回按钮的链接改成首页的链接地址，这样无论什么时候，用户点击返回按钮一定是会有反应的，并且返回首页从逻辑上讲也是合情合理的。而这里判断是否有没有来源信息就是使用这里的document.referrer，当浏览器得不到上一页的来源信息的时候，document.referrer的返回值就是空字符串''，于是乎，就有类似下面的代码：\n\n```\nif (document.referrer === '') {\n    // 没有来源页面信息的时候，改成首页URL地址\n    $('.jsBack').attr('href', '/');\n}\n```\n### ajax与HTML5 history pushState/replaceState实例\n\n```\n\nJS代码：\nvar eleMenus = $(\"#choMenu a\").bind(\"click\", function(event) {\n    var query = this.href.split(\"?\")[1];\n    if (history.pushState && query && !$(this).hasClass(clMenuOn)) {\n        /*\n            ajax载入~~\n        */\n        \n        // history处理\n        var title = \"上海3月开盘项目汇总-\" + $(this).text().replace(/\\d+$/, \"\");\n        document.title = title;\n        if (event && /\\d/.test(event.button)) {            \n            history.pushState({ title: title }, title, location.href.split(\"?\")[0] + \"?\" + query);\n        }\n    }\n    return false;\n});\n\nvar fnHashTrigger = function(target) {\n    var query = location.href.split(\"?\")[1], eleTarget = target || null;\n    if (typeof query == \"undefined\") {\n        if (eleTarget = eleMenus.get(0)) {\n            // 如果没有查询字符，则使用第一个导航元素的查询字符内容\n            history.replaceState(null, document.title, location.href.split(\"#\")[0] + \"?\" + eleTarget.href.split(\"?\")[1]) + location.hash;    \n            fnHashTrigger(eleTarget);\n        }\n    } else {\n        eleMenus.each(function() {\n            if (eleTarget === null && this.href.split(\"?\")[1] === query) {\n                eleTarget = this;\n            }\n        });\n        \n        if (!eleTarget) {\n            // 如果查询序列没有对应的导航菜单，去除查询然后执行回调\n            history.replaceState(null, document.title, location.href.split(\"?\")[0]);    \n            fnHashTrigger();\n        } else {\n            $(eleTarget).trigger(\"click\");\n        }        \n    }    \n};\nif (history.pushState) {\n    window.addEventListener(\"popstate\", function() {\n        fnHashTrigger();                             \n    });\n    \n    // 默认载入\n    fnHashTrigger();\n}\n```\n```\nhistory.pushState({page: 4}, \"title 1\", \"\");\n\t\t\t\tif ( window.history && window.history.pushState ) {\n\t\t\t\t\twindow.addEventListener(\"popstate\", function () {\n\t\t\t\t\t\thistory.replaceState({page: 4}, \"title 1\", location.href);\n\t\t\t\t\t\tlocation.href = \"/\";\n\t\t\t\t\t});\n\t\t\t\t}\n```\npushState会促发popstate事件监听，pushState会在历史里面添加记录，返回时是进入到这个地址，而replaceState虽然能改变浏览器url地址但是并不会添加进历史，回退不会进入相应的地址。\n### 类的使用\n\n","source":"_posts/js.md","raw":"title: js基础\ndate: 2018-06-28\ntag:\n - js\n\nphotos:\n - /img/2017/6.jpg\n\n---\n\njs基础备忘\n\n<!--more-->\n\n### valueOf()\nvalueOf方法是一个所有对象都拥有的方法，表示对该对象求值。不同对象的valueOf方法不尽一致，数组的valueOf方法返回数组本身。\n\n```\nvar arr = [1, 2, 3];\narr.valueOf() // [1, 2, 3]\n```\n日期对象\nvalueOf方法返回实例对象距离时间零点（1970年1月1日00:00:00 UTC）对应的毫秒数，该方法等同于getTime方法\n\n```\nnew Date()\nThu Jun 21 2018 16:43:00 GMT+0800 (中国标准时间)\nnew Date().valueOf()\n1529570590072\n```\n### toString()\ntoString方法也是对象的通用方法，数组的toString方法返回数组的字符串形式。\n\n```\nvar arr = [1, 2, 3];\narr.toString() // \"1,2,3\"\n\nvar arr = [1, 2, 3, [4, 5, 6]];\narr.toString() // \"1,2,3,4,5,6\"\n```\n```\nnew Date()\nThu Jun 21 2018 16:43:00 GMT+0800 (中国标准时间)\nnew Date().valueOf()\n1529570590072\nvar a = 1;\nundefined\na.toString();\n\"1\"\nnew Date().toString()\n\"Thu Jun 21 2018 17:15:52 GMT+0800 (中国标准时间)\"\n```\n### slice()\nslice方法用于提取目标数组的一部分，返回一个新数组，原数组不变。\n\n```\nvar a = ['a', 'b', 'c'];\na.slice(0) // [\"a\", \"b\", \"c\"]\na.slice(1) // [\"b\", \"c\"]\n```\n`String.prototype.slice()`\nslice方法用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。\n\n```\n'JavaScript'.slice(0, 4) // \"Java\"\n```\n控制文字长度\n\n```\n{{item.user_name.slice(0,4)}}\n```\n### indexOf()\nindexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。\n\n```\nvar a = ['a', 'b', 'c'];\na.indexOf('b') // 1\na.indexOf('y') // -1\n```\n`String.prototype.indexOf()`\n\nindexOf方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回-1，就表示不匹配。\n\n```\n'hello world'.indexOf('o') // 4\n'JavaScript'.indexOf('script') // -1\n```\n截取url\n\n```\nvar index = location.href.indexOf(\"order_id\");\nvar re_url = location.href.slice(0,index);\n```\n根据不同环境设置token\n\n```\nlet host = location.host,token = '';\nif( host.indexOf('localhost') !== -1 || host.indexOf('127.0.0.1') !== -1 ){\n    token = ''\n}\n```\n### splice()\nsplice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。\nsplice的第一个参数是删除的起始位置（从0开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。\n\n```\nvar a = ['a', 'b', 'c', 'd', 'e', 'f'];\na.splice(4, 2) // [\"e\", \"f\"]\na // [\"a\", \"b\", \"c\", \"d\"]\n```\n### push()、pop()，shift()、unshift()，concat()\n### join()\njoin方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。\n\n```\nvar a = [1, 2, 3, 4];\na.join(' ') // '1 2 3 4'\na.join(' | ') // \"1 | 2 | 3 | 4\"\na.join() // \"1,2,3,4\"\n```\n### map()\nmap方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。\n\n```\nvar numbers = [1, 2, 3];\n\nnumbers.map(function (n) {\n  return n + 1;\n});\n// [2, 3, 4]\n\nnumbers\n// [1, 2, 3]\n```\nmap方法接受一个函数作为参数。该函数调用时，map方法向它传入三个参数：当前成员、当前位置和数组本身。\n\n```\n[1, 2, 3].map(function(elem, index, arr) {\n  return elem * index;\n});\n// [0, 2, 6]\n```\nmap方法还可以接受第二个参数，用来绑定回调函数内部的this变量\n\n```\nvar arr = ['a', 'b', 'c'];\n[1, 2].map(function (e) {\n  return this[e];\n}, arr)\n// ['b', 'c']\n```\n上面代码通过map方法的第二个参数，将回调函数内部的this对象，指向arr数组。\n### Object.keys() & forEach()\nObject.keys()用于获得由对象属性名组成的数组，可与数组遍历相结合使用，用起来效果杠杠滴。\n\n```\n//创建对象\nvar person = {\n    ChineseName: \"wjh\",\n    EnglishName: \"Bruce\",\n    age: 10,\n    school:\"HQ University\"\n}\n//用forEach()进行遍历\nvar keys = Object.keys(person).forEach(function (tz) {\n    console.log(\"person \", tz, \": \", person[tz]);\n});\n```\n把url参数的类对象模式转化为对象\n\n```\nlet keys = Object.keys( to.query );\nif ( keys.length ){\n\t\tquery = '?';\n\t\tkeys.forEach( key => {\n\t\tif( keys.length == 1 ){\n\t\t\t\tquery += `${key}=${to.query[key]}`\n\t\t}else{\n\t\t\t   query += `${key}=${to.query[key]}&`\n\t\t}\n\t})\n}\t\t\t\n```\n### filter()\nfilter方法用于过滤数组成员，满足条件的成员组成一个新数组返回。\n\n它的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。\n\n```\n[1, 2, 3, 4, 5].filter(function (elem) {\n  return (elem > 3);\n})\n// [4, 5]\n```\n### some()，every()\n这两个方法类似“断言”（assert），返回一个布尔值，表示判断数组成员是否符合某种条件。\n\n它们接受一个函数作为参数，所有数组成员依次执行该函数。该函数接受三个参数：当前成员、当前位置和整个数组，然后返回一个布尔值。\n\nsome方法是只要一个成员的返回值是true，则整个some方法的返回值就是true，否则返回false。\nevery方法是所有成员的返回值都是true，整个every方法才返回true，否则返回false。\n是否是苹果机型的判断\n\n```\nisIphone:function(){\n\t\t\tlet ua = navigator.userAgent,\n\t\t\t\tAgents = [\"iPhone\", \"iPad\", \"iPod\"];\n\t\t\treturn Agents.some(function(v){\n\t\t\t\treturn new RegExp(v,'i').test(ua);\n\t\t\t})\n\t\t}\n```\n### reduce()\nreduce方法和reduceRight方法的第一个参数都是一个函数。该函数接受以下四个参数。\n我们在reduce的第二个参数里面初始了回调函数第一个参数的类型和值\n获取url任意参数值的方法\n\n```\ngetParams:function(){\n            var search = location.href.split(\"?\")[1];\n            if(!search){\n                return {};\n            }\n            var params = search.split(\"&\");\n            return params.reduce(function(res,items){\n                var parts = items.split(\"=\");\n                res[parts[0]] = parts[1] + \"\";\n                return res;\n            },{});\n        },\n```\n{}初始化res为空对象\n## Date对象\n### Date()\nDate对象可以作为普通函数直接调用，返回一个代表当前时间的字符串。\n`·Tue Jun 26 2018 10:19:28 GMT+0800 (中国标准时间)·`\n这个对象里面可以加各种参数，返回的都是如上字符串显示\nDate还可以当作构造函数使用。对它使用new命令，会返回一个Date对象的实例。如果不加参数，实例代表的就是当前时间。\n`new Date();`\n使用\n\n```\ndateFormat:function(time){\n                time = time * 1000 ;\n                time = new Date(time);\n                var year = time.getFullYear(),\n                    month = time.getMonth() + 1,\n                    date = time.getDate(),\n                    hour = time.getHours(),\n                    minute = time.getMinutes(),\n                    second = time.getSeconds(),\n                    m = month >= 10 ? month : \"0\" + month,\n                    d = date >= 10 ? date : \"0\" + date,\n                    h = hour >= 10 ? hour : \"0\" + hour,\n                    mt = minute >= 10 ? minute : \"0\" + minute,\n                    s = second >= 10 ? second : \"0\" + second;\n                return year + \"-\" + m + \"-\" + date + \" \" + h + \":\" + mt + \":\" + s;\n            }\n```\n### Date.now()\nDate.now方法返回当前时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数，相当于 Unix 时间戳乘以1000。\n### Date.parse()\nDate.parse方法用来解析日期字符串，返回该时间距离时间零点（1970年1月1日 00:00:00）的毫秒数。\n\n```\nDate.parse('2018/06/26 23:13:40')\n1530026020000\n```\n### Date.UTC()\nDate.UTC方法接受年、月、日等变量作为参数，返回该时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数。\n\n```\n// 用法\nDate.UTC(2011, 0, 1, 2, 3, 4, 567)\n// 1293847384567\n```\n该方法的参数用法与Date构造函数完全一致，比如月从0开始计算，日期从1开始计算。区别在于Date.UTC方法的参数，会被解释为 UTC 时间（世界标准时间），Date构造函数的参数会被解释为当前时区的时间。\n\nhttp://javascript.ruanyifeng.com/stdlib/date.html\n## RegExp对象\n如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的length属性等于组匹配的数量再加1。\n例子：\n\n```\nvar type = function (o){\n  var s = Object.prototype.toString.call(o);\n  return s.match(/\\[object (.*?)\\]/)[1].toLowerCase();\n};\n\ntype({}); // \"object\"\ntype([]); // \"array\"\n```\n\\s 匹配空格 （包括换行符、制表符、空格符等），相等于[ \\t\\r\\n\\v\\f]\n（1）点字符（.)\n点字符（.）匹配除回车（\\r）、换行(\\n) 、行分隔符（\\u2028）和段分隔符（\\u2029）以外的所有字符。\n（2）位置字符\n位置字符用来提示字符所处的位置，主要有两个字符。\n^ 表示字符串的开始位置\n$ 表示字符串的结束位置\n（3）选择符（|）\n竖线符号（|）在正则表达式中表示“或关系”（OR），即cat|dog表示匹配cat或dog。\n正则表达式中，需要反斜杠转义的，一共有12个字符：^、.、[、$、(、)、|、*、+、?、{和\\\\。\n\n字符类\n字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[xyz] 表示x、y、z之中任选一个匹配。\n量词符\n量词符用来设定某个模式出现的次数。\n\n? 问号表示某个模式出现0次或1次，等同于{0, 1}。\n* 星号表示某个模式出现0次或多次，等同于{0,}。\n+ 加号表示某个模式出现1次或多次，等同于{1,}。\n\n预定义模式指的是某些常见模式的简写方式。\n\\d 匹配0-9之间的任一数字，相当于[0-9]。\n\\D 匹配所有0-9以外的字符，相当于[^0-9]。\n\\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。\n\\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。\n\\s 匹配空格（包括换行符、制表符、空格符等），相等于[ \\t\\r\\n\\v\\f]。\n\\S 匹配非空格的字符，相当于[^ \\t\\r\\n\\v\\f]。\n\\b 匹配词的边界。\n\\B 匹配非词边界，即在词的内部。\n重复类\n模式的精确匹配次数，使用大括号（{}）表示。{n}表示恰好重复n次，{n,}表示至少重复n次，{n,m}表示重复不少于n次，不多于m次。\n量词符\n量词符用来设定某个模式出现的次数。\n\n? 问号表示某个模式出现0次或1次，等同于{0, 1}。\n* 星号表示某个模式出现0次或多次，等同于{0,}。\n+ 加号表示某个模式出现1次或多次，等同于{1,}。\n\n上一小节的三个量词符，默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。\nvar s = 'aaa';\ns.match(/a+/) // [\"aaa\"]\n上面代码中，模式是/a+/，表示匹配1个a或多个a，那么到底会匹配几个a呢？因为默认是贪婪模式，会一直匹配到字符a不出现为止，所以匹配结果是3个a。\n\n如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。\n\nvar s = 'aaa';\ns.match(/a+?/) // [\"a\"]\n*?：表示某个模式出现0次或多次，匹配时采用非贪婪模式。\n+?：表示某个模式出现1次或多次，匹配时采用非贪婪模式。\n## 包装对象\n使用双重的否运算符（!）也可以将任意值转为对应的布尔值。\n\n```\n!!undefined // false\n!!null // false\n!!0 // false\n!!'' // false\n!!NaN // false\n!!1 // true\n!!'false' // true\n!![] // true\n!!{} // true\n!!function(){} // true\n!!/foo/ // true\n```\nNumber、String和Boolean如果不作为构造函数调用（即调用时不加new），常常用于将任意类型的值转为数值、字符串和布尔值。\n\n```\nNumber(123) // 123\nString('abc') // \"abc\"\nBoolean(true) // true\n```\n总结一下，这三个对象作为构造函数使用（带有new）时，可以将原始类型的值转为对象；作为普通函数使用时（不带有new），可以将任意类型的值，转为原始类型的值。\n### Boolean 函数的类型转换作用\nBoolean对象除了可以作为构造函数，还可以单独使用，将任意值转为布尔值。这时Boolean就是一个单纯的工具方法。\n对于一些特殊值，Boolean对象前面加不加new，会得到完全相反的结果，必须小心\n\n```\nif (Boolean(false)) {\n  console.log('true');\n} // 无输出\n\nif (new Boolean(false)) {\n  console.log('true');\n} // true\n\nif (Boolean(null)) {\n  console.log('true');\n} // 无输出\n\nif (new Boolean(null)) {\n  console.log('true');\n} // true\n```\n## JSON对象\n### Number.prototype.toFixed()\ntoFixed方法先将一个数转为指定位数的小数，然后返回这个小数对应的字符串。\n\n```\n(10).toFixed(2) // \"10.00\"\n10.005.toFixed(2) // \"10.01\"\n```\n使用：转化时间\n\n```\ngetTime(time){\n    return (time/3600).toFixed(2) + '小时';\n}\n```\n## Math对象\nMath是 JavaScript 的原生对象，提供各种数学功能。该对象不是构造函数，不能生成实例，所有的属性和方法都必须在Math对象上调用。\nMath对象提供以下一些静态方法。\n\n```\nMath.abs()：绝对值\nMath.ceil()：向上取整\nMath.floor()：向下取整\nMath.max()：最大值\nMath.min()：最小值\nMath.pow()：指数运算\nMath.sqrt()：平方根\nMath.log()：自然对数\nMath.exp()：e的指数\nMath.round()：四舍五入\nMath.random()：随机数\n```\n### Math.floor()\n方法返回小于参数值的最大整数（地板值）。\n\n```\nMath.floor(3.2) // 3\nMath.floor(-3.2) // -4\n```\n时间倒数取整\n\n```\nh = Math.floor(leftTime/1000/60/60%48),\nm = Math.floor(leftTime/1000/60%60),\ns = Math.floor(leftTime/1000%60);\n```\n### Math.ceil()\n方法返回大于参数值的最小整数（天花板值）。\n\n```\nMath.ceil(3.2) // 4\nMath.ceil(-3.2) // -3\n```\n### Math.round()\nMath.round方法用于四舍五入。\n注意，它对负数的处理（主要是对0.5的处理）。\n\n```\nMath.round(-1.1) // -1\nMath.round(-1.5) // -1\nMath.round(-1.6) // -2\n```\n### Object.prototype.toLocaleString()\n这个方法的主要作用是留出一个接口，让各种不同的对象实现自己版本的toLocaleString，用来返回针对某些地域的特定的值。目前，主要有三个对象自定义了toLocaleString方法。\n返回当地时间的写法模式\n\n```\ndateFormat:function(time){\n            var unixTimestamp = new Date( time*1000 ) ;\n            var commonTime;\n            commonTime = unixTimestamp.toLocaleString(\"zh-CN\");\n            return commonTime;\n        }\n```\n\n```\nvar type = function (o){\n  var s = Object.prototype.toString.call(o);\n  return s.match(/\\[object (.*?)\\]/)[1].toLowerCase();\n};\n\ntype({}); // \"object\"\ntype([]); // \"array\"\ntype(5); // \"number\"\ntype(null); // \"null\"\ntype(); // \"undefined\"\ntype(/abcd/); // \"regex\"\ntype(new Date()); // \"date\"\n```\n#### location\n`let curPath = location.pathname;`\n如：\n\n```\nhttp://localhost:8081/courseIndex?channel=123&lin=linziying\nlocation.pathname\n\"/courseIndex\"\nlocation.search\n\"?channel=1524653365&lin=linziying\"\n\nhttp://localhost:8081/home/index/index\nlocation.pathname\n\"/home/index/index\"\nlocation.origin\n\"http://localhost:8081\"\nlocation.host\n\"localhost:8081\"\n```\n### replace\n是字符串写在前面，字符串的实例方法\nString.prototype.replace()：按照给定的正则表达式进行替换，返回替换后的字符串\n字符串对象的replace方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容。\n下面再来说location.replace\nlocation.replace 是替换当前页面，如果a页面 跳转到 b页面  b页面 写location.replace（c） 当点击返回按钮时，就会回到a页面，换句话说，location.replace 是清除了本页面的访问记录，直接回到上一个页面\n如果是 b页面href到c页面的话，按c页面的回退按钮，会回到b页面\n### history 对象\nhistory.replaceState\n\n```\nif( window.history && history.pushState ){\n\thistory.replaceState({state:1},'','/usercateList');\n}\n```\n## DOM 模型概述\n\n## 错误处理机制\n### try…catch 结构\n一旦发生错误，程序就中止执行了。JavaScript 提供了try...catch结构，允许对错误进行处理，选择是否往下执行。\n\n如果你不确定某些代码是否会报错，就可以把它们放在try...catch代码块之中，便于进一步对错误进行处理。因为一旦报错js会阻塞，然后就卡在那里不执行。\n例如json.parse方法，ocalStorage.setItem在iphone的混合模式下会报错，以及下面这个\n\n```\ndateFormat:function(time){\n    var unixTimestamp = new Date( time*1000 ) ;\n    var commonTime;\n    try{\n        commonTime = unixTimestamp.toLocaleString(\"zh-CN\");\n    }catch(err){\n        console.log(err);\n        commonTime = unixTimestamp.toLocaleString();\n    }\n    return commonTime;\n},\n```\n### document.referrer\n此返回上一页相关HTML代码如下：\n\n```\n<a href=\"javascript:history.go(-1)\" class=\"header-back jsBack\">返回</a>\n```\n在大部分场景下，上面办法可以满足我们的交互需求，但是，在有些时候，上面的代码就有些心有力而气不足，因为当前页面的referrer并不总是存在的。\n\n比方说用户是通过微信分享进来的，直接进入了内页，此时是没有上一页的，返回按钮再怎么点击都没有任何反应，就会让用户很奇怪，十有八九会认为是实现了bug，则会让用户对产品的品质抱有疑虑，那问题可就大了。\n\n怎么办呢！后来我想了一招，那就是如果发现浏览器没有上一页来源信息，我们就把返回按钮的链接改成首页的链接地址，这样无论什么时候，用户点击返回按钮一定是会有反应的，并且返回首页从逻辑上讲也是合情合理的。而这里判断是否有没有来源信息就是使用这里的document.referrer，当浏览器得不到上一页的来源信息的时候，document.referrer的返回值就是空字符串''，于是乎，就有类似下面的代码：\n\n```\nif (document.referrer === '') {\n    // 没有来源页面信息的时候，改成首页URL地址\n    $('.jsBack').attr('href', '/');\n}\n```\n### ajax与HTML5 history pushState/replaceState实例\n\n```\n\nJS代码：\nvar eleMenus = $(\"#choMenu a\").bind(\"click\", function(event) {\n    var query = this.href.split(\"?\")[1];\n    if (history.pushState && query && !$(this).hasClass(clMenuOn)) {\n        /*\n            ajax载入~~\n        */\n        \n        // history处理\n        var title = \"上海3月开盘项目汇总-\" + $(this).text().replace(/\\d+$/, \"\");\n        document.title = title;\n        if (event && /\\d/.test(event.button)) {            \n            history.pushState({ title: title }, title, location.href.split(\"?\")[0] + \"?\" + query);\n        }\n    }\n    return false;\n});\n\nvar fnHashTrigger = function(target) {\n    var query = location.href.split(\"?\")[1], eleTarget = target || null;\n    if (typeof query == \"undefined\") {\n        if (eleTarget = eleMenus.get(0)) {\n            // 如果没有查询字符，则使用第一个导航元素的查询字符内容\n            history.replaceState(null, document.title, location.href.split(\"#\")[0] + \"?\" + eleTarget.href.split(\"?\")[1]) + location.hash;    \n            fnHashTrigger(eleTarget);\n        }\n    } else {\n        eleMenus.each(function() {\n            if (eleTarget === null && this.href.split(\"?\")[1] === query) {\n                eleTarget = this;\n            }\n        });\n        \n        if (!eleTarget) {\n            // 如果查询序列没有对应的导航菜单，去除查询然后执行回调\n            history.replaceState(null, document.title, location.href.split(\"?\")[0]);    \n            fnHashTrigger();\n        } else {\n            $(eleTarget).trigger(\"click\");\n        }        \n    }    \n};\nif (history.pushState) {\n    window.addEventListener(\"popstate\", function() {\n        fnHashTrigger();                             \n    });\n    \n    // 默认载入\n    fnHashTrigger();\n}\n```\n```\nhistory.pushState({page: 4}, \"title 1\", \"\");\n\t\t\t\tif ( window.history && window.history.pushState ) {\n\t\t\t\t\twindow.addEventListener(\"popstate\", function () {\n\t\t\t\t\t\thistory.replaceState({page: 4}, \"title 1\", location.href);\n\t\t\t\t\t\tlocation.href = \"/\";\n\t\t\t\t\t});\n\t\t\t\t}\n```\npushState会促发popstate事件监听，pushState会在历史里面添加记录，返回时是进入到这个地址，而replaceState虽然能改变浏览器url地址但是并不会添加进历史，回退不会进入相应的地址。\n### 类的使用\n\n","slug":"js","published":1,"updated":"2018-08-28T10:16:33.910Z","_id":"cjldh03ro000iuv6x9fr2bfj8","comments":1,"layout":"post","link":"","content":"<p>js基础备忘</p>\n<a id=\"more\"></a>\n<h3 id=\"valueOf-NaN\"><a href=\"#valueOf-NaN\" class=\"headerlink\" title=\"valueOf()\"></a>valueOf()</h3><p>valueOf方法是一个所有对象都拥有的方法，表示对该对象求值。不同对象的valueOf方法不尽一致，数组的valueOf方法返回数组本身。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3];</span><br><span class=\"line\">arr.valueOf() // [1, 2, 3]</span><br></pre></td></tr></table></figure>\n<p>日期对象<br>valueOf方法返回实例对象距离时间零点（1970年1月1日00:00:00 UTC）对应的毫秒数，该方法等同于getTime方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">new Date()</span><br><span class=\"line\">Thu Jun 21 2018 16:43:00 GMT+0800 (中国标准时间)</span><br><span class=\"line\">new Date().valueOf()</span><br><span class=\"line\">1529570590072</span><br></pre></td></tr></table></figure>\n<h3 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString()\"></a>toString()</h3><p>toString方法也是对象的通用方法，数组的toString方法返回数组的字符串形式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3];</span><br><span class=\"line\">arr.toString() // &quot;1,2,3&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">var arr = [1, 2, 3, [4, 5, 6]];</span><br><span class=\"line\">arr.toString() // &quot;1,2,3,4,5,6&quot;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">new Date()</span><br><span class=\"line\">Thu Jun 21 2018 16:43:00 GMT+0800 (中国标准时间)</span><br><span class=\"line\">new Date().valueOf()</span><br><span class=\"line\">1529570590072</span><br><span class=\"line\">var a = 1;</span><br><span class=\"line\">undefined</span><br><span class=\"line\">a.toString();</span><br><span class=\"line\">&quot;1&quot;</span><br><span class=\"line\">new Date().toString()</span><br><span class=\"line\">&quot;Thu Jun 21 2018 17:15:52 GMT+0800 (中国标准时间)&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice()\"></a>slice()</h3><p>slice方法用于提取目标数组的一部分，返回一个新数组，原数组不变。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class=\"line\">a.slice(0) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class=\"line\">a.slice(1) // [&quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure>\n<p><code>String.prototype.slice()</code><br>slice方法用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&apos;JavaScript&apos;.slice(0, 4) // &quot;Java&quot;</span><br></pre></td></tr></table></figure>\n<p>控制文字长度</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;&#123;item.user_name.slice(0,4)&#125;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"indexOf\"><a href=\"#indexOf\" class=\"headerlink\" title=\"indexOf()\"></a>indexOf()</h3><p>indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class=\"line\">a.indexOf(&apos;b&apos;) // 1</span><br><span class=\"line\">a.indexOf(&apos;y&apos;) // -1</span><br></pre></td></tr></table></figure>\n<p><code>String.prototype.indexOf()</code></p>\n<p>indexOf方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回-1，就表示不匹配。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&apos;hello world&apos;.indexOf(&apos;o&apos;) // 4</span><br><span class=\"line\">&apos;JavaScript&apos;.indexOf(&apos;script&apos;) // -1</span><br></pre></td></tr></table></figure>\n<p>截取url</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var index = location.href.indexOf(&quot;order_id&quot;);</span><br><span class=\"line\">var re_url = location.href.slice(0,index);</span><br></pre></td></tr></table></figure>\n<p>根据不同环境设置token</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let host = location.host,token = &apos;&apos;;</span><br><span class=\"line\">if( host.indexOf(&apos;localhost&apos;) !== -1 || host.indexOf(&apos;127.0.0.1&apos;) !== -1 )&#123;</span><br><span class=\"line\">    token = &apos;&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"splice\"><a href=\"#splice\" class=\"headerlink\" title=\"splice()\"></a>splice()</h3><p>splice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。<br>splice的第一个参数是删除的起始位置（从0开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;];</span><br><span class=\"line\">a.splice(4, 2) // [&quot;e&quot;, &quot;f&quot;]</span><br><span class=\"line\">a // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span><br></pre></td></tr></table></figure>\n<h3 id=\"push-、pop-，shift-、unshift-，concat\"><a href=\"#push-、pop-，shift-、unshift-，concat\" class=\"headerlink\" title=\"push()、pop()，shift()、unshift()，concat()\"></a>push()、pop()，shift()、unshift()，concat()</h3><h3 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join()\"></a>join()</h3><p>join方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = [1, 2, 3, 4];</span><br><span class=\"line\">a.join(&apos; &apos;) // &apos;1 2 3 4&apos;</span><br><span class=\"line\">a.join(&apos; | &apos;) // &quot;1 | 2 | 3 | 4&quot;</span><br><span class=\"line\">a.join() // &quot;1,2,3,4&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map()\"></a>map()</h3><p>map方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var numbers = [1, 2, 3];</span><br><span class=\"line\"></span><br><span class=\"line\">numbers.map(function (n) &#123;</span><br><span class=\"line\">  return n + 1;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// [2, 3, 4]</span><br><span class=\"line\"></span><br><span class=\"line\">numbers</span><br><span class=\"line\">// [1, 2, 3]</span><br></pre></td></tr></table></figure>\n<p>map方法接受一个函数作为参数。该函数调用时，map方法向它传入三个参数：当前成员、当前位置和数组本身。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[1, 2, 3].map(function(elem, index, arr) &#123;</span><br><span class=\"line\">  return elem * index;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// [0, 2, 6]</span><br></pre></td></tr></table></figure>\n<p>map方法还可以接受第二个参数，用来绑定回调函数内部的this变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class=\"line\">[1, 2].map(function (e) &#123;</span><br><span class=\"line\">  return this[e];</span><br><span class=\"line\">&#125;, arr)</span><br><span class=\"line\">// [&apos;b&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure>\n<p>上面代码通过map方法的第二个参数，将回调函数内部的this对象，指向arr数组。</p>\n<h3 id=\"Object-keys-amp-forEach\"><a href=\"#Object-keys-amp-forEach\" class=\"headerlink\" title=\"Object.keys() &amp; forEach()\"></a>Object.keys() &amp; forEach()</h3><p>Object.keys()用于获得由对象属性名组成的数组，可与数组遍历相结合使用，用起来效果杠杠滴。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//创建对象</span><br><span class=\"line\">var person = &#123;</span><br><span class=\"line\">    ChineseName: &quot;wjh&quot;,</span><br><span class=\"line\">    EnglishName: &quot;Bruce&quot;,</span><br><span class=\"line\">    age: 10,</span><br><span class=\"line\">    school:&quot;HQ University&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//用forEach()进行遍历</span><br><span class=\"line\">var keys = Object.keys(person).forEach(function (tz) &#123;</span><br><span class=\"line\">    console.log(&quot;person &quot;, tz, &quot;: &quot;, person[tz]);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>把url参数的类对象模式转化为对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let keys = Object.keys( to.query );</span><br><span class=\"line\">if ( keys.length )&#123;</span><br><span class=\"line\">\t\tquery = &apos;?&apos;;</span><br><span class=\"line\">\t\tkeys.forEach( key =&gt; &#123;</span><br><span class=\"line\">\t\tif( keys.length == 1 )&#123;</span><br><span class=\"line\">\t\t\t\tquery += `$&#123;key&#125;=$&#123;to.query[key]&#125;`</span><br><span class=\"line\">\t\t&#125;else&#123;</span><br><span class=\"line\">\t\t\t   query += `$&#123;key&#125;=$&#123;to.query[key]&#125;&amp;`</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter()\"></a>filter()</h3><p>filter方法用于过滤数组成员，满足条件的成员组成一个新数组返回。</p>\n<p>它的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[1, 2, 3, 4, 5].filter(function (elem) &#123;</span><br><span class=\"line\">  return (elem &gt; 3);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// [4, 5]</span><br></pre></td></tr></table></figure>\n<h3 id=\"some-，every\"><a href=\"#some-，every\" class=\"headerlink\" title=\"some()，every()\"></a>some()，every()</h3><p>这两个方法类似“断言”（assert），返回一个布尔值，表示判断数组成员是否符合某种条件。</p>\n<p>它们接受一个函数作为参数，所有数组成员依次执行该函数。该函数接受三个参数：当前成员、当前位置和整个数组，然后返回一个布尔值。</p>\n<p>some方法是只要一个成员的返回值是true，则整个some方法的返回值就是true，否则返回false。<br>every方法是所有成员的返回值都是true，整个every方法才返回true，否则返回false。<br>是否是苹果机型的判断</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">isIphone:function()&#123;</span><br><span class=\"line\">\t\t\tlet ua = navigator.userAgent,</span><br><span class=\"line\">\t\t\t\tAgents = [&quot;iPhone&quot;, &quot;iPad&quot;, &quot;iPod&quot;];</span><br><span class=\"line\">\t\t\treturn Agents.some(function(v)&#123;</span><br><span class=\"line\">\t\t\t\treturn new RegExp(v,&apos;i&apos;).test(ua);</span><br><span class=\"line\">\t\t\t&#125;)</span><br><span class=\"line\">\t\t&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce()\"></a>reduce()</h3><p>reduce方法和reduceRight方法的第一个参数都是一个函数。该函数接受以下四个参数。<br>我们在reduce的第二个参数里面初始了回调函数第一个参数的类型和值<br>获取url任意参数值的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">getParams:function()&#123;</span><br><span class=\"line\">            var search = location.href.split(&quot;?&quot;)[1];</span><br><span class=\"line\">            if(!search)&#123;</span><br><span class=\"line\">                return &#123;&#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            var params = search.split(&quot;&amp;&quot;);</span><br><span class=\"line\">            return params.reduce(function(res,items)&#123;</span><br><span class=\"line\">                var parts = items.split(&quot;=&quot;);</span><br><span class=\"line\">                res[parts[0]] = parts[1] + &quot;&quot;;</span><br><span class=\"line\">                return res;</span><br><span class=\"line\">            &#125;,&#123;&#125;);</span><br><span class=\"line\">        &#125;,</span><br></pre></td></tr></table></figure>\n<p>{}初始化res为空对象</p>\n<h2 id=\"Date对象\"><a href=\"#Date对象\" class=\"headerlink\" title=\"Date对象\"></a>Date对象</h2><h3 id=\"Date\"><a href=\"#Date\" class=\"headerlink\" title=\"Date()\"></a>Date()</h3><p>Date对象可以作为普通函数直接调用，返回一个代表当前时间的字符串。<br><code>·Tue Jun 26 2018 10:19:28 GMT+0800 (中国标准时间)·</code><br>这个对象里面可以加各种参数，返回的都是如上字符串显示<br>Date还可以当作构造函数使用。对它使用new命令，会返回一个Date对象的实例。如果不加参数，实例代表的就是当前时间。<br><code>new Date();</code><br>使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">dateFormat:function(time)&#123;</span><br><span class=\"line\">                time = time * 1000 ;</span><br><span class=\"line\">                time = new Date(time);</span><br><span class=\"line\">                var year = time.getFullYear(),</span><br><span class=\"line\">                    month = time.getMonth() + 1,</span><br><span class=\"line\">                    date = time.getDate(),</span><br><span class=\"line\">                    hour = time.getHours(),</span><br><span class=\"line\">                    minute = time.getMinutes(),</span><br><span class=\"line\">                    second = time.getSeconds(),</span><br><span class=\"line\">                    m = month &gt;= 10 ? month : &quot;0&quot; + month,</span><br><span class=\"line\">                    d = date &gt;= 10 ? date : &quot;0&quot; + date,</span><br><span class=\"line\">                    h = hour &gt;= 10 ? hour : &quot;0&quot; + hour,</span><br><span class=\"line\">                    mt = minute &gt;= 10 ? minute : &quot;0&quot; + minute,</span><br><span class=\"line\">                    s = second &gt;= 10 ? second : &quot;0&quot; + second;</span><br><span class=\"line\">                return year + &quot;-&quot; + m + &quot;-&quot; + date + &quot; &quot; + h + &quot;:&quot; + mt + &quot;:&quot; + s;</span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Date-now\"><a href=\"#Date-now\" class=\"headerlink\" title=\"Date.now()\"></a>Date.now()</h3><p>Date.now方法返回当前时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数，相当于 Unix 时间戳乘以1000。</p>\n<h3 id=\"Date-parse\"><a href=\"#Date-parse\" class=\"headerlink\" title=\"Date.parse()\"></a>Date.parse()</h3><p>Date.parse方法用来解析日期字符串，返回该时间距离时间零点（1970年1月1日 00:00:00）的毫秒数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Date.parse(&apos;2018/06/26 23:13:40&apos;)</span><br><span class=\"line\">1530026020000</span><br></pre></td></tr></table></figure>\n<h3 id=\"Date-UTC\"><a href=\"#Date-UTC\" class=\"headerlink\" title=\"Date.UTC()\"></a>Date.UTC()</h3><p>Date.UTC方法接受年、月、日等变量作为参数，返回该时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 用法</span><br><span class=\"line\">Date.UTC(2011, 0, 1, 2, 3, 4, 567)</span><br><span class=\"line\">// 1293847384567</span><br></pre></td></tr></table></figure>\n<p>该方法的参数用法与Date构造函数完全一致，比如月从0开始计算，日期从1开始计算。区别在于Date.UTC方法的参数，会被解释为 UTC 时间（世界标准时间），Date构造函数的参数会被解释为当前时区的时间。</p>\n<p><a href=\"http://javascript.ruanyifeng.com/stdlib/date.html\" target=\"_blank\" rel=\"noopener\">http://javascript.ruanyifeng.com/stdlib/date.html</a></p>\n<h2 id=\"RegExp对象\"><a href=\"#RegExp对象\" class=\"headerlink\" title=\"RegExp对象\"></a>RegExp对象</h2><p>如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的length属性等于组匹配的数量再加1。<br>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var type = function (o)&#123;</span><br><span class=\"line\">  var s = Object.prototype.toString.call(o);</span><br><span class=\"line\">  return s.match(/\\[object (.*?)\\]/)[1].toLowerCase();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">type(&#123;&#125;); // &quot;object&quot;</span><br><span class=\"line\">type([]); // &quot;array&quot;</span><br></pre></td></tr></table></figure>\n<p>\\s 匹配空格 （包括换行符、制表符、空格符等），相等于[ \\t\\r\\n\\v\\f]<br>（1）点字符（.)<br>点字符（.）匹配除回车（\\r）、换行(\\n) 、行分隔符（\\u2028）和段分隔符（\\u2029）以外的所有字符。<br>（2）位置字符<br>位置字符用来提示字符所处的位置，主要有两个字符。<br>^ 表示字符串的开始位置<br>$ 表示字符串的结束位置<br>（3）选择符（|）<br>竖线符号（|）在正则表达式中表示“或关系”（OR），即cat|dog表示匹配cat或dog。<br>正则表达式中，需要反斜杠转义的，一共有12个字符：^、.、[、$、(、)、|、*、+、?、{和\\。</p>\n<p>字符类<br>字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[xyz] 表示x、y、z之中任选一个匹配。<br>量词符<br>量词符用来设定某个模式出现的次数。</p>\n<p>? 问号表示某个模式出现0次或1次，等同于{0, 1}。</p>\n<ul>\n<li>星号表示某个模式出现0次或多次，等同于{0,}。</li>\n</ul>\n<ul>\n<li>加号表示某个模式出现1次或多次，等同于{1,}。</li>\n</ul>\n<p>预定义模式指的是某些常见模式的简写方式。<br>\\d 匹配0-9之间的任一数字，相当于[0-9]。<br>\\D 匹配所有0-9以外的字符，相当于[^0-9]。<br>\\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。<br>\\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。<br>\\s 匹配空格（包括换行符、制表符、空格符等），相等于[ \\t\\r\\n\\v\\f]。<br>\\S 匹配非空格的字符，相当于[^ \\t\\r\\n\\v\\f]。<br>\\b 匹配词的边界。<br>\\B 匹配非词边界，即在词的内部。<br>重复类<br>模式的精确匹配次数，使用大括号（{}）表示。{n}表示恰好重复n次，{n,}表示至少重复n次，{n,m}表示重复不少于n次，不多于m次。<br>量词符<br>量词符用来设定某个模式出现的次数。</p>\n<p>? 问号表示某个模式出现0次或1次，等同于{0, 1}。</p>\n<ul>\n<li>星号表示某个模式出现0次或多次，等同于{0,}。</li>\n</ul>\n<ul>\n<li>加号表示某个模式出现1次或多次，等同于{1,}。</li>\n</ul>\n<p>上一小节的三个量词符，默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。<br>var s = ‘aaa’;<br>s.match(/a+/) // [“aaa”]<br>上面代码中，模式是/a+/，表示匹配1个a或多个a，那么到底会匹配几个a呢？因为默认是贪婪模式，会一直匹配到字符a不出现为止，所以匹配结果是3个a。</p>\n<p>如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。</p>\n<p>var s = ‘aaa’;<br>s.match(/a+?/) // [“a”]<br>*?：表示某个模式出现0次或多次，匹配时采用非贪婪模式。<br>+?：表示某个模式出现1次或多次，匹配时采用非贪婪模式。</p>\n<h2 id=\"包装对象\"><a href=\"#包装对象\" class=\"headerlink\" title=\"包装对象\"></a>包装对象</h2><p>使用双重的否运算符（!）也可以将任意值转为对应的布尔值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">!!undefined // false</span><br><span class=\"line\">!!null // false</span><br><span class=\"line\">!!0 // false</span><br><span class=\"line\">!!&apos;&apos; // false</span><br><span class=\"line\">!!NaN // false</span><br><span class=\"line\">!!1 // true</span><br><span class=\"line\">!!&apos;false&apos; // true</span><br><span class=\"line\">!![] // true</span><br><span class=\"line\">!!&#123;&#125; // true</span><br><span class=\"line\">!!function()&#123;&#125; // true</span><br><span class=\"line\">!!/foo/ // true</span><br></pre></td></tr></table></figure>\n<p>Number、String和Boolean如果不作为构造函数调用（即调用时不加new），常常用于将任意类型的值转为数值、字符串和布尔值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Number(123) // 123</span><br><span class=\"line\">String(&apos;abc&apos;) // &quot;abc&quot;</span><br><span class=\"line\">Boolean(true) // true</span><br></pre></td></tr></table></figure>\n<p>总结一下，这三个对象作为构造函数使用（带有new）时，可以将原始类型的值转为对象；作为普通函数使用时（不带有new），可以将任意类型的值，转为原始类型的值。</p>\n<h3 id=\"Boolean-函数的类型转换作用\"><a href=\"#Boolean-函数的类型转换作用\" class=\"headerlink\" title=\"Boolean 函数的类型转换作用\"></a>Boolean 函数的类型转换作用</h3><p>Boolean对象除了可以作为构造函数，还可以单独使用，将任意值转为布尔值。这时Boolean就是一个单纯的工具方法。<br>对于一些特殊值，Boolean对象前面加不加new，会得到完全相反的结果，必须小心</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (Boolean(false)) &#123;</span><br><span class=\"line\">  console.log(&apos;true&apos;);</span><br><span class=\"line\">&#125; // 无输出</span><br><span class=\"line\"></span><br><span class=\"line\">if (new Boolean(false)) &#123;</span><br><span class=\"line\">  console.log(&apos;true&apos;);</span><br><span class=\"line\">&#125; // true</span><br><span class=\"line\"></span><br><span class=\"line\">if (Boolean(null)) &#123;</span><br><span class=\"line\">  console.log(&apos;true&apos;);</span><br><span class=\"line\">&#125; // 无输出</span><br><span class=\"line\"></span><br><span class=\"line\">if (new Boolean(null)) &#123;</span><br><span class=\"line\">  console.log(&apos;true&apos;);</span><br><span class=\"line\">&#125; // true</span><br></pre></td></tr></table></figure>\n<h2 id=\"JSON对象\"><a href=\"#JSON对象\" class=\"headerlink\" title=\"JSON对象\"></a>JSON对象</h2><h3 id=\"Number-prototype-toFixed\"><a href=\"#Number-prototype-toFixed\" class=\"headerlink\" title=\"Number.prototype.toFixed()\"></a>Number.prototype.toFixed()</h3><p>toFixed方法先将一个数转为指定位数的小数，然后返回这个小数对应的字符串。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">(10).toFixed(2) // &quot;10.00&quot;</span><br><span class=\"line\">10.005.toFixed(2) // &quot;10.01&quot;</span><br></pre></td></tr></table></figure>\n<p>使用：转化时间</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">getTime(time)&#123;</span><br><span class=\"line\">    return (time/3600).toFixed(2) + &apos;小时&apos;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Math对象\"><a href=\"#Math对象\" class=\"headerlink\" title=\"Math对象\"></a>Math对象</h2><p>Math是 JavaScript 的原生对象，提供各种数学功能。该对象不是构造函数，不能生成实例，所有的属性和方法都必须在Math对象上调用。<br>Math对象提供以下一些静态方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Math.abs()：绝对值</span><br><span class=\"line\">Math.ceil()：向上取整</span><br><span class=\"line\">Math.floor()：向下取整</span><br><span class=\"line\">Math.max()：最大值</span><br><span class=\"line\">Math.min()：最小值</span><br><span class=\"line\">Math.pow()：指数运算</span><br><span class=\"line\">Math.sqrt()：平方根</span><br><span class=\"line\">Math.log()：自然对数</span><br><span class=\"line\">Math.exp()：e的指数</span><br><span class=\"line\">Math.round()：四舍五入</span><br><span class=\"line\">Math.random()：随机数</span><br></pre></td></tr></table></figure>\n<h3 id=\"Math-floor\"><a href=\"#Math-floor\" class=\"headerlink\" title=\"Math.floor()\"></a>Math.floor()</h3><p>方法返回小于参数值的最大整数（地板值）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Math.floor(3.2) // 3</span><br><span class=\"line\">Math.floor(-3.2) // -4</span><br></pre></td></tr></table></figure>\n<p>时间倒数取整</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">h = Math.floor(leftTime/1000/60/60%48),</span><br><span class=\"line\">m = Math.floor(leftTime/1000/60%60),</span><br><span class=\"line\">s = Math.floor(leftTime/1000%60);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Math-ceil\"><a href=\"#Math-ceil\" class=\"headerlink\" title=\"Math.ceil()\"></a>Math.ceil()</h3><p>方法返回大于参数值的最小整数（天花板值）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Math.ceil(3.2) // 4</span><br><span class=\"line\">Math.ceil(-3.2) // -3</span><br></pre></td></tr></table></figure>\n<h3 id=\"Math-round\"><a href=\"#Math-round\" class=\"headerlink\" title=\"Math.round()\"></a>Math.round()</h3><p>Math.round方法用于四舍五入。<br>注意，它对负数的处理（主要是对0.5的处理）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Math.round(-1.1) // -1</span><br><span class=\"line\">Math.round(-1.5) // -1</span><br><span class=\"line\">Math.round(-1.6) // -2</span><br></pre></td></tr></table></figure>\n<h3 id=\"Object-prototype-toLocaleString\"><a href=\"#Object-prototype-toLocaleString\" class=\"headerlink\" title=\"Object.prototype.toLocaleString()\"></a>Object.prototype.toLocaleString()</h3><p>这个方法的主要作用是留出一个接口，让各种不同的对象实现自己版本的toLocaleString，用来返回针对某些地域的特定的值。目前，主要有三个对象自定义了toLocaleString方法。<br>返回当地时间的写法模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">dateFormat:function(time)&#123;</span><br><span class=\"line\">            var unixTimestamp = new Date( time*1000 ) ;</span><br><span class=\"line\">            var commonTime;</span><br><span class=\"line\">            commonTime = unixTimestamp.toLocaleString(&quot;zh-CN&quot;);</span><br><span class=\"line\">            return commonTime;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var type = function (o)&#123;</span><br><span class=\"line\">  var s = Object.prototype.toString.call(o);</span><br><span class=\"line\">  return s.match(/\\[object (.*?)\\]/)[1].toLowerCase();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">type(&#123;&#125;); // &quot;object&quot;</span><br><span class=\"line\">type([]); // &quot;array&quot;</span><br><span class=\"line\">type(5); // &quot;number&quot;</span><br><span class=\"line\">type(null); // &quot;null&quot;</span><br><span class=\"line\">type(); // &quot;undefined&quot;</span><br><span class=\"line\">type(/abcd/); // &quot;regex&quot;</span><br><span class=\"line\">type(new Date()); // &quot;date&quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"location\"><a href=\"#location\" class=\"headerlink\" title=\"location\"></a>location</h4><p><code>let curPath = location.pathname;</code><br>如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">http://localhost:8081/courseIndex?channel=123&amp;lin=linziying</span><br><span class=\"line\">location.pathname</span><br><span class=\"line\">&quot;/courseIndex&quot;</span><br><span class=\"line\">location.search</span><br><span class=\"line\">&quot;?channel=1524653365&amp;lin=linziying&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">http://localhost:8081/home/index/index</span><br><span class=\"line\">location.pathname</span><br><span class=\"line\">&quot;/home/index/index&quot;</span><br><span class=\"line\">location.origin</span><br><span class=\"line\">&quot;http://localhost:8081&quot;</span><br><span class=\"line\">location.host</span><br><span class=\"line\">&quot;localhost:8081&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"replace\"><a href=\"#replace\" class=\"headerlink\" title=\"replace\"></a>replace</h3><p>是字符串写在前面，字符串的实例方法<br>String.prototype.replace()：按照给定的正则表达式进行替换，返回替换后的字符串<br>字符串对象的replace方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容。<br>下面再来说location.replace<br>location.replace 是替换当前页面，如果a页面 跳转到 b页面  b页面 写location.replace（c） 当点击返回按钮时，就会回到a页面，换句话说，location.replace 是清除了本页面的访问记录，直接回到上一个页面<br>如果是 b页面href到c页面的话，按c页面的回退按钮，会回到b页面</p>\n<h3 id=\"history-对象\"><a href=\"#history-对象\" class=\"headerlink\" title=\"history 对象\"></a>history 对象</h3><p>history.replaceState</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">if( window.history &amp;&amp; history.pushState )&#123;</span><br><span class=\"line\">\thistory.replaceState(&#123;state:1&#125;,&apos;&apos;,&apos;/usercateList&apos;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"DOM-模型概述\"><a href=\"#DOM-模型概述\" class=\"headerlink\" title=\"DOM 模型概述\"></a>DOM 模型概述</h2><h2 id=\"错误处理机制\"><a href=\"#错误处理机制\" class=\"headerlink\" title=\"错误处理机制\"></a>错误处理机制</h2><h3 id=\"try…catch-结构\"><a href=\"#try…catch-结构\" class=\"headerlink\" title=\"try…catch 结构\"></a>try…catch 结构</h3><p>一旦发生错误，程序就中止执行了。JavaScript 提供了try…catch结构，允许对错误进行处理，选择是否往下执行。</p>\n<p>如果你不确定某些代码是否会报错，就可以把它们放在try…catch代码块之中，便于进一步对错误进行处理。因为一旦报错js会阻塞，然后就卡在那里不执行。<br>例如json.parse方法，ocalStorage.setItem在iphone的混合模式下会报错，以及下面这个</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">dateFormat:function(time)&#123;</span><br><span class=\"line\">    var unixTimestamp = new Date( time*1000 ) ;</span><br><span class=\"line\">    var commonTime;</span><br><span class=\"line\">    try&#123;</span><br><span class=\"line\">        commonTime = unixTimestamp.toLocaleString(&quot;zh-CN&quot;);</span><br><span class=\"line\">    &#125;catch(err)&#123;</span><br><span class=\"line\">        console.log(err);</span><br><span class=\"line\">        commonTime = unixTimestamp.toLocaleString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return commonTime;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<h3 id=\"document-referrer\"><a href=\"#document-referrer\" class=\"headerlink\" title=\"document.referrer\"></a>document.referrer</h3><p>此返回上一页相关HTML代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;a href=&quot;javascript:history.go(-1)&quot; class=&quot;header-back jsBack&quot;&gt;返回&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<p>在大部分场景下，上面办法可以满足我们的交互需求，但是，在有些时候，上面的代码就有些心有力而气不足，因为当前页面的referrer并不总是存在的。</p>\n<p>比方说用户是通过微信分享进来的，直接进入了内页，此时是没有上一页的，返回按钮再怎么点击都没有任何反应，就会让用户很奇怪，十有八九会认为是实现了bug，则会让用户对产品的品质抱有疑虑，那问题可就大了。</p>\n<p>怎么办呢！后来我想了一招，那就是如果发现浏览器没有上一页来源信息，我们就把返回按钮的链接改成首页的链接地址，这样无论什么时候，用户点击返回按钮一定是会有反应的，并且返回首页从逻辑上讲也是合情合理的。而这里判断是否有没有来源信息就是使用这里的document.referrer，当浏览器得不到上一页的来源信息的时候，document.referrer的返回值就是空字符串’’，于是乎，就有类似下面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (document.referrer === &apos;&apos;) &#123;</span><br><span class=\"line\">    // 没有来源页面信息的时候，改成首页URL地址</span><br><span class=\"line\">    $(&apos;.jsBack&apos;).attr(&apos;href&apos;, &apos;/&apos;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ajax与HTML5-history-pushState-replaceState实例\"><a href=\"#ajax与HTML5-history-pushState-replaceState实例\" class=\"headerlink\" title=\"ajax与HTML5 history pushState/replaceState实例\"></a>ajax与HTML5 history pushState/replaceState实例</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">JS代码：</span><br><span class=\"line\">var eleMenus = $(&quot;#choMenu a&quot;).bind(&quot;click&quot;, function(event) &#123;</span><br><span class=\"line\">    var query = this.href.split(&quot;?&quot;)[1];</span><br><span class=\"line\">    if (history.pushState &amp;&amp; query &amp;&amp; !$(this).hasClass(clMenuOn)) &#123;</span><br><span class=\"line\">        /*</span><br><span class=\"line\">            ajax载入~~</span><br><span class=\"line\">        */</span><br><span class=\"line\">        </span><br><span class=\"line\">        // history处理</span><br><span class=\"line\">        var title = &quot;上海3月开盘项目汇总-&quot; + $(this).text().replace(/\\d+$/, &quot;&quot;);</span><br><span class=\"line\">        document.title = title;</span><br><span class=\"line\">        if (event &amp;&amp; /\\d/.test(event.button)) &#123;            </span><br><span class=\"line\">            history.pushState(&#123; title: title &#125;, title, location.href.split(&quot;?&quot;)[0] + &quot;?&quot; + query);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">var fnHashTrigger = function(target) &#123;</span><br><span class=\"line\">    var query = location.href.split(&quot;?&quot;)[1], eleTarget = target || null;</span><br><span class=\"line\">    if (typeof query == &quot;undefined&quot;) &#123;</span><br><span class=\"line\">        if (eleTarget = eleMenus.get(0)) &#123;</span><br><span class=\"line\">            // 如果没有查询字符，则使用第一个导航元素的查询字符内容</span><br><span class=\"line\">            history.replaceState(null, document.title, location.href.split(&quot;#&quot;)[0] + &quot;?&quot; + eleTarget.href.split(&quot;?&quot;)[1]) + location.hash;    </span><br><span class=\"line\">            fnHashTrigger(eleTarget);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        eleMenus.each(function() &#123;</span><br><span class=\"line\">            if (eleTarget === null &amp;&amp; this.href.split(&quot;?&quot;)[1] === query) &#123;</span><br><span class=\"line\">                eleTarget = this;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        if (!eleTarget) &#123;</span><br><span class=\"line\">            // 如果查询序列没有对应的导航菜单，去除查询然后执行回调</span><br><span class=\"line\">            history.replaceState(null, document.title, location.href.split(&quot;?&quot;)[0]);    </span><br><span class=\"line\">            fnHashTrigger();</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            $(eleTarget).trigger(&quot;click&quot;);</span><br><span class=\"line\">        &#125;        </span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">if (history.pushState) &#123;</span><br><span class=\"line\">    window.addEventListener(&quot;popstate&quot;, function() &#123;</span><br><span class=\"line\">        fnHashTrigger();                             </span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 默认载入</span><br><span class=\"line\">    fnHashTrigger();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">history.pushState(&#123;page: 4&#125;, &quot;title 1&quot;, &quot;&quot;);</span><br><span class=\"line\">\t\t\t\tif ( window.history &amp;&amp; window.history.pushState ) &#123;</span><br><span class=\"line\">\t\t\t\t\twindow.addEventListener(&quot;popstate&quot;, function () &#123;</span><br><span class=\"line\">\t\t\t\t\t\thistory.replaceState(&#123;page: 4&#125;, &quot;title 1&quot;, location.href);</span><br><span class=\"line\">\t\t\t\t\t\tlocation.href = &quot;/&quot;;</span><br><span class=\"line\">\t\t\t\t\t&#125;);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br></pre></td></tr></table></figure>\n<p>pushState会促发popstate事件监听，pushState会在历史里面添加记录，返回时是进入到这个地址，而replaceState虽然能改变浏览器url地址但是并不会添加进历史，回退不会进入相应的地址。</p>\n<h3 id=\"类的使用\"><a href=\"#类的使用\" class=\"headerlink\" title=\"类的使用\"></a>类的使用</h3>","site":{"data":{}},"excerpt":"<p>js基础备忘</p>","more":"<h3 id=\"valueOf-NaN\"><a href=\"#valueOf-NaN\" class=\"headerlink\" title=\"valueOf()\"></a>valueOf()</h3><p>valueOf方法是一个所有对象都拥有的方法，表示对该对象求值。不同对象的valueOf方法不尽一致，数组的valueOf方法返回数组本身。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3];</span><br><span class=\"line\">arr.valueOf() // [1, 2, 3]</span><br></pre></td></tr></table></figure>\n<p>日期对象<br>valueOf方法返回实例对象距离时间零点（1970年1月1日00:00:00 UTC）对应的毫秒数，该方法等同于getTime方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">new Date()</span><br><span class=\"line\">Thu Jun 21 2018 16:43:00 GMT+0800 (中国标准时间)</span><br><span class=\"line\">new Date().valueOf()</span><br><span class=\"line\">1529570590072</span><br></pre></td></tr></table></figure>\n<h3 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString()\"></a>toString()</h3><p>toString方法也是对象的通用方法，数组的toString方法返回数组的字符串形式。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3];</span><br><span class=\"line\">arr.toString() // &quot;1,2,3&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">var arr = [1, 2, 3, [4, 5, 6]];</span><br><span class=\"line\">arr.toString() // &quot;1,2,3,4,5,6&quot;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">new Date()</span><br><span class=\"line\">Thu Jun 21 2018 16:43:00 GMT+0800 (中国标准时间)</span><br><span class=\"line\">new Date().valueOf()</span><br><span class=\"line\">1529570590072</span><br><span class=\"line\">var a = 1;</span><br><span class=\"line\">undefined</span><br><span class=\"line\">a.toString();</span><br><span class=\"line\">&quot;1&quot;</span><br><span class=\"line\">new Date().toString()</span><br><span class=\"line\">&quot;Thu Jun 21 2018 17:15:52 GMT+0800 (中国标准时间)&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"slice\"><a href=\"#slice\" class=\"headerlink\" title=\"slice()\"></a>slice()</h3><p>slice方法用于提取目标数组的一部分，返回一个新数组，原数组不变。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class=\"line\">a.slice(0) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class=\"line\">a.slice(1) // [&quot;b&quot;, &quot;c&quot;]</span><br></pre></td></tr></table></figure>\n<p><code>String.prototype.slice()</code><br>slice方法用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&apos;JavaScript&apos;.slice(0, 4) // &quot;Java&quot;</span><br></pre></td></tr></table></figure>\n<p>控制文字长度</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;&#123;item.user_name.slice(0,4)&#125;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"indexOf\"><a href=\"#indexOf\" class=\"headerlink\" title=\"indexOf()\"></a>indexOf()</h3><p>indexOf方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class=\"line\">a.indexOf(&apos;b&apos;) // 1</span><br><span class=\"line\">a.indexOf(&apos;y&apos;) // -1</span><br></pre></td></tr></table></figure>\n<p><code>String.prototype.indexOf()</code></p>\n<p>indexOf方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回-1，就表示不匹配。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&apos;hello world&apos;.indexOf(&apos;o&apos;) // 4</span><br><span class=\"line\">&apos;JavaScript&apos;.indexOf(&apos;script&apos;) // -1</span><br></pre></td></tr></table></figure>\n<p>截取url</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var index = location.href.indexOf(&quot;order_id&quot;);</span><br><span class=\"line\">var re_url = location.href.slice(0,index);</span><br></pre></td></tr></table></figure>\n<p>根据不同环境设置token</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let host = location.host,token = &apos;&apos;;</span><br><span class=\"line\">if( host.indexOf(&apos;localhost&apos;) !== -1 || host.indexOf(&apos;127.0.0.1&apos;) !== -1 )&#123;</span><br><span class=\"line\">    token = &apos;&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"splice\"><a href=\"#splice\" class=\"headerlink\" title=\"splice()\"></a>splice()</h3><p>splice方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组。<br>splice的第一个参数是删除的起始位置（从0开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;];</span><br><span class=\"line\">a.splice(4, 2) // [&quot;e&quot;, &quot;f&quot;]</span><br><span class=\"line\">a // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span><br></pre></td></tr></table></figure>\n<h3 id=\"push-、pop-，shift-、unshift-，concat\"><a href=\"#push-、pop-，shift-、unshift-，concat\" class=\"headerlink\" title=\"push()、pop()，shift()、unshift()，concat()\"></a>push()、pop()，shift()、unshift()，concat()</h3><h3 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join()\"></a>join()</h3><p>join方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var a = [1, 2, 3, 4];</span><br><span class=\"line\">a.join(&apos; &apos;) // &apos;1 2 3 4&apos;</span><br><span class=\"line\">a.join(&apos; | &apos;) // &quot;1 | 2 | 3 | 4&quot;</span><br><span class=\"line\">a.join() // &quot;1,2,3,4&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map()\"></a>map()</h3><p>map方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var numbers = [1, 2, 3];</span><br><span class=\"line\"></span><br><span class=\"line\">numbers.map(function (n) &#123;</span><br><span class=\"line\">  return n + 1;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// [2, 3, 4]</span><br><span class=\"line\"></span><br><span class=\"line\">numbers</span><br><span class=\"line\">// [1, 2, 3]</span><br></pre></td></tr></table></figure>\n<p>map方法接受一个函数作为参数。该函数调用时，map方法向它传入三个参数：当前成员、当前位置和数组本身。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[1, 2, 3].map(function(elem, index, arr) &#123;</span><br><span class=\"line\">  return elem * index;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// [0, 2, 6]</span><br></pre></td></tr></table></figure>\n<p>map方法还可以接受第二个参数，用来绑定回调函数内部的this变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class=\"line\">[1, 2].map(function (e) &#123;</span><br><span class=\"line\">  return this[e];</span><br><span class=\"line\">&#125;, arr)</span><br><span class=\"line\">// [&apos;b&apos;, &apos;c&apos;]</span><br></pre></td></tr></table></figure>\n<p>上面代码通过map方法的第二个参数，将回调函数内部的this对象，指向arr数组。</p>\n<h3 id=\"Object-keys-amp-forEach\"><a href=\"#Object-keys-amp-forEach\" class=\"headerlink\" title=\"Object.keys() &amp; forEach()\"></a>Object.keys() &amp; forEach()</h3><p>Object.keys()用于获得由对象属性名组成的数组，可与数组遍历相结合使用，用起来效果杠杠滴。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">//创建对象</span><br><span class=\"line\">var person = &#123;</span><br><span class=\"line\">    ChineseName: &quot;wjh&quot;,</span><br><span class=\"line\">    EnglishName: &quot;Bruce&quot;,</span><br><span class=\"line\">    age: 10,</span><br><span class=\"line\">    school:&quot;HQ University&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//用forEach()进行遍历</span><br><span class=\"line\">var keys = Object.keys(person).forEach(function (tz) &#123;</span><br><span class=\"line\">    console.log(&quot;person &quot;, tz, &quot;: &quot;, person[tz]);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>把url参数的类对象模式转化为对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">let keys = Object.keys( to.query );</span><br><span class=\"line\">if ( keys.length )&#123;</span><br><span class=\"line\">\t\tquery = &apos;?&apos;;</span><br><span class=\"line\">\t\tkeys.forEach( key =&gt; &#123;</span><br><span class=\"line\">\t\tif( keys.length == 1 )&#123;</span><br><span class=\"line\">\t\t\t\tquery += `$&#123;key&#125;=$&#123;to.query[key]&#125;`</span><br><span class=\"line\">\t\t&#125;else&#123;</span><br><span class=\"line\">\t\t\t   query += `$&#123;key&#125;=$&#123;to.query[key]&#125;&amp;`</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter()\"></a>filter()</h3><p>filter方法用于过滤数组成员，满足条件的成员组成一个新数组返回。</p>\n<p>它的参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">[1, 2, 3, 4, 5].filter(function (elem) &#123;</span><br><span class=\"line\">  return (elem &gt; 3);</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// [4, 5]</span><br></pre></td></tr></table></figure>\n<h3 id=\"some-，every\"><a href=\"#some-，every\" class=\"headerlink\" title=\"some()，every()\"></a>some()，every()</h3><p>这两个方法类似“断言”（assert），返回一个布尔值，表示判断数组成员是否符合某种条件。</p>\n<p>它们接受一个函数作为参数，所有数组成员依次执行该函数。该函数接受三个参数：当前成员、当前位置和整个数组，然后返回一个布尔值。</p>\n<p>some方法是只要一个成员的返回值是true，则整个some方法的返回值就是true，否则返回false。<br>every方法是所有成员的返回值都是true，整个every方法才返回true，否则返回false。<br>是否是苹果机型的判断</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">isIphone:function()&#123;</span><br><span class=\"line\">\t\t\tlet ua = navigator.userAgent,</span><br><span class=\"line\">\t\t\t\tAgents = [&quot;iPhone&quot;, &quot;iPad&quot;, &quot;iPod&quot;];</span><br><span class=\"line\">\t\t\treturn Agents.some(function(v)&#123;</span><br><span class=\"line\">\t\t\t\treturn new RegExp(v,&apos;i&apos;).test(ua);</span><br><span class=\"line\">\t\t\t&#125;)</span><br><span class=\"line\">\t\t&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce()\"></a>reduce()</h3><p>reduce方法和reduceRight方法的第一个参数都是一个函数。该函数接受以下四个参数。<br>我们在reduce的第二个参数里面初始了回调函数第一个参数的类型和值<br>获取url任意参数值的方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">getParams:function()&#123;</span><br><span class=\"line\">            var search = location.href.split(&quot;?&quot;)[1];</span><br><span class=\"line\">            if(!search)&#123;</span><br><span class=\"line\">                return &#123;&#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            var params = search.split(&quot;&amp;&quot;);</span><br><span class=\"line\">            return params.reduce(function(res,items)&#123;</span><br><span class=\"line\">                var parts = items.split(&quot;=&quot;);</span><br><span class=\"line\">                res[parts[0]] = parts[1] + &quot;&quot;;</span><br><span class=\"line\">                return res;</span><br><span class=\"line\">            &#125;,&#123;&#125;);</span><br><span class=\"line\">        &#125;,</span><br></pre></td></tr></table></figure>\n<p>{}初始化res为空对象</p>\n<h2 id=\"Date对象\"><a href=\"#Date对象\" class=\"headerlink\" title=\"Date对象\"></a>Date对象</h2><h3 id=\"Date\"><a href=\"#Date\" class=\"headerlink\" title=\"Date()\"></a>Date()</h3><p>Date对象可以作为普通函数直接调用，返回一个代表当前时间的字符串。<br><code>·Tue Jun 26 2018 10:19:28 GMT+0800 (中国标准时间)·</code><br>这个对象里面可以加各种参数，返回的都是如上字符串显示<br>Date还可以当作构造函数使用。对它使用new命令，会返回一个Date对象的实例。如果不加参数，实例代表的就是当前时间。<br><code>new Date();</code><br>使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">dateFormat:function(time)&#123;</span><br><span class=\"line\">                time = time * 1000 ;</span><br><span class=\"line\">                time = new Date(time);</span><br><span class=\"line\">                var year = time.getFullYear(),</span><br><span class=\"line\">                    month = time.getMonth() + 1,</span><br><span class=\"line\">                    date = time.getDate(),</span><br><span class=\"line\">                    hour = time.getHours(),</span><br><span class=\"line\">                    minute = time.getMinutes(),</span><br><span class=\"line\">                    second = time.getSeconds(),</span><br><span class=\"line\">                    m = month &gt;= 10 ? month : &quot;0&quot; + month,</span><br><span class=\"line\">                    d = date &gt;= 10 ? date : &quot;0&quot; + date,</span><br><span class=\"line\">                    h = hour &gt;= 10 ? hour : &quot;0&quot; + hour,</span><br><span class=\"line\">                    mt = minute &gt;= 10 ? minute : &quot;0&quot; + minute,</span><br><span class=\"line\">                    s = second &gt;= 10 ? second : &quot;0&quot; + second;</span><br><span class=\"line\">                return year + &quot;-&quot; + m + &quot;-&quot; + date + &quot; &quot; + h + &quot;:&quot; + mt + &quot;:&quot; + s;</span><br><span class=\"line\">            &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Date-now\"><a href=\"#Date-now\" class=\"headerlink\" title=\"Date.now()\"></a>Date.now()</h3><p>Date.now方法返回当前时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数，相当于 Unix 时间戳乘以1000。</p>\n<h3 id=\"Date-parse\"><a href=\"#Date-parse\" class=\"headerlink\" title=\"Date.parse()\"></a>Date.parse()</h3><p>Date.parse方法用来解析日期字符串，返回该时间距离时间零点（1970年1月1日 00:00:00）的毫秒数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Date.parse(&apos;2018/06/26 23:13:40&apos;)</span><br><span class=\"line\">1530026020000</span><br></pre></td></tr></table></figure>\n<h3 id=\"Date-UTC\"><a href=\"#Date-UTC\" class=\"headerlink\" title=\"Date.UTC()\"></a>Date.UTC()</h3><p>Date.UTC方法接受年、月、日等变量作为参数，返回该时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">// 用法</span><br><span class=\"line\">Date.UTC(2011, 0, 1, 2, 3, 4, 567)</span><br><span class=\"line\">// 1293847384567</span><br></pre></td></tr></table></figure>\n<p>该方法的参数用法与Date构造函数完全一致，比如月从0开始计算，日期从1开始计算。区别在于Date.UTC方法的参数，会被解释为 UTC 时间（世界标准时间），Date构造函数的参数会被解释为当前时区的时间。</p>\n<p><a href=\"http://javascript.ruanyifeng.com/stdlib/date.html\" target=\"_blank\" rel=\"noopener\">http://javascript.ruanyifeng.com/stdlib/date.html</a></p>\n<h2 id=\"RegExp对象\"><a href=\"#RegExp对象\" class=\"headerlink\" title=\"RegExp对象\"></a>RegExp对象</h2><p>如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的length属性等于组匹配的数量再加1。<br>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var type = function (o)&#123;</span><br><span class=\"line\">  var s = Object.prototype.toString.call(o);</span><br><span class=\"line\">  return s.match(/\\[object (.*?)\\]/)[1].toLowerCase();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">type(&#123;&#125;); // &quot;object&quot;</span><br><span class=\"line\">type([]); // &quot;array&quot;</span><br></pre></td></tr></table></figure>\n<p>\\s 匹配空格 （包括换行符、制表符、空格符等），相等于[ \\t\\r\\n\\v\\f]<br>（1）点字符（.)<br>点字符（.）匹配除回车（\\r）、换行(\\n) 、行分隔符（\\u2028）和段分隔符（\\u2029）以外的所有字符。<br>（2）位置字符<br>位置字符用来提示字符所处的位置，主要有两个字符。<br>^ 表示字符串的开始位置<br>$ 表示字符串的结束位置<br>（3）选择符（|）<br>竖线符号（|）在正则表达式中表示“或关系”（OR），即cat|dog表示匹配cat或dog。<br>正则表达式中，需要反斜杠转义的，一共有12个字符：^、.、[、$、(、)、|、*、+、?、{和\\。</p>\n<p>字符类<br>字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[xyz] 表示x、y、z之中任选一个匹配。<br>量词符<br>量词符用来设定某个模式出现的次数。</p>\n<p>? 问号表示某个模式出现0次或1次，等同于{0, 1}。</p>\n<ul>\n<li>星号表示某个模式出现0次或多次，等同于{0,}。</li>\n</ul>\n<ul>\n<li>加号表示某个模式出现1次或多次，等同于{1,}。</li>\n</ul>\n<p>预定义模式指的是某些常见模式的简写方式。<br>\\d 匹配0-9之间的任一数字，相当于[0-9]。<br>\\D 匹配所有0-9以外的字符，相当于[^0-9]。<br>\\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。<br>\\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。<br>\\s 匹配空格（包括换行符、制表符、空格符等），相等于[ \\t\\r\\n\\v\\f]。<br>\\S 匹配非空格的字符，相当于[^ \\t\\r\\n\\v\\f]。<br>\\b 匹配词的边界。<br>\\B 匹配非词边界，即在词的内部。<br>重复类<br>模式的精确匹配次数，使用大括号（{}）表示。{n}表示恰好重复n次，{n,}表示至少重复n次，{n,m}表示重复不少于n次，不多于m次。<br>量词符<br>量词符用来设定某个模式出现的次数。</p>\n<p>? 问号表示某个模式出现0次或1次，等同于{0, 1}。</p>\n<ul>\n<li>星号表示某个模式出现0次或多次，等同于{0,}。</li>\n</ul>\n<ul>\n<li>加号表示某个模式出现1次或多次，等同于{1,}。</li>\n</ul>\n<p>上一小节的三个量词符，默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。<br>var s = ‘aaa’;<br>s.match(/a+/) // [“aaa”]<br>上面代码中，模式是/a+/，表示匹配1个a或多个a，那么到底会匹配几个a呢？因为默认是贪婪模式，会一直匹配到字符a不出现为止，所以匹配结果是3个a。</p>\n<p>如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。</p>\n<p>var s = ‘aaa’;<br>s.match(/a+?/) // [“a”]<br>*?：表示某个模式出现0次或多次，匹配时采用非贪婪模式。<br>+?：表示某个模式出现1次或多次，匹配时采用非贪婪模式。</p>\n<h2 id=\"包装对象\"><a href=\"#包装对象\" class=\"headerlink\" title=\"包装对象\"></a>包装对象</h2><p>使用双重的否运算符（!）也可以将任意值转为对应的布尔值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">!!undefined // false</span><br><span class=\"line\">!!null // false</span><br><span class=\"line\">!!0 // false</span><br><span class=\"line\">!!&apos;&apos; // false</span><br><span class=\"line\">!!NaN // false</span><br><span class=\"line\">!!1 // true</span><br><span class=\"line\">!!&apos;false&apos; // true</span><br><span class=\"line\">!![] // true</span><br><span class=\"line\">!!&#123;&#125; // true</span><br><span class=\"line\">!!function()&#123;&#125; // true</span><br><span class=\"line\">!!/foo/ // true</span><br></pre></td></tr></table></figure>\n<p>Number、String和Boolean如果不作为构造函数调用（即调用时不加new），常常用于将任意类型的值转为数值、字符串和布尔值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Number(123) // 123</span><br><span class=\"line\">String(&apos;abc&apos;) // &quot;abc&quot;</span><br><span class=\"line\">Boolean(true) // true</span><br></pre></td></tr></table></figure>\n<p>总结一下，这三个对象作为构造函数使用（带有new）时，可以将原始类型的值转为对象；作为普通函数使用时（不带有new），可以将任意类型的值，转为原始类型的值。</p>\n<h3 id=\"Boolean-函数的类型转换作用\"><a href=\"#Boolean-函数的类型转换作用\" class=\"headerlink\" title=\"Boolean 函数的类型转换作用\"></a>Boolean 函数的类型转换作用</h3><p>Boolean对象除了可以作为构造函数，还可以单独使用，将任意值转为布尔值。这时Boolean就是一个单纯的工具方法。<br>对于一些特殊值，Boolean对象前面加不加new，会得到完全相反的结果，必须小心</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (Boolean(false)) &#123;</span><br><span class=\"line\">  console.log(&apos;true&apos;);</span><br><span class=\"line\">&#125; // 无输出</span><br><span class=\"line\"></span><br><span class=\"line\">if (new Boolean(false)) &#123;</span><br><span class=\"line\">  console.log(&apos;true&apos;);</span><br><span class=\"line\">&#125; // true</span><br><span class=\"line\"></span><br><span class=\"line\">if (Boolean(null)) &#123;</span><br><span class=\"line\">  console.log(&apos;true&apos;);</span><br><span class=\"line\">&#125; // 无输出</span><br><span class=\"line\"></span><br><span class=\"line\">if (new Boolean(null)) &#123;</span><br><span class=\"line\">  console.log(&apos;true&apos;);</span><br><span class=\"line\">&#125; // true</span><br></pre></td></tr></table></figure>\n<h2 id=\"JSON对象\"><a href=\"#JSON对象\" class=\"headerlink\" title=\"JSON对象\"></a>JSON对象</h2><h3 id=\"Number-prototype-toFixed\"><a href=\"#Number-prototype-toFixed\" class=\"headerlink\" title=\"Number.prototype.toFixed()\"></a>Number.prototype.toFixed()</h3><p>toFixed方法先将一个数转为指定位数的小数，然后返回这个小数对应的字符串。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">(10).toFixed(2) // &quot;10.00&quot;</span><br><span class=\"line\">10.005.toFixed(2) // &quot;10.01&quot;</span><br></pre></td></tr></table></figure>\n<p>使用：转化时间</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">getTime(time)&#123;</span><br><span class=\"line\">    return (time/3600).toFixed(2) + &apos;小时&apos;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"Math对象\"><a href=\"#Math对象\" class=\"headerlink\" title=\"Math对象\"></a>Math对象</h2><p>Math是 JavaScript 的原生对象，提供各种数学功能。该对象不是构造函数，不能生成实例，所有的属性和方法都必须在Math对象上调用。<br>Math对象提供以下一些静态方法。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Math.abs()：绝对值</span><br><span class=\"line\">Math.ceil()：向上取整</span><br><span class=\"line\">Math.floor()：向下取整</span><br><span class=\"line\">Math.max()：最大值</span><br><span class=\"line\">Math.min()：最小值</span><br><span class=\"line\">Math.pow()：指数运算</span><br><span class=\"line\">Math.sqrt()：平方根</span><br><span class=\"line\">Math.log()：自然对数</span><br><span class=\"line\">Math.exp()：e的指数</span><br><span class=\"line\">Math.round()：四舍五入</span><br><span class=\"line\">Math.random()：随机数</span><br></pre></td></tr></table></figure>\n<h3 id=\"Math-floor\"><a href=\"#Math-floor\" class=\"headerlink\" title=\"Math.floor()\"></a>Math.floor()</h3><p>方法返回小于参数值的最大整数（地板值）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Math.floor(3.2) // 3</span><br><span class=\"line\">Math.floor(-3.2) // -4</span><br></pre></td></tr></table></figure>\n<p>时间倒数取整</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">h = Math.floor(leftTime/1000/60/60%48),</span><br><span class=\"line\">m = Math.floor(leftTime/1000/60%60),</span><br><span class=\"line\">s = Math.floor(leftTime/1000%60);</span><br></pre></td></tr></table></figure>\n<h3 id=\"Math-ceil\"><a href=\"#Math-ceil\" class=\"headerlink\" title=\"Math.ceil()\"></a>Math.ceil()</h3><p>方法返回大于参数值的最小整数（天花板值）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Math.ceil(3.2) // 4</span><br><span class=\"line\">Math.ceil(-3.2) // -3</span><br></pre></td></tr></table></figure>\n<h3 id=\"Math-round\"><a href=\"#Math-round\" class=\"headerlink\" title=\"Math.round()\"></a>Math.round()</h3><p>Math.round方法用于四舍五入。<br>注意，它对负数的处理（主要是对0.5的处理）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Math.round(-1.1) // -1</span><br><span class=\"line\">Math.round(-1.5) // -1</span><br><span class=\"line\">Math.round(-1.6) // -2</span><br></pre></td></tr></table></figure>\n<h3 id=\"Object-prototype-toLocaleString\"><a href=\"#Object-prototype-toLocaleString\" class=\"headerlink\" title=\"Object.prototype.toLocaleString()\"></a>Object.prototype.toLocaleString()</h3><p>这个方法的主要作用是留出一个接口，让各种不同的对象实现自己版本的toLocaleString，用来返回针对某些地域的特定的值。目前，主要有三个对象自定义了toLocaleString方法。<br>返回当地时间的写法模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">dateFormat:function(time)&#123;</span><br><span class=\"line\">            var unixTimestamp = new Date( time*1000 ) ;</span><br><span class=\"line\">            var commonTime;</span><br><span class=\"line\">            commonTime = unixTimestamp.toLocaleString(&quot;zh-CN&quot;);</span><br><span class=\"line\">            return commonTime;</span><br><span class=\"line\">        &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var type = function (o)&#123;</span><br><span class=\"line\">  var s = Object.prototype.toString.call(o);</span><br><span class=\"line\">  return s.match(/\\[object (.*?)\\]/)[1].toLowerCase();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">type(&#123;&#125;); // &quot;object&quot;</span><br><span class=\"line\">type([]); // &quot;array&quot;</span><br><span class=\"line\">type(5); // &quot;number&quot;</span><br><span class=\"line\">type(null); // &quot;null&quot;</span><br><span class=\"line\">type(); // &quot;undefined&quot;</span><br><span class=\"line\">type(/abcd/); // &quot;regex&quot;</span><br><span class=\"line\">type(new Date()); // &quot;date&quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"location\"><a href=\"#location\" class=\"headerlink\" title=\"location\"></a>location</h4><p><code>let curPath = location.pathname;</code><br>如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">http://localhost:8081/courseIndex?channel=123&amp;lin=linziying</span><br><span class=\"line\">location.pathname</span><br><span class=\"line\">&quot;/courseIndex&quot;</span><br><span class=\"line\">location.search</span><br><span class=\"line\">&quot;?channel=1524653365&amp;lin=linziying&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">http://localhost:8081/home/index/index</span><br><span class=\"line\">location.pathname</span><br><span class=\"line\">&quot;/home/index/index&quot;</span><br><span class=\"line\">location.origin</span><br><span class=\"line\">&quot;http://localhost:8081&quot;</span><br><span class=\"line\">location.host</span><br><span class=\"line\">&quot;localhost:8081&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"replace\"><a href=\"#replace\" class=\"headerlink\" title=\"replace\"></a>replace</h3><p>是字符串写在前面，字符串的实例方法<br>String.prototype.replace()：按照给定的正则表达式进行替换，返回替换后的字符串<br>字符串对象的replace方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容。<br>下面再来说location.replace<br>location.replace 是替换当前页面，如果a页面 跳转到 b页面  b页面 写location.replace（c） 当点击返回按钮时，就会回到a页面，换句话说，location.replace 是清除了本页面的访问记录，直接回到上一个页面<br>如果是 b页面href到c页面的话，按c页面的回退按钮，会回到b页面</p>\n<h3 id=\"history-对象\"><a href=\"#history-对象\" class=\"headerlink\" title=\"history 对象\"></a>history 对象</h3><p>history.replaceState</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">if( window.history &amp;&amp; history.pushState )&#123;</span><br><span class=\"line\">\thistory.replaceState(&#123;state:1&#125;,&apos;&apos;,&apos;/usercateList&apos;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"DOM-模型概述\"><a href=\"#DOM-模型概述\" class=\"headerlink\" title=\"DOM 模型概述\"></a>DOM 模型概述</h2><h2 id=\"错误处理机制\"><a href=\"#错误处理机制\" class=\"headerlink\" title=\"错误处理机制\"></a>错误处理机制</h2><h3 id=\"try…catch-结构\"><a href=\"#try…catch-结构\" class=\"headerlink\" title=\"try…catch 结构\"></a>try…catch 结构</h3><p>一旦发生错误，程序就中止执行了。JavaScript 提供了try…catch结构，允许对错误进行处理，选择是否往下执行。</p>\n<p>如果你不确定某些代码是否会报错，就可以把它们放在try…catch代码块之中，便于进一步对错误进行处理。因为一旦报错js会阻塞，然后就卡在那里不执行。<br>例如json.parse方法，ocalStorage.setItem在iphone的混合模式下会报错，以及下面这个</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">dateFormat:function(time)&#123;</span><br><span class=\"line\">    var unixTimestamp = new Date( time*1000 ) ;</span><br><span class=\"line\">    var commonTime;</span><br><span class=\"line\">    try&#123;</span><br><span class=\"line\">        commonTime = unixTimestamp.toLocaleString(&quot;zh-CN&quot;);</span><br><span class=\"line\">    &#125;catch(err)&#123;</span><br><span class=\"line\">        console.log(err);</span><br><span class=\"line\">        commonTime = unixTimestamp.toLocaleString();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return commonTime;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<h3 id=\"document-referrer\"><a href=\"#document-referrer\" class=\"headerlink\" title=\"document.referrer\"></a>document.referrer</h3><p>此返回上一页相关HTML代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;a href=&quot;javascript:history.go(-1)&quot; class=&quot;header-back jsBack&quot;&gt;返回&lt;/a&gt;</span><br></pre></td></tr></table></figure>\n<p>在大部分场景下，上面办法可以满足我们的交互需求，但是，在有些时候，上面的代码就有些心有力而气不足，因为当前页面的referrer并不总是存在的。</p>\n<p>比方说用户是通过微信分享进来的，直接进入了内页，此时是没有上一页的，返回按钮再怎么点击都没有任何反应，就会让用户很奇怪，十有八九会认为是实现了bug，则会让用户对产品的品质抱有疑虑，那问题可就大了。</p>\n<p>怎么办呢！后来我想了一招，那就是如果发现浏览器没有上一页来源信息，我们就把返回按钮的链接改成首页的链接地址，这样无论什么时候，用户点击返回按钮一定是会有反应的，并且返回首页从逻辑上讲也是合情合理的。而这里判断是否有没有来源信息就是使用这里的document.referrer，当浏览器得不到上一页的来源信息的时候，document.referrer的返回值就是空字符串’’，于是乎，就有类似下面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">if (document.referrer === &apos;&apos;) &#123;</span><br><span class=\"line\">    // 没有来源页面信息的时候，改成首页URL地址</span><br><span class=\"line\">    $(&apos;.jsBack&apos;).attr(&apos;href&apos;, &apos;/&apos;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"ajax与HTML5-history-pushState-replaceState实例\"><a href=\"#ajax与HTML5-history-pushState-replaceState实例\" class=\"headerlink\" title=\"ajax与HTML5 history pushState/replaceState实例\"></a>ajax与HTML5 history pushState/replaceState实例</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">JS代码：</span><br><span class=\"line\">var eleMenus = $(&quot;#choMenu a&quot;).bind(&quot;click&quot;, function(event) &#123;</span><br><span class=\"line\">    var query = this.href.split(&quot;?&quot;)[1];</span><br><span class=\"line\">    if (history.pushState &amp;&amp; query &amp;&amp; !$(this).hasClass(clMenuOn)) &#123;</span><br><span class=\"line\">        /*</span><br><span class=\"line\">            ajax载入~~</span><br><span class=\"line\">        */</span><br><span class=\"line\">        </span><br><span class=\"line\">        // history处理</span><br><span class=\"line\">        var title = &quot;上海3月开盘项目汇总-&quot; + $(this).text().replace(/\\d+$/, &quot;&quot;);</span><br><span class=\"line\">        document.title = title;</span><br><span class=\"line\">        if (event &amp;&amp; /\\d/.test(event.button)) &#123;            </span><br><span class=\"line\">            history.pushState(&#123; title: title &#125;, title, location.href.split(&quot;?&quot;)[0] + &quot;?&quot; + query);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return false;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">var fnHashTrigger = function(target) &#123;</span><br><span class=\"line\">    var query = location.href.split(&quot;?&quot;)[1], eleTarget = target || null;</span><br><span class=\"line\">    if (typeof query == &quot;undefined&quot;) &#123;</span><br><span class=\"line\">        if (eleTarget = eleMenus.get(0)) &#123;</span><br><span class=\"line\">            // 如果没有查询字符，则使用第一个导航元素的查询字符内容</span><br><span class=\"line\">            history.replaceState(null, document.title, location.href.split(&quot;#&quot;)[0] + &quot;?&quot; + eleTarget.href.split(&quot;?&quot;)[1]) + location.hash;    </span><br><span class=\"line\">            fnHashTrigger(eleTarget);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        eleMenus.each(function() &#123;</span><br><span class=\"line\">            if (eleTarget === null &amp;&amp; this.href.split(&quot;?&quot;)[1] === query) &#123;</span><br><span class=\"line\">                eleTarget = this;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        </span><br><span class=\"line\">        if (!eleTarget) &#123;</span><br><span class=\"line\">            // 如果查询序列没有对应的导航菜单，去除查询然后执行回调</span><br><span class=\"line\">            history.replaceState(null, document.title, location.href.split(&quot;?&quot;)[0]);    </span><br><span class=\"line\">            fnHashTrigger();</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            $(eleTarget).trigger(&quot;click&quot;);</span><br><span class=\"line\">        &#125;        </span><br><span class=\"line\">    &#125;    </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">if (history.pushState) &#123;</span><br><span class=\"line\">    window.addEventListener(&quot;popstate&quot;, function() &#123;</span><br><span class=\"line\">        fnHashTrigger();                             </span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 默认载入</span><br><span class=\"line\">    fnHashTrigger();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">history.pushState(&#123;page: 4&#125;, &quot;title 1&quot;, &quot;&quot;);</span><br><span class=\"line\">\t\t\t\tif ( window.history &amp;&amp; window.history.pushState ) &#123;</span><br><span class=\"line\">\t\t\t\t\twindow.addEventListener(&quot;popstate&quot;, function () &#123;</span><br><span class=\"line\">\t\t\t\t\t\thistory.replaceState(&#123;page: 4&#125;, &quot;title 1&quot;, location.href);</span><br><span class=\"line\">\t\t\t\t\t\tlocation.href = &quot;/&quot;;</span><br><span class=\"line\">\t\t\t\t\t&#125;);</span><br><span class=\"line\">\t\t\t\t&#125;</span><br></pre></td></tr></table></figure>\n<p>pushState会促发popstate事件监听，pushState会在历史里面添加记录，返回时是进入到这个地址，而replaceState虽然能改变浏览器url地址但是并不会添加进历史，回退不会进入相应的地址。</p>\n<h3 id=\"类的使用\"><a href=\"#类的使用\" class=\"headerlink\" title=\"类的使用\"></a>类的使用</h3>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjldh03qc0000uv6xx2orh2ky","tag_id":"cjldh03qw0003uv6x44y11ckw","_id":"cjldh03rc0008uv6xycspm9ej"},{"post_id":"cjldh03qr0002uv6xelpdsbu8","tag_id":"cjldh03rb0007uv6xailf5p7l","_id":"cjldh03rj000duv6xtvyicmkx"},{"post_id":"cjldh03qz0004uv6xqenai4ik","tag_id":"cjldh03rh000buv6x0egqxlmr","_id":"cjldh03ro000huv6x5dj0ddj3"},{"post_id":"cjldh03rj000euv6xsbliagbt","tag_id":"cjldh03rh000buv6x0egqxlmr","_id":"cjldh03rp000juv6xw2fwdoa4"},{"post_id":"cjldh03r70005uv6xw3qa2h17","tag_id":"cjldh03rh000buv6x0egqxlmr","_id":"cjldh03rr000luv6xfxtbbhyu"},{"post_id":"cjldh03ro000iuv6x9fr2bfj8","tag_id":"cjldh03rh000buv6x0egqxlmr","_id":"cjldh03rr000muv6xp86u1i6i"},{"post_id":"cjldh03ra0006uv6xw4zbq7oq","tag_id":"cjldh03rh000buv6x0egqxlmr","_id":"cjldh03rs000ouv6x3li5ii5p"},{"post_id":"cjldh03rc0009uv6xy35uya1i","tag_id":"cjldh03rh000buv6x0egqxlmr","_id":"cjldh03rt000ruv6x9shg1lsl"},{"post_id":"cjldh03rc0009uv6xy35uya1i","tag_id":"cjldh03rs000puv6xuc2mh0z2","_id":"cjldh03rt000suv6xang6g0o6"},{"post_id":"cjldh03rg000auv6xnp5dqyek","tag_id":"cjldh03rh000buv6x0egqxlmr","_id":"cjldh03ru000vuv6x3uvdhkuq"},{"post_id":"cjldh03rg000auv6xnp5dqyek","tag_id":"cjldh03ru000tuv6xvk6m4s7p","_id":"cjldh03rv000wuv6xgeg5ywfo"},{"post_id":"cjldh03rh000cuv6x0m70iwv3","tag_id":"cjldh03rh000buv6x0egqxlmr","_id":"cjldh03rv000yuv6xnsxi6et3"},{"post_id":"cjldh03rh000cuv6x0m70iwv3","tag_id":"cjldh03ru000uuv6xj63uilco","_id":"cjldh03rv000zuv6x3qr8e4z3"},{"post_id":"cjldh03rm000guv6xc0d6ais4","tag_id":"cjldh03rh000buv6x0egqxlmr","_id":"cjldh03rv0010uv6xcmsy7rru"},{"post_id":"cjldh03rm000guv6xc0d6ais4","tag_id":"cjldh03rv000xuv6xupqtwzcp","_id":"cjldh03rw0011uv6xz17g9qwu"}],"Tag":[{"name":"css","_id":"cjldh03qw0003uv6x44y11ckw"},{"name":"git","_id":"cjldh03rb0007uv6xailf5p7l"},{"name":"js","_id":"cjldh03rh000buv6x0egqxlmr"},{"name":"构建","_id":"cjldh03rs000puv6xuc2mh0z2"},{"name":"移动端","_id":"cjldh03ru000tuv6xvk6m4s7p"},{"name":"promise","_id":"cjldh03ru000uuv6xj63uilco"},{"name":"websocket","_id":"cjldh03rv000xuv6xupqtwzcp"}]}}