title: javascript作用域
date: 2018-12-28
tag:
 - js


<!--more-->

最近在看你不知道的javascript上卷，做下总结。

### 简述编译原理
JavaScript通常会被归类为“动态”或“解释执行”语言，但事实上它是一门编译语言。但与传统的编译语言不同，它不是提前编译的，编译结果也不能在分布式系统上进行移植。

在传统编译语言的流程中，程序中的一段源代码在执行前会经历三个步骤，统称为“编译”。 

`1. 分词 / 词法分析 `
`2. 解析 / 语法分析 `
`3. 代码生成`

  与其他语言不同，JavaScript的编译过程不是发生在构建之前的。对于JavaScript来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短）的时间内。 


举个栗子，var a = 2; JavaScript引擎会将它分为几步完成呢？ 
  答案是两步，JavaScript 会将其看成两句声明：var a; 和 a = 2;。第一个定义声明在编译阶段进行，第二个赋值声明会被留在原地等待执行阶段。 


下面是原书对这句声明的拆解分析：

`变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在引用域中查找该变量，如果能够找到就会对它赋值。`

  而要讲的LHS 和 RHS 就是上面说的对变量的两种查找操作，查找的过程是由作用域（词法作用域）进行协助，在编译的第二步中执行。

参考原文：https://blog.csdn.net/zwkkkk1/article/details/79725502 

### LHS（Left-Hand-Side）查询和RHS(Right-Hand-Side)查询
问题1：之前只知道在JavaScript中，如果一个变量a未经声明就直接取值，如 console.log(a)，会抛出ReferenceError异常；如果一个变量a未经声明，就直接赋值，如 a = 2，那么程序会自动创建一个全局变量a，然后再把2赋给a，但是这是为什么呢？

如 var a = 2，在JavaScript预编译结束后引擎开始执行代码，引擎执行它时，会通过查找变量a来判断它是否已声明过，查找的过程由作用域进行协助。有两种查询类型，LHS（Left-Hand-Side）查询和RHS(Right-Hand-Side)查询。

作用域是一套规则，用于确定在何处以及如何查找变量（标识符）。如果查找的目的是对变量进行赋值，那么就会使用LHS查询，如 a = 2；如果目的是获取变量的值，那么就会使用RHS查询，如 console.log(a)。非严格模式下，不成功的RHS引用（如找不到变量a）会导致抛出ReferenceError异常；不成功的LHS引用（如找不到变量a）会导致自动隐式地创建一个全局变量（a），该变量使用LHS引用的目标作为标识符，但严格模式下也会抛出ReferenceError异常。

赋值操作符会导致LHS查询，= 操作符或调用函数时传入参数的操作都会导致关联作用域的赋值操作。

LHS查询和RHS查询都会在当前执行作用域中开始，如果有需要（没找到），就会向上一级作用域继续查找目标标识符，这样每次上升一级作用域，最后抵达全局作用域，无论找到或者没找到都将停止。

参考原文：https://blog.csdn.net/binma2542/article/details/81169604 

### 词法作用域
“词法作用域”就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变。

```
function foo(a){ 
    var b = a * 2; 
    function bar(c){ 
        console.log(a,b,c); 
    } 
    bar(b * 3); 
} 
foo(2);
```
这个例子有三级嵌套的作用域

![GitHub set up](https://images2015.cnblogs.com/blog/549190/201604/549190-20160423231318757-428800616.png)
参考：https://www.cnblogs.com/GongQi/p/5426055.html
#### 欺骗词法

如果词法作用域完全由写代码期间函数所生命的位置来定义，那么可以通过几种方法来欺骗(修改)词法作用域，比如 eval、with 但是要注意：欺骗词法作用域会导致性能下降。

因为JS引擎会在编译阶段进行性能优化，其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。但是如果引擎在代码中找到 eval、with ，就会完全不做任何优化。

`eval:eval()函数接受一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。`

```
function foo(str, a){
  eval(str);
  console.log(a,b)
}
var b = 2;
foo("var b = 3;", 1)
//也就是永远都找不到外部的b，好像就是在动态的写代码一样
```
with:with通常被当作重复引用同一个对象中的多个属性的更快捷方式

```
eg:var obj = {
          a:1,
          b:2
          }
   obj.a = 2;
   obj.b = 3;
相当于：
  with(obj){
      a:2;
      b:33;
  }
//可以方便的访问对象属性
```

with可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。但是这个块内部正常的var声明并不会被限制在这个块的作用域中，而是被添加到with所在的函数作用域中，所以就有一个新的问题，变量会被泄露。

参考链接：https://www.jianshu.com/p/8fe5ba6d2b3b
### 函数作用域



