写法学习
数组
[].forEach.call()

因为document.querySelectorAll()返回的并不是我们想当然的数组，而是NodeList，对NodeList，它里面没有.forEach方法，我们使用了这样的方法进行循环：

var divs = document.querySelectorAll('div');



[].forEach.call(divs, function(div) {

  // do whatever

  div.style.color = "red";

});

初次看到[].forEach.call()这样的代码，我觉得这种写法很有趣，为什么要这样写？为什么要用空数值引申出的方法？于是研究了一下。

[]就是个数组，而且是用不到的空数组。用来就是为了访问它的数组相关方法，比如.forEach。这是一种简写，完整的写法应该是这样：

Array.prototype.forEach.call(...);

很显然，简写更方便。

至于forEach 方法，它可以接受一个函数参数：

[1,2,3].forEach(function (num) { console.log(num); });

上面的这句代码中，我们可以访问this对象，也就是[1,2,3]，可以看出，这个this是个数组。

最后，.call是一个prototype，JavaScript函数内置的。.call使用它的第一个参数替换掉上面说的这个this，也就是你要传人的数组，其它的参数就跟forEach方法的参数一样了。

[1, 2, 3].forEach.call(["a", "b", "c"], function (item, i, arr) {

    console.log(i + ": " + item);

});

// 0: "a"

// 1: "b"

// 2: "c"

因此，[].forEach.call()是一种快速的方法访问forEach，并将空数组的this换成想要遍历的list。

对象
Object.keys()

Object.keys方法的参数是一个对象，返回一个数组。该数组的成员都是该对象自身的（而不是继承的）所有属性名。

var obj = {
  p1: 123,
  p2: 456
};
Object.keys(obj) // ["p1", "p2"]
模块化写法
es6
export function addStatisticsCode() {} 

export const provinceList = [{

text: '北京市',

      value: '110000'

}]


export {commonFn}

对应导入  

import {addStatisticsCode} from './common/js/addStatisticsCode';



默认导出

let myAjax = {

env: process.env.NODE_ENV,

get(){},

}

export default myAjax 

默认导出的引入不能用{}大括号

import myAjax from './request';

commonJs
var ora = require('ora')

module.exports =

命名空间
let statisticsCode = {

'BaiDu': function () {},

'GrowIo': function () {},

get(){},
env: process.env.NODE_ENV,

}

立即执行函数

var BJ_REPORT = function (global) {

if (global.BJ_REPORT) return global.BJ_REPORT;



init: function (e) { },

}(window);

window.BJ_REPORT.init({ });

错误捕获
try{

}catch(e){

console.log(e)

}

promise
let [ askDataRes, recommendDataRes ] = await Promise.all([

api.getPublicAsk({ ask_id }),

api.getRandAsk({ ask_id }),

]);

类的静态方法
export default class Tips {


static success(title, duration = 1000) {

wx.showToast({

title: title,

icon: 'success',

mask: true,

duration: duration

})

}


/**

* 警告框

*/

static warning(title, duration = 1000) {

wx.showToast({

title: title,

icon: 'none',

mask: true,

duration: duration

});

}

}


import tips from '../../utils/tips';


tips.warning(msg);

解构写法

let { page, count, teacherArr } = this.teacherList,

{ curSort, isUp, sortObj, highCateId } = this, //这一行相当于data里面的值，let curSort = this.curSort


onLoad({ high_cate_id = 1, name = '婚姻家庭' } = options) {

wx.setNavigationBarTitle({

    title: name,

})

};

splice

splice() 方法通过删除或替换现有元素或者原地添加新的元素来修改数组,并以数组形式返回被修改的内容。此方法会改变原数组。

语法：array.splice(start[, deleteCount[, item1[, item2[, ...]]]])

start指定修改的开始位置（从0计数）。如果超出了数组的长度，则从数组末尾开始添加内容；如果是负值，则表示从数组末位开始的第几位（从-1计数，这意味着-n是倒数第n个元素并且等价于array.length-n）；如果负数的绝对值大于数组的长度，则表示开始位置为第0位。deleteCount 可选整数，表示要移除的数组元素的个数。如果 deleteCount 大于 start 之后的元素的总数，则从 start 后面的元素都将被删除（含第 start 位）。如果 deleteCount 被省略了，或者它的值大于等于array.length - start(也就是说，如果它大于或者等于start之后的所有元素的数量)，那么start之后数组的所有元素都会被删除。如果 deleteCount 是 0 或者负数，则不移除元素。这种情况下，至少应添加一个新元素。item1, item2, ... 可选要添加进数组的元素,从start 位置开始。如果不指定，则 splice() 将只删除数组元素。

 map
返回一个数组，数组中元素为原始数组的平方根:

var numbers = [4, 9, 16, 25];



function myFunction() {

    x = document.getElementById("demo")

    x.innerHTML = numbers.map(Math.sqrt);

}

输出结果为:

2,3,4,5

共享结构的对象
希望大家都知道这种 ES6 的语法：

const obj = { a: 1, b: 2}
const obj2 = { ...obj } // => { a: 1, b: 2 }
const obj2 = { ...obj } 其实就是新建一个对象 obj2，然后把 obj 所有的属性都复制到 obj2 里面，相当于对象的浅复制。上面的 obj 里面的内容和 obj2 是完全一样的，但是却是两个不同的对象。除了浅复制对象，还可以覆盖、拓展对象属性：

const obj = { a: 1, b: 2}
const obj2 = { ...obj, b: 3, c: 4} // => { a: 1, b: 3, c: 4 }，覆盖了 b，新增了 c
let appState = {

title: {

text: 'React.js 小书',

color: 'red',

},

content: {

text: 'React.js 小书内容',

color: 'blue'

}

}


我们可以把这种特性应用在 state 的更新上，我们禁止直接修改原来的对象，一旦你要修改某些东西，你就得把修改路径上的所有对象复制一遍，例如，我们不写下面的修改代码：

appState.title.text = '《React.js 小书》'
取而代之的是，我们新建一个 appState，新建 appState.title，新建 appState.title.text：

let newAppState = { // 新建一个 newAppState
  ...appState, // 复制 appState 里面的内容
  title: { // 用一个新的对象覆盖原来的 title 属性
    ...appState.title, // 复制原来 title 对象里面的内容
    text: '《React.js 小书》' // 覆盖 text 属性
  }
}
appState 和 newAppState 其实是两个不同的对象，因为对象浅复制的缘故，其实它们里面的属性 content 指向的是同一个对象；但是因为 title 被一个新的对象覆盖了，所以它们的 title 属性指向的对象是不同的。同样地，修改 appState.title.color：



image.png

我们每次修改某些数据的时候，都不会碰原来的数据，而是把需要修改数据路径上的对象都 copy 一个出来。这样有什么好处？看看我们的目的达到了：

appState !== newAppState // true，两个对象引用不同，数据变化了，重新渲染
appState.title !== newAppState.title // true，两个对象引用不同，数据变化了，重新渲染
appState.content !== appState.content // false，两个对象引用相同，数据没有变化，
修改数据的时候就把修改路径都复制一遍，但是保持其他内容不变，最后的所有对象具有某些不变共享的结构（例如上面三个对象都共享 content 对象）。大多数情况下我们可以保持 50% 以上的内容具有共享结构，这种操作具有非常优良的特性，我们可以用它来优化上面的渲染性能。






